
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model FeatureRequest
 * 
 */
export type FeatureRequest = $Result.DefaultSelection<Prisma.$FeatureRequestPayload>
/**
 * Model WaitlistRequest
 * 
 */
export type WaitlistRequest = $Result.DefaultSelection<Prisma.$WaitlistRequestPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model DailyFocus
 * 
 */
export type DailyFocus = $Result.DefaultSelection<Prisma.$DailyFocusPayload>
/**
 * Model AutoSetting
 * 
 */
export type AutoSetting = $Result.DefaultSelection<Prisma.$AutoSettingPayload>
/**
 * Model ReadingList
 * 
 */
export type ReadingList = $Result.DefaultSelection<Prisma.$ReadingListPayload>
/**
 * Model BibEntry
 * 
 */
export type BibEntry = $Result.DefaultSelection<Prisma.$BibEntryPayload>
/**
 * Model CitationsGroup
 * 
 */
export type CitationsGroup = $Result.DefaultSelection<Prisma.$CitationsGroupPayload>
/**
 * Model Bib
 * 
 */
export type Bib = $Result.DefaultSelection<Prisma.$BibPayload>
/**
 * Model GoogleCalendarAuth
 * 
 */
export type GoogleCalendarAuth = $Result.DefaultSelection<Prisma.$GoogleCalendarAuthPayload>
/**
 * Model Snippet
 * 
 */
export type Snippet = $Result.DefaultSelection<Prisma.$SnippetPayload>
/**
 * Model RelatedValues
 * 
 */
export type RelatedValues = $Result.DefaultSelection<Prisma.$RelatedValuesPayload>
/**
 * Model Equation
 * 
 */
export type Equation = $Result.DefaultSelection<Prisma.$EquationPayload>
/**
 * Model Definition
 * 
 */
export type Definition = $Result.DefaultSelection<Prisma.$DefinitionPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model SettingsAppendix
 * 
 */
export type SettingsAppendix = $Result.DefaultSelection<Prisma.$SettingsAppendixPayload>
/**
 * Model RandomImage
 * 
 */
export type RandomImage = $Result.DefaultSelection<Prisma.$RandomImagePayload>
/**
 * Model NoteType
 * 
 */
export type NoteType = $Result.DefaultSelection<Prisma.$NoteTypePayload>
/**
 * Model QAPair
 * 
 */
export type QAPair = $Result.DefaultSelection<Prisma.$QAPairPayload>
/**
 * Model PracticeExam
 * 
 */
export type PracticeExam = $Result.DefaultSelection<Prisma.$PracticeExamPayload>
/**
 * Model SequentialNoteList
 * 
 */
export type SequentialNoteList = $Result.DefaultSelection<Prisma.$SequentialNoteListPayload>
/**
 * Model MdxNote
 * 
 */
export type MdxNote = $Result.DefaultSelection<Prisma.$MdxNotePayload>
/**
 * Model Ipynb
 * 
 */
export type Ipynb = $Result.DefaultSelection<Prisma.$IpynbPayload>
/**
 * Model ToDoList
 * 
 */
export type ToDoList = $Result.DefaultSelection<Prisma.$ToDoListPayload>
/**
 * Model ToDo
 * 
 */
export type ToDo = $Result.DefaultSelection<Prisma.$ToDoPayload>
/**
 * Model KanBanCard
 * 
 */
export type KanBanCard = $Result.DefaultSelection<Prisma.$KanBanCardPayload>
/**
 * Model KanBanList
 * 
 */
export type KanBanList = $Result.DefaultSelection<Prisma.$KanBanListPayload>
/**
 * Model Kanban
 * 
 */
export type Kanban = $Result.DefaultSelection<Prisma.$KanbanPayload>
/**
 * Model TimePeriod
 * 
 */
export type TimePeriod = $Result.DefaultSelection<Prisma.$TimePeriodPayload>
/**
 * Model Diet
 * 
 */
export type Diet = $Result.DefaultSelection<Prisma.$DietPayload>
/**
 * Model Serving
 * 
 */
export type Serving = $Result.DefaultSelection<Prisma.$ServingPayload>
/**
 * Model DietaryItem
 * 
 */
export type DietaryItem = $Result.DefaultSelection<Prisma.$DietaryItemPayload>
/**
 * Model HealthReport
 * 
 */
export type HealthReport = $Result.DefaultSelection<Prisma.$HealthReportPayload>
/**
 * Model Whiteboard
 * 
 */
export type Whiteboard = $Result.DefaultSelection<Prisma.$WhiteboardPayload>
/**
 * Model DJT
 * 
 */
export type DJT = $Result.DefaultSelection<Prisma.$DJTPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const autoSetting: {
  tag: 'tag',
  topic: 'topic',
  subject: 'subject'
};

export type autoSetting = (typeof autoSetting)[keyof typeof autoSetting]


export const Technologies: {
  python: 'python',
  javascript: 'javascript',
  lua: 'lua',
  typescript: 'typescript',
  css: 'css',
  scss: 'scss',
  react: 'react',
  prisma: 'prisma',
  tailwind: 'tailwind',
  node: 'node',
  bash: 'bash',
  zsh: 'zsh',
  bibtex: 'bibtex',
  latex: 'latex',
  json: 'json',
  applescript: 'applescript',
  swift: 'swift'
};

export type Technologies = (typeof Technologies)[keyof typeof Technologies]


export const ImageAlignment: {
  bottom: 'bottom',
  center: 'center',
  top: 'top',
  left: 'left',
  right: 'right'
};

export type ImageAlignment = (typeof ImageAlignment)[keyof typeof ImageAlignment]


export const TaskCategory: {
  bug: 'bug',
  feature: 'feature',
  documentation: 'documentation',
  online: 'online',
  priority: 'priority',
  urgent: 'urgent',
  work: 'work',
  gym: 'gym',
  freetime: 'freetime',
  study: 'study',
  research: 'research',
  paper: 'paper'
};

export type TaskCategory = (typeof TaskCategory)[keyof typeof TaskCategory]


export const ToDoListStatus: {
  ToDo: 'ToDo',
  In_Progress: 'In_Progress',
  Backlog: 'Backlog',
  Cancelled: 'Cancelled',
  Done: 'Done',
  Future: 'Future'
};

export type ToDoListStatus = (typeof ToDoListStatus)[keyof typeof ToDoListStatus]


export const TERTIARY_TOGGLE: {
  on: 'on',
  off: 'off',
  partial: 'partial'
};

export type TERTIARY_TOGGLE = (typeof TERTIARY_TOGGLE)[keyof typeof TERTIARY_TOGGLE]


export const DIETARY_GOAL: {
  weightLoss: 'weightLoss',
  muscleGain: 'muscleGain',
  autoImmune: 'autoImmune',
  allergy: 'allergy',
  gsd: 'gsd',
  skin: 'skin',
  sexDrive: 'sexDrive',
  anxiety: 'anxiety',
  memory: 'memory',
  energy: 'energy',
  adhd: 'adhd',
  sleep: 'sleep',
  depression: 'depression',
  mentalHealth: 'mentalHealth'
};

export type DIETARY_GOAL = (typeof DIETARY_GOAL)[keyof typeof DIETARY_GOAL]


export const QUANTITY_GUESS: {
  nibble: 'nibble',
  fewBites: 'fewBites',
  snack: 'snack',
  smallMeal: 'smallMeal',
  fullMeal: 'fullMeal',
  largeMeal: 'largeMeal',
  multipleMeals: 'multipleMeals',
  allMeals: 'allMeals',
  completelyStuffed: 'completelyStuffed'
};

export type QUANTITY_GUESS = (typeof QUANTITY_GUESS)[keyof typeof QUANTITY_GUESS]

}

export type autoSetting = $Enums.autoSetting

export const autoSetting: typeof $Enums.autoSetting

export type Technologies = $Enums.Technologies

export const Technologies: typeof $Enums.Technologies

export type ImageAlignment = $Enums.ImageAlignment

export const ImageAlignment: typeof $Enums.ImageAlignment

export type TaskCategory = $Enums.TaskCategory

export const TaskCategory: typeof $Enums.TaskCategory

export type ToDoListStatus = $Enums.ToDoListStatus

export const ToDoListStatus: typeof $Enums.ToDoListStatus

export type TERTIARY_TOGGLE = $Enums.TERTIARY_TOGGLE

export const TERTIARY_TOGGLE: typeof $Enums.TERTIARY_TOGGLE

export type DIETARY_GOAL = $Enums.DIETARY_GOAL

export const DIETARY_GOAL: typeof $Enums.DIETARY_GOAL

export type QUANTITY_GUESS = $Enums.QUANTITY_GUESS

export const QUANTITY_GUESS: typeof $Enums.QUANTITY_GUESS

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more FeatureRequests
 * const featureRequests = await prisma.featureRequest.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more FeatureRequests
   * const featureRequests = await prisma.featureRequest.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.featureRequest`: Exposes CRUD operations for the **FeatureRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureRequests
    * const featureRequests = await prisma.featureRequest.findMany()
    * ```
    */
  get featureRequest(): Prisma.FeatureRequestDelegate<ExtArgs>;

  /**
   * `prisma.waitlistRequest`: Exposes CRUD operations for the **WaitlistRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WaitlistRequests
    * const waitlistRequests = await prisma.waitlistRequest.findMany()
    * ```
    */
  get waitlistRequest(): Prisma.WaitlistRequestDelegate<ExtArgs>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs>;

  /**
   * `prisma.dailyFocus`: Exposes CRUD operations for the **DailyFocus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyFoci
    * const dailyFoci = await prisma.dailyFocus.findMany()
    * ```
    */
  get dailyFocus(): Prisma.DailyFocusDelegate<ExtArgs>;

  /**
   * `prisma.autoSetting`: Exposes CRUD operations for the **AutoSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoSettings
    * const autoSettings = await prisma.autoSetting.findMany()
    * ```
    */
  get autoSetting(): Prisma.AutoSettingDelegate<ExtArgs>;

  /**
   * `prisma.readingList`: Exposes CRUD operations for the **ReadingList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReadingLists
    * const readingLists = await prisma.readingList.findMany()
    * ```
    */
  get readingList(): Prisma.ReadingListDelegate<ExtArgs>;

  /**
   * `prisma.bibEntry`: Exposes CRUD operations for the **BibEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BibEntries
    * const bibEntries = await prisma.bibEntry.findMany()
    * ```
    */
  get bibEntry(): Prisma.BibEntryDelegate<ExtArgs>;

  /**
   * `prisma.citationsGroup`: Exposes CRUD operations for the **CitationsGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CitationsGroups
    * const citationsGroups = await prisma.citationsGroup.findMany()
    * ```
    */
  get citationsGroup(): Prisma.CitationsGroupDelegate<ExtArgs>;

  /**
   * `prisma.bib`: Exposes CRUD operations for the **Bib** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bibs
    * const bibs = await prisma.bib.findMany()
    * ```
    */
  get bib(): Prisma.BibDelegate<ExtArgs>;

  /**
   * `prisma.googleCalendarAuth`: Exposes CRUD operations for the **GoogleCalendarAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoogleCalendarAuths
    * const googleCalendarAuths = await prisma.googleCalendarAuth.findMany()
    * ```
    */
  get googleCalendarAuth(): Prisma.GoogleCalendarAuthDelegate<ExtArgs>;

  /**
   * `prisma.snippet`: Exposes CRUD operations for the **Snippet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Snippets
    * const snippets = await prisma.snippet.findMany()
    * ```
    */
  get snippet(): Prisma.SnippetDelegate<ExtArgs>;

  /**
   * `prisma.relatedValues`: Exposes CRUD operations for the **RelatedValues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelatedValues
    * const relatedValues = await prisma.relatedValues.findMany()
    * ```
    */
  get relatedValues(): Prisma.RelatedValuesDelegate<ExtArgs>;

  /**
   * `prisma.equation`: Exposes CRUD operations for the **Equation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equations
    * const equations = await prisma.equation.findMany()
    * ```
    */
  get equation(): Prisma.EquationDelegate<ExtArgs>;

  /**
   * `prisma.definition`: Exposes CRUD operations for the **Definition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Definitions
    * const definitions = await prisma.definition.findMany()
    * ```
    */
  get definition(): Prisma.DefinitionDelegate<ExtArgs>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs>;

  /**
   * `prisma.settingsAppendix`: Exposes CRUD operations for the **SettingsAppendix** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingsAppendices
    * const settingsAppendices = await prisma.settingsAppendix.findMany()
    * ```
    */
  get settingsAppendix(): Prisma.SettingsAppendixDelegate<ExtArgs>;

  /**
   * `prisma.randomImage`: Exposes CRUD operations for the **RandomImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RandomImages
    * const randomImages = await prisma.randomImage.findMany()
    * ```
    */
  get randomImage(): Prisma.RandomImageDelegate<ExtArgs>;

  /**
   * `prisma.noteType`: Exposes CRUD operations for the **NoteType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteTypes
    * const noteTypes = await prisma.noteType.findMany()
    * ```
    */
  get noteType(): Prisma.NoteTypeDelegate<ExtArgs>;

  /**
   * `prisma.qAPair`: Exposes CRUD operations for the **QAPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QAPairs
    * const qAPairs = await prisma.qAPair.findMany()
    * ```
    */
  get qAPair(): Prisma.QAPairDelegate<ExtArgs>;

  /**
   * `prisma.practiceExam`: Exposes CRUD operations for the **PracticeExam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PracticeExams
    * const practiceExams = await prisma.practiceExam.findMany()
    * ```
    */
  get practiceExam(): Prisma.PracticeExamDelegate<ExtArgs>;

  /**
   * `prisma.sequentialNoteList`: Exposes CRUD operations for the **SequentialNoteList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SequentialNoteLists
    * const sequentialNoteLists = await prisma.sequentialNoteList.findMany()
    * ```
    */
  get sequentialNoteList(): Prisma.SequentialNoteListDelegate<ExtArgs>;

  /**
   * `prisma.mdxNote`: Exposes CRUD operations for the **MdxNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MdxNotes
    * const mdxNotes = await prisma.mdxNote.findMany()
    * ```
    */
  get mdxNote(): Prisma.MdxNoteDelegate<ExtArgs>;

  /**
   * `prisma.ipynb`: Exposes CRUD operations for the **Ipynb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ipynbs
    * const ipynbs = await prisma.ipynb.findMany()
    * ```
    */
  get ipynb(): Prisma.IpynbDelegate<ExtArgs>;

  /**
   * `prisma.toDoList`: Exposes CRUD operations for the **ToDoList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ToDoLists
    * const toDoLists = await prisma.toDoList.findMany()
    * ```
    */
  get toDoList(): Prisma.ToDoListDelegate<ExtArgs>;

  /**
   * `prisma.toDo`: Exposes CRUD operations for the **ToDo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ToDos
    * const toDos = await prisma.toDo.findMany()
    * ```
    */
  get toDo(): Prisma.ToDoDelegate<ExtArgs>;

  /**
   * `prisma.kanBanCard`: Exposes CRUD operations for the **KanBanCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KanBanCards
    * const kanBanCards = await prisma.kanBanCard.findMany()
    * ```
    */
  get kanBanCard(): Prisma.KanBanCardDelegate<ExtArgs>;

  /**
   * `prisma.kanBanList`: Exposes CRUD operations for the **KanBanList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KanBanLists
    * const kanBanLists = await prisma.kanBanList.findMany()
    * ```
    */
  get kanBanList(): Prisma.KanBanListDelegate<ExtArgs>;

  /**
   * `prisma.kanban`: Exposes CRUD operations for the **Kanban** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kanbans
    * const kanbans = await prisma.kanban.findMany()
    * ```
    */
  get kanban(): Prisma.KanbanDelegate<ExtArgs>;

  /**
   * `prisma.timePeriod`: Exposes CRUD operations for the **TimePeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimePeriods
    * const timePeriods = await prisma.timePeriod.findMany()
    * ```
    */
  get timePeriod(): Prisma.TimePeriodDelegate<ExtArgs>;

  /**
   * `prisma.diet`: Exposes CRUD operations for the **Diet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diets
    * const diets = await prisma.diet.findMany()
    * ```
    */
  get diet(): Prisma.DietDelegate<ExtArgs>;

  /**
   * `prisma.serving`: Exposes CRUD operations for the **Serving** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servings
    * const servings = await prisma.serving.findMany()
    * ```
    */
  get serving(): Prisma.ServingDelegate<ExtArgs>;

  /**
   * `prisma.dietaryItem`: Exposes CRUD operations for the **DietaryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DietaryItems
    * const dietaryItems = await prisma.dietaryItem.findMany()
    * ```
    */
  get dietaryItem(): Prisma.DietaryItemDelegate<ExtArgs>;

  /**
   * `prisma.healthReport`: Exposes CRUD operations for the **HealthReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthReports
    * const healthReports = await prisma.healthReport.findMany()
    * ```
    */
  get healthReport(): Prisma.HealthReportDelegate<ExtArgs>;

  /**
   * `prisma.whiteboard`: Exposes CRUD operations for the **Whiteboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whiteboards
    * const whiteboards = await prisma.whiteboard.findMany()
    * ```
    */
  get whiteboard(): Prisma.WhiteboardDelegate<ExtArgs>;

  /**
   * `prisma.dJT`: Exposes CRUD operations for the **DJT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DJTS
    * const dJTS = await prisma.dJT.findMany()
    * ```
    */
  get dJT(): Prisma.DJTDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.16.2
   * Query Engine version: 34ace0eb2704183d2c05b60b52fba5c43c13f303
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    FeatureRequest: 'FeatureRequest',
    WaitlistRequest: 'WaitlistRequest',
    Subject: 'Subject',
    Topic: 'Topic',
    Tag: 'Tag',
    Quote: 'Quote',
    DailyFocus: 'DailyFocus',
    AutoSetting: 'AutoSetting',
    ReadingList: 'ReadingList',
    BibEntry: 'BibEntry',
    CitationsGroup: 'CitationsGroup',
    Bib: 'Bib',
    GoogleCalendarAuth: 'GoogleCalendarAuth',
    Snippet: 'Snippet',
    RelatedValues: 'RelatedValues',
    Equation: 'Equation',
    Definition: 'Definition',
    Settings: 'Settings',
    SettingsAppendix: 'SettingsAppendix',
    RandomImage: 'RandomImage',
    NoteType: 'NoteType',
    QAPair: 'QAPair',
    PracticeExam: 'PracticeExam',
    SequentialNoteList: 'SequentialNoteList',
    MdxNote: 'MdxNote',
    Ipynb: 'Ipynb',
    ToDoList: 'ToDoList',
    ToDo: 'ToDo',
    KanBanCard: 'KanBanCard',
    KanBanList: 'KanBanList',
    Kanban: 'Kanban',
    TimePeriod: 'TimePeriod',
    Diet: 'Diet',
    Serving: 'Serving',
    DietaryItem: 'DietaryItem',
    HealthReport: 'HealthReport',
    Whiteboard: 'Whiteboard',
    DJT: 'DJT'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "featureRequest" | "waitlistRequest" | "subject" | "topic" | "tag" | "quote" | "dailyFocus" | "autoSetting" | "readingList" | "bibEntry" | "citationsGroup" | "bib" | "googleCalendarAuth" | "snippet" | "relatedValues" | "equation" | "definition" | "settings" | "settingsAppendix" | "randomImage" | "noteType" | "qAPair" | "practiceExam" | "sequentialNoteList" | "mdxNote" | "ipynb" | "toDoList" | "toDo" | "kanBanCard" | "kanBanList" | "kanban" | "timePeriod" | "diet" | "serving" | "dietaryItem" | "healthReport" | "whiteboard" | "dJT"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      FeatureRequest: {
        payload: Prisma.$FeatureRequestPayload<ExtArgs>
        fields: Prisma.FeatureRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload>
          }
          findFirst: {
            args: Prisma.FeatureRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload>
          }
          findMany: {
            args: Prisma.FeatureRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload>[]
          }
          create: {
            args: Prisma.FeatureRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload>
          }
          createMany: {
            args: Prisma.FeatureRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload>[]
          }
          delete: {
            args: Prisma.FeatureRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload>
          }
          update: {
            args: Prisma.FeatureRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload>
          }
          deleteMany: {
            args: Prisma.FeatureRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeatureRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestPayload>
          }
          aggregate: {
            args: Prisma.FeatureRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureRequest>
          }
          groupBy: {
            args: Prisma.FeatureRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureRequestCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureRequestCountAggregateOutputType> | number
          }
        }
      }
      WaitlistRequest: {
        payload: Prisma.$WaitlistRequestPayload<ExtArgs>
        fields: Prisma.WaitlistRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WaitlistRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WaitlistRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload>
          }
          findFirst: {
            args: Prisma.WaitlistRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WaitlistRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload>
          }
          findMany: {
            args: Prisma.WaitlistRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload>[]
          }
          create: {
            args: Prisma.WaitlistRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload>
          }
          createMany: {
            args: Prisma.WaitlistRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WaitlistRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload>[]
          }
          delete: {
            args: Prisma.WaitlistRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload>
          }
          update: {
            args: Prisma.WaitlistRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload>
          }
          deleteMany: {
            args: Prisma.WaitlistRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WaitlistRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WaitlistRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitlistRequestPayload>
          }
          aggregate: {
            args: Prisma.WaitlistRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWaitlistRequest>
          }
          groupBy: {
            args: Prisma.WaitlistRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<WaitlistRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.WaitlistRequestCountArgs<ExtArgs>
            result: $Utils.Optional<WaitlistRequestCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      DailyFocus: {
        payload: Prisma.$DailyFocusPayload<ExtArgs>
        fields: Prisma.DailyFocusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyFocusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyFocusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload>
          }
          findFirst: {
            args: Prisma.DailyFocusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyFocusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload>
          }
          findMany: {
            args: Prisma.DailyFocusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload>[]
          }
          create: {
            args: Prisma.DailyFocusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload>
          }
          createMany: {
            args: Prisma.DailyFocusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyFocusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload>[]
          }
          delete: {
            args: Prisma.DailyFocusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload>
          }
          update: {
            args: Prisma.DailyFocusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload>
          }
          deleteMany: {
            args: Prisma.DailyFocusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyFocusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyFocusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyFocusPayload>
          }
          aggregate: {
            args: Prisma.DailyFocusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyFocus>
          }
          groupBy: {
            args: Prisma.DailyFocusGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyFocusGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyFocusCountArgs<ExtArgs>
            result: $Utils.Optional<DailyFocusCountAggregateOutputType> | number
          }
        }
      }
      AutoSetting: {
        payload: Prisma.$AutoSettingPayload<ExtArgs>
        fields: Prisma.AutoSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload>
          }
          findFirst: {
            args: Prisma.AutoSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload>
          }
          findMany: {
            args: Prisma.AutoSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload>[]
          }
          create: {
            args: Prisma.AutoSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload>
          }
          createMany: {
            args: Prisma.AutoSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutoSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload>[]
          }
          delete: {
            args: Prisma.AutoSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload>
          }
          update: {
            args: Prisma.AutoSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload>
          }
          deleteMany: {
            args: Prisma.AutoSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoSettingPayload>
          }
          aggregate: {
            args: Prisma.AutoSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoSetting>
          }
          groupBy: {
            args: Prisma.AutoSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoSettingCountArgs<ExtArgs>
            result: $Utils.Optional<AutoSettingCountAggregateOutputType> | number
          }
        }
      }
      ReadingList: {
        payload: Prisma.$ReadingListPayload<ExtArgs>
        fields: Prisma.ReadingListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReadingListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReadingListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload>
          }
          findFirst: {
            args: Prisma.ReadingListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReadingListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload>
          }
          findMany: {
            args: Prisma.ReadingListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload>[]
          }
          create: {
            args: Prisma.ReadingListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload>
          }
          createMany: {
            args: Prisma.ReadingListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReadingListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload>[]
          }
          delete: {
            args: Prisma.ReadingListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload>
          }
          update: {
            args: Prisma.ReadingListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload>
          }
          deleteMany: {
            args: Prisma.ReadingListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReadingListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReadingListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingListPayload>
          }
          aggregate: {
            args: Prisma.ReadingListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReadingList>
          }
          groupBy: {
            args: Prisma.ReadingListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReadingListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReadingListCountArgs<ExtArgs>
            result: $Utils.Optional<ReadingListCountAggregateOutputType> | number
          }
        }
      }
      BibEntry: {
        payload: Prisma.$BibEntryPayload<ExtArgs>
        fields: Prisma.BibEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BibEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BibEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload>
          }
          findFirst: {
            args: Prisma.BibEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BibEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload>
          }
          findMany: {
            args: Prisma.BibEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload>[]
          }
          create: {
            args: Prisma.BibEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload>
          }
          createMany: {
            args: Prisma.BibEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BibEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload>[]
          }
          delete: {
            args: Prisma.BibEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload>
          }
          update: {
            args: Prisma.BibEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload>
          }
          deleteMany: {
            args: Prisma.BibEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BibEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BibEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibEntryPayload>
          }
          aggregate: {
            args: Prisma.BibEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBibEntry>
          }
          groupBy: {
            args: Prisma.BibEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BibEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BibEntryCountArgs<ExtArgs>
            result: $Utils.Optional<BibEntryCountAggregateOutputType> | number
          }
        }
      }
      CitationsGroup: {
        payload: Prisma.$CitationsGroupPayload<ExtArgs>
        fields: Prisma.CitationsGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CitationsGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CitationsGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload>
          }
          findFirst: {
            args: Prisma.CitationsGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CitationsGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload>
          }
          findMany: {
            args: Prisma.CitationsGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload>[]
          }
          create: {
            args: Prisma.CitationsGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload>
          }
          createMany: {
            args: Prisma.CitationsGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CitationsGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload>[]
          }
          delete: {
            args: Prisma.CitationsGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload>
          }
          update: {
            args: Prisma.CitationsGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload>
          }
          deleteMany: {
            args: Prisma.CitationsGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CitationsGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CitationsGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationsGroupPayload>
          }
          aggregate: {
            args: Prisma.CitationsGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCitationsGroup>
          }
          groupBy: {
            args: Prisma.CitationsGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitationsGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CitationsGroupCountArgs<ExtArgs>
            result: $Utils.Optional<CitationsGroupCountAggregateOutputType> | number
          }
        }
      }
      Bib: {
        payload: Prisma.$BibPayload<ExtArgs>
        fields: Prisma.BibFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BibFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BibFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload>
          }
          findFirst: {
            args: Prisma.BibFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BibFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload>
          }
          findMany: {
            args: Prisma.BibFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload>[]
          }
          create: {
            args: Prisma.BibCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload>
          }
          createMany: {
            args: Prisma.BibCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BibCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload>[]
          }
          delete: {
            args: Prisma.BibDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload>
          }
          update: {
            args: Prisma.BibUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload>
          }
          deleteMany: {
            args: Prisma.BibDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BibUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BibUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BibPayload>
          }
          aggregate: {
            args: Prisma.BibAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBib>
          }
          groupBy: {
            args: Prisma.BibGroupByArgs<ExtArgs>
            result: $Utils.Optional<BibGroupByOutputType>[]
          }
          count: {
            args: Prisma.BibCountArgs<ExtArgs>
            result: $Utils.Optional<BibCountAggregateOutputType> | number
          }
        }
      }
      GoogleCalendarAuth: {
        payload: Prisma.$GoogleCalendarAuthPayload<ExtArgs>
        fields: Prisma.GoogleCalendarAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoogleCalendarAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoogleCalendarAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload>
          }
          findFirst: {
            args: Prisma.GoogleCalendarAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoogleCalendarAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload>
          }
          findMany: {
            args: Prisma.GoogleCalendarAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload>[]
          }
          create: {
            args: Prisma.GoogleCalendarAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload>
          }
          createMany: {
            args: Prisma.GoogleCalendarAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoogleCalendarAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload>[]
          }
          delete: {
            args: Prisma.GoogleCalendarAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload>
          }
          update: {
            args: Prisma.GoogleCalendarAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload>
          }
          deleteMany: {
            args: Prisma.GoogleCalendarAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoogleCalendarAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoogleCalendarAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleCalendarAuthPayload>
          }
          aggregate: {
            args: Prisma.GoogleCalendarAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoogleCalendarAuth>
          }
          groupBy: {
            args: Prisma.GoogleCalendarAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoogleCalendarAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoogleCalendarAuthCountArgs<ExtArgs>
            result: $Utils.Optional<GoogleCalendarAuthCountAggregateOutputType> | number
          }
        }
      }
      Snippet: {
        payload: Prisma.$SnippetPayload<ExtArgs>
        fields: Prisma.SnippetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SnippetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SnippetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          findFirst: {
            args: Prisma.SnippetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SnippetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          findMany: {
            args: Prisma.SnippetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>[]
          }
          create: {
            args: Prisma.SnippetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          createMany: {
            args: Prisma.SnippetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SnippetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>[]
          }
          delete: {
            args: Prisma.SnippetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          update: {
            args: Prisma.SnippetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          deleteMany: {
            args: Prisma.SnippetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SnippetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SnippetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          aggregate: {
            args: Prisma.SnippetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSnippet>
          }
          groupBy: {
            args: Prisma.SnippetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SnippetGroupByOutputType>[]
          }
          count: {
            args: Prisma.SnippetCountArgs<ExtArgs>
            result: $Utils.Optional<SnippetCountAggregateOutputType> | number
          }
        }
      }
      RelatedValues: {
        payload: Prisma.$RelatedValuesPayload<ExtArgs>
        fields: Prisma.RelatedValuesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelatedValuesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelatedValuesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload>
          }
          findFirst: {
            args: Prisma.RelatedValuesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelatedValuesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload>
          }
          findMany: {
            args: Prisma.RelatedValuesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload>[]
          }
          create: {
            args: Prisma.RelatedValuesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload>
          }
          createMany: {
            args: Prisma.RelatedValuesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelatedValuesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload>[]
          }
          delete: {
            args: Prisma.RelatedValuesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload>
          }
          update: {
            args: Prisma.RelatedValuesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload>
          }
          deleteMany: {
            args: Prisma.RelatedValuesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelatedValuesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelatedValuesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedValuesPayload>
          }
          aggregate: {
            args: Prisma.RelatedValuesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelatedValues>
          }
          groupBy: {
            args: Prisma.RelatedValuesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelatedValuesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelatedValuesCountArgs<ExtArgs>
            result: $Utils.Optional<RelatedValuesCountAggregateOutputType> | number
          }
        }
      }
      Equation: {
        payload: Prisma.$EquationPayload<ExtArgs>
        fields: Prisma.EquationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload>
          }
          findFirst: {
            args: Prisma.EquationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload>
          }
          findMany: {
            args: Prisma.EquationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload>[]
          }
          create: {
            args: Prisma.EquationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload>
          }
          createMany: {
            args: Prisma.EquationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload>[]
          }
          delete: {
            args: Prisma.EquationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload>
          }
          update: {
            args: Prisma.EquationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload>
          }
          deleteMany: {
            args: Prisma.EquationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquationPayload>
          }
          aggregate: {
            args: Prisma.EquationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquation>
          }
          groupBy: {
            args: Prisma.EquationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquationCountArgs<ExtArgs>
            result: $Utils.Optional<EquationCountAggregateOutputType> | number
          }
        }
      }
      Definition: {
        payload: Prisma.$DefinitionPayload<ExtArgs>
        fields: Prisma.DefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload>
          }
          findFirst: {
            args: Prisma.DefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload>
          }
          findMany: {
            args: Prisma.DefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload>[]
          }
          create: {
            args: Prisma.DefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload>
          }
          createMany: {
            args: Prisma.DefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload>[]
          }
          delete: {
            args: Prisma.DefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload>
          }
          update: {
            args: Prisma.DefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload>
          }
          deleteMany: {
            args: Prisma.DefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefinitionPayload>
          }
          aggregate: {
            args: Prisma.DefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefinition>
          }
          groupBy: {
            args: Prisma.DefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<DefinitionCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      SettingsAppendix: {
        payload: Prisma.$SettingsAppendixPayload<ExtArgs>
        fields: Prisma.SettingsAppendixFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsAppendixFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsAppendixFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload>
          }
          findFirst: {
            args: Prisma.SettingsAppendixFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsAppendixFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload>
          }
          findMany: {
            args: Prisma.SettingsAppendixFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload>[]
          }
          create: {
            args: Prisma.SettingsAppendixCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload>
          }
          createMany: {
            args: Prisma.SettingsAppendixCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsAppendixCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload>[]
          }
          delete: {
            args: Prisma.SettingsAppendixDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload>
          }
          update: {
            args: Prisma.SettingsAppendixUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload>
          }
          deleteMany: {
            args: Prisma.SettingsAppendixDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsAppendixUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingsAppendixUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsAppendixPayload>
          }
          aggregate: {
            args: Prisma.SettingsAppendixAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingsAppendix>
          }
          groupBy: {
            args: Prisma.SettingsAppendixGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsAppendixGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsAppendixCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsAppendixCountAggregateOutputType> | number
          }
        }
      }
      RandomImage: {
        payload: Prisma.$RandomImagePayload<ExtArgs>
        fields: Prisma.RandomImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RandomImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RandomImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload>
          }
          findFirst: {
            args: Prisma.RandomImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RandomImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload>
          }
          findMany: {
            args: Prisma.RandomImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload>[]
          }
          create: {
            args: Prisma.RandomImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload>
          }
          createMany: {
            args: Prisma.RandomImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RandomImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload>[]
          }
          delete: {
            args: Prisma.RandomImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload>
          }
          update: {
            args: Prisma.RandomImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload>
          }
          deleteMany: {
            args: Prisma.RandomImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RandomImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RandomImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RandomImagePayload>
          }
          aggregate: {
            args: Prisma.RandomImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRandomImage>
          }
          groupBy: {
            args: Prisma.RandomImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<RandomImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.RandomImageCountArgs<ExtArgs>
            result: $Utils.Optional<RandomImageCountAggregateOutputType> | number
          }
        }
      }
      NoteType: {
        payload: Prisma.$NoteTypePayload<ExtArgs>
        fields: Prisma.NoteTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload>
          }
          findFirst: {
            args: Prisma.NoteTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload>
          }
          findMany: {
            args: Prisma.NoteTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload>[]
          }
          create: {
            args: Prisma.NoteTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload>
          }
          createMany: {
            args: Prisma.NoteTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload>[]
          }
          delete: {
            args: Prisma.NoteTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload>
          }
          update: {
            args: Prisma.NoteTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload>
          }
          deleteMany: {
            args: Prisma.NoteTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTypePayload>
          }
          aggregate: {
            args: Prisma.NoteTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteType>
          }
          groupBy: {
            args: Prisma.NoteTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteTypeCountArgs<ExtArgs>
            result: $Utils.Optional<NoteTypeCountAggregateOutputType> | number
          }
        }
      }
      QAPair: {
        payload: Prisma.$QAPairPayload<ExtArgs>
        fields: Prisma.QAPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QAPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QAPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          findFirst: {
            args: Prisma.QAPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QAPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          findMany: {
            args: Prisma.QAPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>[]
          }
          create: {
            args: Prisma.QAPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          createMany: {
            args: Prisma.QAPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QAPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>[]
          }
          delete: {
            args: Prisma.QAPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          update: {
            args: Prisma.QAPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          deleteMany: {
            args: Prisma.QAPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QAPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QAPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          aggregate: {
            args: Prisma.QAPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQAPair>
          }
          groupBy: {
            args: Prisma.QAPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<QAPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.QAPairCountArgs<ExtArgs>
            result: $Utils.Optional<QAPairCountAggregateOutputType> | number
          }
        }
      }
      PracticeExam: {
        payload: Prisma.$PracticeExamPayload<ExtArgs>
        fields: Prisma.PracticeExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PracticeExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PracticeExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload>
          }
          findFirst: {
            args: Prisma.PracticeExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PracticeExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload>
          }
          findMany: {
            args: Prisma.PracticeExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload>[]
          }
          create: {
            args: Prisma.PracticeExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload>
          }
          createMany: {
            args: Prisma.PracticeExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PracticeExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload>[]
          }
          delete: {
            args: Prisma.PracticeExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload>
          }
          update: {
            args: Prisma.PracticeExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload>
          }
          deleteMany: {
            args: Prisma.PracticeExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PracticeExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PracticeExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeExamPayload>
          }
          aggregate: {
            args: Prisma.PracticeExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePracticeExam>
          }
          groupBy: {
            args: Prisma.PracticeExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<PracticeExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.PracticeExamCountArgs<ExtArgs>
            result: $Utils.Optional<PracticeExamCountAggregateOutputType> | number
          }
        }
      }
      SequentialNoteList: {
        payload: Prisma.$SequentialNoteListPayload<ExtArgs>
        fields: Prisma.SequentialNoteListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SequentialNoteListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SequentialNoteListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload>
          }
          findFirst: {
            args: Prisma.SequentialNoteListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SequentialNoteListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload>
          }
          findMany: {
            args: Prisma.SequentialNoteListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload>[]
          }
          create: {
            args: Prisma.SequentialNoteListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload>
          }
          createMany: {
            args: Prisma.SequentialNoteListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SequentialNoteListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload>[]
          }
          delete: {
            args: Prisma.SequentialNoteListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload>
          }
          update: {
            args: Prisma.SequentialNoteListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload>
          }
          deleteMany: {
            args: Prisma.SequentialNoteListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SequentialNoteListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SequentialNoteListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequentialNoteListPayload>
          }
          aggregate: {
            args: Prisma.SequentialNoteListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSequentialNoteList>
          }
          groupBy: {
            args: Prisma.SequentialNoteListGroupByArgs<ExtArgs>
            result: $Utils.Optional<SequentialNoteListGroupByOutputType>[]
          }
          count: {
            args: Prisma.SequentialNoteListCountArgs<ExtArgs>
            result: $Utils.Optional<SequentialNoteListCountAggregateOutputType> | number
          }
        }
      }
      MdxNote: {
        payload: Prisma.$MdxNotePayload<ExtArgs>
        fields: Prisma.MdxNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MdxNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MdxNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload>
          }
          findFirst: {
            args: Prisma.MdxNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MdxNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload>
          }
          findMany: {
            args: Prisma.MdxNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload>[]
          }
          create: {
            args: Prisma.MdxNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload>
          }
          createMany: {
            args: Prisma.MdxNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MdxNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload>[]
          }
          delete: {
            args: Prisma.MdxNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload>
          }
          update: {
            args: Prisma.MdxNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload>
          }
          deleteMany: {
            args: Prisma.MdxNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MdxNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MdxNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MdxNotePayload>
          }
          aggregate: {
            args: Prisma.MdxNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMdxNote>
          }
          groupBy: {
            args: Prisma.MdxNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<MdxNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.MdxNoteCountArgs<ExtArgs>
            result: $Utils.Optional<MdxNoteCountAggregateOutputType> | number
          }
        }
      }
      Ipynb: {
        payload: Prisma.$IpynbPayload<ExtArgs>
        fields: Prisma.IpynbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IpynbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IpynbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload>
          }
          findFirst: {
            args: Prisma.IpynbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IpynbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload>
          }
          findMany: {
            args: Prisma.IpynbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload>[]
          }
          create: {
            args: Prisma.IpynbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload>
          }
          createMany: {
            args: Prisma.IpynbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IpynbCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload>[]
          }
          delete: {
            args: Prisma.IpynbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload>
          }
          update: {
            args: Prisma.IpynbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload>
          }
          deleteMany: {
            args: Prisma.IpynbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IpynbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IpynbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpynbPayload>
          }
          aggregate: {
            args: Prisma.IpynbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIpynb>
          }
          groupBy: {
            args: Prisma.IpynbGroupByArgs<ExtArgs>
            result: $Utils.Optional<IpynbGroupByOutputType>[]
          }
          count: {
            args: Prisma.IpynbCountArgs<ExtArgs>
            result: $Utils.Optional<IpynbCountAggregateOutputType> | number
          }
        }
      }
      ToDoList: {
        payload: Prisma.$ToDoListPayload<ExtArgs>
        fields: Prisma.ToDoListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ToDoListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ToDoListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload>
          }
          findFirst: {
            args: Prisma.ToDoListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ToDoListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload>
          }
          findMany: {
            args: Prisma.ToDoListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload>[]
          }
          create: {
            args: Prisma.ToDoListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload>
          }
          createMany: {
            args: Prisma.ToDoListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ToDoListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload>[]
          }
          delete: {
            args: Prisma.ToDoListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload>
          }
          update: {
            args: Prisma.ToDoListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload>
          }
          deleteMany: {
            args: Prisma.ToDoListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ToDoListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ToDoListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoListPayload>
          }
          aggregate: {
            args: Prisma.ToDoListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToDoList>
          }
          groupBy: {
            args: Prisma.ToDoListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ToDoListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ToDoListCountArgs<ExtArgs>
            result: $Utils.Optional<ToDoListCountAggregateOutputType> | number
          }
        }
      }
      ToDo: {
        payload: Prisma.$ToDoPayload<ExtArgs>
        fields: Prisma.ToDoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ToDoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ToDoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload>
          }
          findFirst: {
            args: Prisma.ToDoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ToDoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload>
          }
          findMany: {
            args: Prisma.ToDoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload>[]
          }
          create: {
            args: Prisma.ToDoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload>
          }
          createMany: {
            args: Prisma.ToDoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ToDoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload>[]
          }
          delete: {
            args: Prisma.ToDoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload>
          }
          update: {
            args: Prisma.ToDoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload>
          }
          deleteMany: {
            args: Prisma.ToDoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ToDoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ToDoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToDoPayload>
          }
          aggregate: {
            args: Prisma.ToDoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToDo>
          }
          groupBy: {
            args: Prisma.ToDoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ToDoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ToDoCountArgs<ExtArgs>
            result: $Utils.Optional<ToDoCountAggregateOutputType> | number
          }
        }
      }
      KanBanCard: {
        payload: Prisma.$KanBanCardPayload<ExtArgs>
        fields: Prisma.KanBanCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KanBanCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KanBanCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload>
          }
          findFirst: {
            args: Prisma.KanBanCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KanBanCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload>
          }
          findMany: {
            args: Prisma.KanBanCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload>[]
          }
          create: {
            args: Prisma.KanBanCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload>
          }
          createMany: {
            args: Prisma.KanBanCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KanBanCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload>[]
          }
          delete: {
            args: Prisma.KanBanCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload>
          }
          update: {
            args: Prisma.KanBanCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload>
          }
          deleteMany: {
            args: Prisma.KanBanCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KanBanCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KanBanCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanCardPayload>
          }
          aggregate: {
            args: Prisma.KanBanCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKanBanCard>
          }
          groupBy: {
            args: Prisma.KanBanCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<KanBanCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.KanBanCardCountArgs<ExtArgs>
            result: $Utils.Optional<KanBanCardCountAggregateOutputType> | number
          }
        }
      }
      KanBanList: {
        payload: Prisma.$KanBanListPayload<ExtArgs>
        fields: Prisma.KanBanListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KanBanListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KanBanListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload>
          }
          findFirst: {
            args: Prisma.KanBanListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KanBanListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload>
          }
          findMany: {
            args: Prisma.KanBanListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload>[]
          }
          create: {
            args: Prisma.KanBanListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload>
          }
          createMany: {
            args: Prisma.KanBanListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KanBanListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload>[]
          }
          delete: {
            args: Prisma.KanBanListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload>
          }
          update: {
            args: Prisma.KanBanListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload>
          }
          deleteMany: {
            args: Prisma.KanBanListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KanBanListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KanBanListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanBanListPayload>
          }
          aggregate: {
            args: Prisma.KanBanListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKanBanList>
          }
          groupBy: {
            args: Prisma.KanBanListGroupByArgs<ExtArgs>
            result: $Utils.Optional<KanBanListGroupByOutputType>[]
          }
          count: {
            args: Prisma.KanBanListCountArgs<ExtArgs>
            result: $Utils.Optional<KanBanListCountAggregateOutputType> | number
          }
        }
      }
      Kanban: {
        payload: Prisma.$KanbanPayload<ExtArgs>
        fields: Prisma.KanbanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KanbanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KanbanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload>
          }
          findFirst: {
            args: Prisma.KanbanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KanbanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload>
          }
          findMany: {
            args: Prisma.KanbanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload>[]
          }
          create: {
            args: Prisma.KanbanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload>
          }
          createMany: {
            args: Prisma.KanbanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KanbanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload>[]
          }
          delete: {
            args: Prisma.KanbanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload>
          }
          update: {
            args: Prisma.KanbanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload>
          }
          deleteMany: {
            args: Prisma.KanbanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KanbanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KanbanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KanbanPayload>
          }
          aggregate: {
            args: Prisma.KanbanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKanban>
          }
          groupBy: {
            args: Prisma.KanbanGroupByArgs<ExtArgs>
            result: $Utils.Optional<KanbanGroupByOutputType>[]
          }
          count: {
            args: Prisma.KanbanCountArgs<ExtArgs>
            result: $Utils.Optional<KanbanCountAggregateOutputType> | number
          }
        }
      }
      TimePeriod: {
        payload: Prisma.$TimePeriodPayload<ExtArgs>
        fields: Prisma.TimePeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimePeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimePeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload>
          }
          findFirst: {
            args: Prisma.TimePeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimePeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload>
          }
          findMany: {
            args: Prisma.TimePeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload>[]
          }
          create: {
            args: Prisma.TimePeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload>
          }
          createMany: {
            args: Prisma.TimePeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimePeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload>[]
          }
          delete: {
            args: Prisma.TimePeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload>
          }
          update: {
            args: Prisma.TimePeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload>
          }
          deleteMany: {
            args: Prisma.TimePeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimePeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimePeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimePeriodPayload>
          }
          aggregate: {
            args: Prisma.TimePeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimePeriod>
          }
          groupBy: {
            args: Prisma.TimePeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimePeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimePeriodCountArgs<ExtArgs>
            result: $Utils.Optional<TimePeriodCountAggregateOutputType> | number
          }
        }
      }
      Diet: {
        payload: Prisma.$DietPayload<ExtArgs>
        fields: Prisma.DietFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DietFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DietFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload>
          }
          findFirst: {
            args: Prisma.DietFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DietFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload>
          }
          findMany: {
            args: Prisma.DietFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload>[]
          }
          create: {
            args: Prisma.DietCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload>
          }
          createMany: {
            args: Prisma.DietCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DietCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload>[]
          }
          delete: {
            args: Prisma.DietDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload>
          }
          update: {
            args: Prisma.DietUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload>
          }
          deleteMany: {
            args: Prisma.DietDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DietUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DietUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPayload>
          }
          aggregate: {
            args: Prisma.DietAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiet>
          }
          groupBy: {
            args: Prisma.DietGroupByArgs<ExtArgs>
            result: $Utils.Optional<DietGroupByOutputType>[]
          }
          count: {
            args: Prisma.DietCountArgs<ExtArgs>
            result: $Utils.Optional<DietCountAggregateOutputType> | number
          }
        }
      }
      Serving: {
        payload: Prisma.$ServingPayload<ExtArgs>
        fields: Prisma.ServingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload>
          }
          findFirst: {
            args: Prisma.ServingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload>
          }
          findMany: {
            args: Prisma.ServingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload>[]
          }
          create: {
            args: Prisma.ServingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload>
          }
          createMany: {
            args: Prisma.ServingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload>[]
          }
          delete: {
            args: Prisma.ServingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload>
          }
          update: {
            args: Prisma.ServingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload>
          }
          deleteMany: {
            args: Prisma.ServingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServingPayload>
          }
          aggregate: {
            args: Prisma.ServingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServing>
          }
          groupBy: {
            args: Prisma.ServingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServingCountArgs<ExtArgs>
            result: $Utils.Optional<ServingCountAggregateOutputType> | number
          }
        }
      }
      DietaryItem: {
        payload: Prisma.$DietaryItemPayload<ExtArgs>
        fields: Prisma.DietaryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DietaryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DietaryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload>
          }
          findFirst: {
            args: Prisma.DietaryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DietaryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload>
          }
          findMany: {
            args: Prisma.DietaryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload>[]
          }
          create: {
            args: Prisma.DietaryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload>
          }
          createMany: {
            args: Prisma.DietaryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DietaryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload>[]
          }
          delete: {
            args: Prisma.DietaryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload>
          }
          update: {
            args: Prisma.DietaryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload>
          }
          deleteMany: {
            args: Prisma.DietaryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DietaryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DietaryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryItemPayload>
          }
          aggregate: {
            args: Prisma.DietaryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDietaryItem>
          }
          groupBy: {
            args: Prisma.DietaryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DietaryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DietaryItemCountArgs<ExtArgs>
            result: $Utils.Optional<DietaryItemCountAggregateOutputType> | number
          }
        }
      }
      HealthReport: {
        payload: Prisma.$HealthReportPayload<ExtArgs>
        fields: Prisma.HealthReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          findFirst: {
            args: Prisma.HealthReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          findMany: {
            args: Prisma.HealthReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>[]
          }
          create: {
            args: Prisma.HealthReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          createMany: {
            args: Prisma.HealthReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>[]
          }
          delete: {
            args: Prisma.HealthReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          update: {
            args: Prisma.HealthReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          deleteMany: {
            args: Prisma.HealthReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          aggregate: {
            args: Prisma.HealthReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthReport>
          }
          groupBy: {
            args: Prisma.HealthReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthReportCountArgs<ExtArgs>
            result: $Utils.Optional<HealthReportCountAggregateOutputType> | number
          }
        }
      }
      Whiteboard: {
        payload: Prisma.$WhiteboardPayload<ExtArgs>
        fields: Prisma.WhiteboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhiteboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhiteboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          findFirst: {
            args: Prisma.WhiteboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhiteboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          findMany: {
            args: Prisma.WhiteboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>[]
          }
          create: {
            args: Prisma.WhiteboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          createMany: {
            args: Prisma.WhiteboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhiteboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>[]
          }
          delete: {
            args: Prisma.WhiteboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          update: {
            args: Prisma.WhiteboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          deleteMany: {
            args: Prisma.WhiteboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhiteboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhiteboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          aggregate: {
            args: Prisma.WhiteboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhiteboard>
          }
          groupBy: {
            args: Prisma.WhiteboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhiteboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhiteboardCountArgs<ExtArgs>
            result: $Utils.Optional<WhiteboardCountAggregateOutputType> | number
          }
        }
      }
      DJT: {
        payload: Prisma.$DJTPayload<ExtArgs>
        fields: Prisma.DJTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DJTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DJTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload>
          }
          findFirst: {
            args: Prisma.DJTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DJTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload>
          }
          findMany: {
            args: Prisma.DJTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload>[]
          }
          create: {
            args: Prisma.DJTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload>
          }
          createMany: {
            args: Prisma.DJTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DJTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload>[]
          }
          delete: {
            args: Prisma.DJTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload>
          }
          update: {
            args: Prisma.DJTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload>
          }
          deleteMany: {
            args: Prisma.DJTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DJTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DJTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DJTPayload>
          }
          aggregate: {
            args: Prisma.DJTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDJT>
          }
          groupBy: {
            args: Prisma.DJTGroupByArgs<ExtArgs>
            result: $Utils.Optional<DJTGroupByOutputType>[]
          }
          count: {
            args: Prisma.DJTCountArgs<ExtArgs>
            result: $Utils.Optional<DJTCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    MdxNotes: number
    IpynbNotes: number
    QaPair: number
    practiceExam: number
    todoList: number
    toDo: number
    bibEntries: number
    equations: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MdxNotes?: boolean | SubjectCountOutputTypeCountMdxNotesArgs
    IpynbNotes?: boolean | SubjectCountOutputTypeCountIpynbNotesArgs
    QaPair?: boolean | SubjectCountOutputTypeCountQaPairArgs
    practiceExam?: boolean | SubjectCountOutputTypeCountPracticeExamArgs
    todoList?: boolean | SubjectCountOutputTypeCountTodoListArgs
    toDo?: boolean | SubjectCountOutputTypeCountToDoArgs
    bibEntries?: boolean | SubjectCountOutputTypeCountBibEntriesArgs
    equations?: boolean | SubjectCountOutputTypeCountEquationsArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountMdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountIpynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpynbWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountQaPairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAPairWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountPracticeExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeExamWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTodoListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoListWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountToDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountBibEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountEquationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquationWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    MdxNotes: number
    ipynbNotes: number
    QAPair: number
    practiceExam: number
    toDo: number
    todoList: number
    bibEntries: number
    equations: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MdxNotes?: boolean | TopicCountOutputTypeCountMdxNotesArgs
    ipynbNotes?: boolean | TopicCountOutputTypeCountIpynbNotesArgs
    QAPair?: boolean | TopicCountOutputTypeCountQAPairArgs
    practiceExam?: boolean | TopicCountOutputTypeCountPracticeExamArgs
    toDo?: boolean | TopicCountOutputTypeCountToDoArgs
    todoList?: boolean | TopicCountOutputTypeCountTodoListArgs
    bibEntries?: boolean | TopicCountOutputTypeCountBibEntriesArgs
    equations?: boolean | TopicCountOutputTypeCountEquationsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountMdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountIpynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpynbWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountQAPairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAPairWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountPracticeExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeExamWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountToDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountTodoListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoListWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountBibEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountEquationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquationWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    MdxNotes: number
    bibEntries: number
    ipynbNotes: number
    QAPair: number
    practiceExam: number
    equations: number
    toDo: number
    todoList: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MdxNotes?: boolean | TagCountOutputTypeCountMdxNotesArgs
    bibEntries?: boolean | TagCountOutputTypeCountBibEntriesArgs
    ipynbNotes?: boolean | TagCountOutputTypeCountIpynbNotesArgs
    QAPair?: boolean | TagCountOutputTypeCountQAPairArgs
    practiceExam?: boolean | TagCountOutputTypeCountPracticeExamArgs
    equations?: boolean | TagCountOutputTypeCountEquationsArgs
    toDo?: boolean | TagCountOutputTypeCountToDoArgs
    todoList?: boolean | TagCountOutputTypeCountTodoListArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountMdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountBibEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountIpynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpynbWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountQAPairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAPairWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPracticeExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeExamWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountEquationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquationWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountToDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTodoListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoListWhereInput
  }


  /**
   * Count Type ReadingListCountOutputType
   */

  export type ReadingListCountOutputType = {
    bibEntries: number
    mdxNotes: number
    ipynbNotes: number
  }

  export type ReadingListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bibEntries?: boolean | ReadingListCountOutputTypeCountBibEntriesArgs
    mdxNotes?: boolean | ReadingListCountOutputTypeCountMdxNotesArgs
    ipynbNotes?: boolean | ReadingListCountOutputTypeCountIpynbNotesArgs
  }

  // Custom InputTypes
  /**
   * ReadingListCountOutputType without action
   */
  export type ReadingListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingListCountOutputType
     */
    select?: ReadingListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReadingListCountOutputType without action
   */
  export type ReadingListCountOutputTypeCountBibEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
  }

  /**
   * ReadingListCountOutputType without action
   */
  export type ReadingListCountOutputTypeCountMdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
  }

  /**
   * ReadingListCountOutputType without action
   */
  export type ReadingListCountOutputTypeCountIpynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpynbWhereInput
  }


  /**
   * Count Type BibEntryCountOutputType
   */

  export type BibEntryCountOutputType = {
    citationGroups: number
    tags: number
    topics: number
    subjects: number
    MdxNotes: number
    ipynbNotes: number
    readingList: number
  }

  export type BibEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citationGroups?: boolean | BibEntryCountOutputTypeCountCitationGroupsArgs
    tags?: boolean | BibEntryCountOutputTypeCountTagsArgs
    topics?: boolean | BibEntryCountOutputTypeCountTopicsArgs
    subjects?: boolean | BibEntryCountOutputTypeCountSubjectsArgs
    MdxNotes?: boolean | BibEntryCountOutputTypeCountMdxNotesArgs
    ipynbNotes?: boolean | BibEntryCountOutputTypeCountIpynbNotesArgs
    readingList?: boolean | BibEntryCountOutputTypeCountReadingListArgs
  }

  // Custom InputTypes
  /**
   * BibEntryCountOutputType without action
   */
  export type BibEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntryCountOutputType
     */
    select?: BibEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BibEntryCountOutputType without action
   */
  export type BibEntryCountOutputTypeCountCitationGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitationsGroupWhereInput
  }

  /**
   * BibEntryCountOutputType without action
   */
  export type BibEntryCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * BibEntryCountOutputType without action
   */
  export type BibEntryCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * BibEntryCountOutputType without action
   */
  export type BibEntryCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * BibEntryCountOutputType without action
   */
  export type BibEntryCountOutputTypeCountMdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
  }

  /**
   * BibEntryCountOutputType without action
   */
  export type BibEntryCountOutputTypeCountIpynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpynbWhereInput
  }

  /**
   * BibEntryCountOutputType without action
   */
  export type BibEntryCountOutputTypeCountReadingListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingListWhereInput
  }


  /**
   * Count Type CitationsGroupCountOutputType
   */

  export type CitationsGroupCountOutputType = {
    entries: number
  }

  export type CitationsGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | CitationsGroupCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * CitationsGroupCountOutputType without action
   */
  export type CitationsGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroupCountOutputType
     */
    select?: CitationsGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CitationsGroupCountOutputType without action
   */
  export type CitationsGroupCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
  }


  /**
   * Count Type BibCountOutputType
   */

  export type BibCountOutputType = {
    entries: number
  }

  export type BibCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | BibCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * BibCountOutputType without action
   */
  export type BibCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibCountOutputType
     */
    select?: BibCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BibCountOutputType without action
   */
  export type BibCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
  }


  /**
   * Count Type RelatedValuesCountOutputType
   */

  export type RelatedValuesCountOutputType = {
    equations: number
  }

  export type RelatedValuesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equations?: boolean | RelatedValuesCountOutputTypeCountEquationsArgs
  }

  // Custom InputTypes
  /**
   * RelatedValuesCountOutputType without action
   */
  export type RelatedValuesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValuesCountOutputType
     */
    select?: RelatedValuesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RelatedValuesCountOutputType without action
   */
  export type RelatedValuesCountOutputTypeCountEquationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquationWhereInput
  }


  /**
   * Count Type EquationCountOutputType
   */

  export type EquationCountOutputType = {
    relatedValues: number
    tags: number
    topics: number
    subjects: number
    mdxNotes: number
  }

  export type EquationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedValues?: boolean | EquationCountOutputTypeCountRelatedValuesArgs
    tags?: boolean | EquationCountOutputTypeCountTagsArgs
    topics?: boolean | EquationCountOutputTypeCountTopicsArgs
    subjects?: boolean | EquationCountOutputTypeCountSubjectsArgs
    mdxNotes?: boolean | EquationCountOutputTypeCountMdxNotesArgs
  }

  // Custom InputTypes
  /**
   * EquationCountOutputType without action
   */
  export type EquationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquationCountOutputType
     */
    select?: EquationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquationCountOutputType without action
   */
  export type EquationCountOutputTypeCountRelatedValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedValuesWhereInput
  }

  /**
   * EquationCountOutputType without action
   */
  export type EquationCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * EquationCountOutputType without action
   */
  export type EquationCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * EquationCountOutputType without action
   */
  export type EquationCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * EquationCountOutputType without action
   */
  export type EquationCountOutputTypeCountMdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
  }


  /**
   * Count Type QAPairCountOutputType
   */

  export type QAPairCountOutputType = {
    tags: number
    topics: number
    subjects: number
    practiceExam: number
  }

  export type QAPairCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | QAPairCountOutputTypeCountTagsArgs
    topics?: boolean | QAPairCountOutputTypeCountTopicsArgs
    subjects?: boolean | QAPairCountOutputTypeCountSubjectsArgs
    practiceExam?: boolean | QAPairCountOutputTypeCountPracticeExamArgs
  }

  // Custom InputTypes
  /**
   * QAPairCountOutputType without action
   */
  export type QAPairCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPairCountOutputType
     */
    select?: QAPairCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QAPairCountOutputType without action
   */
  export type QAPairCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * QAPairCountOutputType without action
   */
  export type QAPairCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * QAPairCountOutputType without action
   */
  export type QAPairCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * QAPairCountOutputType without action
   */
  export type QAPairCountOutputTypeCountPracticeExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeExamWhereInput
  }


  /**
   * Count Type PracticeExamCountOutputType
   */

  export type PracticeExamCountOutputType = {
    topics: number
    tags: number
    subjects: number
    questions: number
  }

  export type PracticeExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | PracticeExamCountOutputTypeCountTopicsArgs
    tags?: boolean | PracticeExamCountOutputTypeCountTagsArgs
    subjects?: boolean | PracticeExamCountOutputTypeCountSubjectsArgs
    questions?: boolean | PracticeExamCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * PracticeExamCountOutputType without action
   */
  export type PracticeExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExamCountOutputType
     */
    select?: PracticeExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PracticeExamCountOutputType without action
   */
  export type PracticeExamCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * PracticeExamCountOutputType without action
   */
  export type PracticeExamCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * PracticeExamCountOutputType without action
   */
  export type PracticeExamCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * PracticeExamCountOutputType without action
   */
  export type PracticeExamCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAPairWhereInput
  }


  /**
   * Count Type SequentialNoteListCountOutputType
   */

  export type SequentialNoteListCountOutputType = {
    MdxNote: number
    Ipynb: number
  }

  export type SequentialNoteListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MdxNote?: boolean | SequentialNoteListCountOutputTypeCountMdxNoteArgs
    Ipynb?: boolean | SequentialNoteListCountOutputTypeCountIpynbArgs
  }

  // Custom InputTypes
  /**
   * SequentialNoteListCountOutputType without action
   */
  export type SequentialNoteListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteListCountOutputType
     */
    select?: SequentialNoteListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SequentialNoteListCountOutputType without action
   */
  export type SequentialNoteListCountOutputTypeCountMdxNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
  }

  /**
   * SequentialNoteListCountOutputType without action
   */
  export type SequentialNoteListCountOutputTypeCountIpynbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpynbWhereInput
  }


  /**
   * Count Type MdxNoteCountOutputType
   */

  export type MdxNoteCountOutputType = {
    topics: number
    subjects: number
    tags: number
    citations: number
    ReadingList: number
    equations: number
    definitions: number
    toDo: number
  }

  export type MdxNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | MdxNoteCountOutputTypeCountTopicsArgs
    subjects?: boolean | MdxNoteCountOutputTypeCountSubjectsArgs
    tags?: boolean | MdxNoteCountOutputTypeCountTagsArgs
    citations?: boolean | MdxNoteCountOutputTypeCountCitationsArgs
    ReadingList?: boolean | MdxNoteCountOutputTypeCountReadingListArgs
    equations?: boolean | MdxNoteCountOutputTypeCountEquationsArgs
    definitions?: boolean | MdxNoteCountOutputTypeCountDefinitionsArgs
    toDo?: boolean | MdxNoteCountOutputTypeCountToDoArgs
  }

  // Custom InputTypes
  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNoteCountOutputType
     */
    select?: MdxNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeCountCitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
  }

  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeCountReadingListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingListWhereInput
  }

  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeCountEquationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquationWhereInput
  }

  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeCountDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefinitionWhereInput
  }

  /**
   * MdxNoteCountOutputType without action
   */
  export type MdxNoteCountOutputTypeCountToDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoWhereInput
  }


  /**
   * Count Type IpynbCountOutputType
   */

  export type IpynbCountOutputType = {
    tags: number
    topics: number
    subjects: number
    citations: number
    readingList: number
  }

  export type IpynbCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | IpynbCountOutputTypeCountTagsArgs
    topics?: boolean | IpynbCountOutputTypeCountTopicsArgs
    subjects?: boolean | IpynbCountOutputTypeCountSubjectsArgs
    citations?: boolean | IpynbCountOutputTypeCountCitationsArgs
    readingList?: boolean | IpynbCountOutputTypeCountReadingListArgs
  }

  // Custom InputTypes
  /**
   * IpynbCountOutputType without action
   */
  export type IpynbCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpynbCountOutputType
     */
    select?: IpynbCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IpynbCountOutputType without action
   */
  export type IpynbCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * IpynbCountOutputType without action
   */
  export type IpynbCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * IpynbCountOutputType without action
   */
  export type IpynbCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * IpynbCountOutputType without action
   */
  export type IpynbCountOutputTypeCountCitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
  }

  /**
   * IpynbCountOutputType without action
   */
  export type IpynbCountOutputTypeCountReadingListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingListWhereInput
  }


  /**
   * Count Type ToDoListCountOutputType
   */

  export type ToDoListCountOutputType = {
    tasks: number
    tags: number
    topics: number
    subjects: number
  }

  export type ToDoListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ToDoListCountOutputTypeCountTasksArgs
    tags?: boolean | ToDoListCountOutputTypeCountTagsArgs
    topics?: boolean | ToDoListCountOutputTypeCountTopicsArgs
    subjects?: boolean | ToDoListCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * ToDoListCountOutputType without action
   */
  export type ToDoListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoListCountOutputType
     */
    select?: ToDoListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ToDoListCountOutputType without action
   */
  export type ToDoListCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoWhereInput
  }

  /**
   * ToDoListCountOutputType without action
   */
  export type ToDoListCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * ToDoListCountOutputType without action
   */
  export type ToDoListCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * ToDoListCountOutputType without action
   */
  export type ToDoListCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }


  /**
   * Count Type ToDoCountOutputType
   */

  export type ToDoCountOutputType = {
    associatedNotes: number
    tags: number
    topics: number
    subjects: number
    child: number
  }

  export type ToDoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    associatedNotes?: boolean | ToDoCountOutputTypeCountAssociatedNotesArgs
    tags?: boolean | ToDoCountOutputTypeCountTagsArgs
    topics?: boolean | ToDoCountOutputTypeCountTopicsArgs
    subjects?: boolean | ToDoCountOutputTypeCountSubjectsArgs
    child?: boolean | ToDoCountOutputTypeCountChildArgs
  }

  // Custom InputTypes
  /**
   * ToDoCountOutputType without action
   */
  export type ToDoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoCountOutputType
     */
    select?: ToDoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ToDoCountOutputType without action
   */
  export type ToDoCountOutputTypeCountAssociatedNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
  }

  /**
   * ToDoCountOutputType without action
   */
  export type ToDoCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * ToDoCountOutputType without action
   */
  export type ToDoCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * ToDoCountOutputType without action
   */
  export type ToDoCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * ToDoCountOutputType without action
   */
  export type ToDoCountOutputTypeCountChildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoWhereInput
  }


  /**
   * Count Type KanBanListCountOutputType
   */

  export type KanBanListCountOutputType = {
    cards: number
  }

  export type KanBanListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cards?: boolean | KanBanListCountOutputTypeCountCardsArgs
  }

  // Custom InputTypes
  /**
   * KanBanListCountOutputType without action
   */
  export type KanBanListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanListCountOutputType
     */
    select?: KanBanListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KanBanListCountOutputType without action
   */
  export type KanBanListCountOutputTypeCountCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KanBanCardWhereInput
  }


  /**
   * Count Type KanbanCountOutputType
   */

  export type KanbanCountOutputType = {
    lists: number
    tags: number
    subjects: number
    topics: number
  }

  export type KanbanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lists?: boolean | KanbanCountOutputTypeCountListsArgs
    tags?: boolean | KanbanCountOutputTypeCountTagsArgs
    subjects?: boolean | KanbanCountOutputTypeCountSubjectsArgs
    topics?: boolean | KanbanCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * KanbanCountOutputType without action
   */
  export type KanbanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanbanCountOutputType
     */
    select?: KanbanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KanbanCountOutputType without action
   */
  export type KanbanCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KanBanListWhereInput
  }

  /**
   * KanbanCountOutputType without action
   */
  export type KanbanCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * KanbanCountOutputType without action
   */
  export type KanbanCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * KanbanCountOutputType without action
   */
  export type KanbanCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }


  /**
   * Count Type DietCountOutputType
   */

  export type DietCountOutputType = {
    items: number
    periodsFollowed: number
    HealthReport: number
  }

  export type DietCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | DietCountOutputTypeCountItemsArgs
    periodsFollowed?: boolean | DietCountOutputTypeCountPeriodsFollowedArgs
    HealthReport?: boolean | DietCountOutputTypeCountHealthReportArgs
  }

  // Custom InputTypes
  /**
   * DietCountOutputType without action
   */
  export type DietCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietCountOutputType
     */
    select?: DietCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DietCountOutputType without action
   */
  export type DietCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietaryItemWhereInput
  }

  /**
   * DietCountOutputType without action
   */
  export type DietCountOutputTypeCountPeriodsFollowedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimePeriodWhereInput
  }

  /**
   * DietCountOutputType without action
   */
  export type DietCountOutputTypeCountHealthReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthReportWhereInput
  }


  /**
   * Count Type DietaryItemCountOutputType
   */

  export type DietaryItemCountOutputType = {
    Diet: number
    Serving: number
  }

  export type DietaryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diet?: boolean | DietaryItemCountOutputTypeCountDietArgs
    Serving?: boolean | DietaryItemCountOutputTypeCountServingArgs
  }

  // Custom InputTypes
  /**
   * DietaryItemCountOutputType without action
   */
  export type DietaryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItemCountOutputType
     */
    select?: DietaryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DietaryItemCountOutputType without action
   */
  export type DietaryItemCountOutputTypeCountDietArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietWhereInput
  }

  /**
   * DietaryItemCountOutputType without action
   */
  export type DietaryItemCountOutputTypeCountServingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model FeatureRequest
   */

  export type AggregateFeatureRequest = {
    _count: FeatureRequestCountAggregateOutputType | null
    _avg: FeatureRequestAvgAggregateOutputType | null
    _sum: FeatureRequestSumAggregateOutputType | null
    _min: FeatureRequestMinAggregateOutputType | null
    _max: FeatureRequestMaxAggregateOutputType | null
  }

  export type FeatureRequestAvgAggregateOutputType = {
    id: number | null
  }

  export type FeatureRequestSumAggregateOutputType = {
    id: number | null
  }

  export type FeatureRequestMinAggregateOutputType = {
    id: number | null
    email: string | null
    message: string | null
    receivedOn: Date | null
  }

  export type FeatureRequestMaxAggregateOutputType = {
    id: number | null
    email: string | null
    message: string | null
    receivedOn: Date | null
  }

  export type FeatureRequestCountAggregateOutputType = {
    id: number
    email: number
    message: number
    category: number
    userBase: number
    receivedOn: number
    _all: number
  }


  export type FeatureRequestAvgAggregateInputType = {
    id?: true
  }

  export type FeatureRequestSumAggregateInputType = {
    id?: true
  }

  export type FeatureRequestMinAggregateInputType = {
    id?: true
    email?: true
    message?: true
    receivedOn?: true
  }

  export type FeatureRequestMaxAggregateInputType = {
    id?: true
    email?: true
    message?: true
    receivedOn?: true
  }

  export type FeatureRequestCountAggregateInputType = {
    id?: true
    email?: true
    message?: true
    category?: true
    userBase?: true
    receivedOn?: true
    _all?: true
  }

  export type FeatureRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureRequest to aggregate.
     */
    where?: FeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     */
    orderBy?: FeatureRequestOrderByWithRelationInput | FeatureRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureRequests
    **/
    _count?: true | FeatureRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureRequestMaxAggregateInputType
  }

  export type GetFeatureRequestAggregateType<T extends FeatureRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureRequest[P]>
      : GetScalarType<T[P], AggregateFeatureRequest[P]>
  }




  export type FeatureRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureRequestWhereInput
    orderBy?: FeatureRequestOrderByWithAggregationInput | FeatureRequestOrderByWithAggregationInput[]
    by: FeatureRequestScalarFieldEnum[] | FeatureRequestScalarFieldEnum
    having?: FeatureRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureRequestCountAggregateInputType | true
    _avg?: FeatureRequestAvgAggregateInputType
    _sum?: FeatureRequestSumAggregateInputType
    _min?: FeatureRequestMinAggregateInputType
    _max?: FeatureRequestMaxAggregateInputType
  }

  export type FeatureRequestGroupByOutputType = {
    id: number
    email: string
    message: string
    category: string[]
    userBase: string[]
    receivedOn: Date
    _count: FeatureRequestCountAggregateOutputType | null
    _avg: FeatureRequestAvgAggregateOutputType | null
    _sum: FeatureRequestSumAggregateOutputType | null
    _min: FeatureRequestMinAggregateOutputType | null
    _max: FeatureRequestMaxAggregateOutputType | null
  }

  type GetFeatureRequestGroupByPayload<T extends FeatureRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureRequestGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureRequestGroupByOutputType[P]>
        }
      >
    >


  export type FeatureRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    message?: boolean
    category?: boolean
    userBase?: boolean
    receivedOn?: boolean
  }, ExtArgs["result"]["featureRequest"]>

  export type FeatureRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    message?: boolean
    category?: boolean
    userBase?: boolean
    receivedOn?: boolean
  }, ExtArgs["result"]["featureRequest"]>

  export type FeatureRequestSelectScalar = {
    id?: boolean
    email?: boolean
    message?: boolean
    category?: boolean
    userBase?: boolean
    receivedOn?: boolean
  }


  export type $FeatureRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      message: string
      category: string[]
      userBase: string[]
      receivedOn: Date
    }, ExtArgs["result"]["featureRequest"]>
    composites: {}
  }

  type FeatureRequestGetPayload<S extends boolean | null | undefined | FeatureRequestDefaultArgs> = $Result.GetResult<Prisma.$FeatureRequestPayload, S>

  type FeatureRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeatureRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeatureRequestCountAggregateInputType | true
    }

  export interface FeatureRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureRequest'], meta: { name: 'FeatureRequest' } }
    /**
     * Find zero or one FeatureRequest that matches the filter.
     * @param {FeatureRequestFindUniqueArgs} args - Arguments to find a FeatureRequest
     * @example
     * // Get one FeatureRequest
     * const featureRequest = await prisma.featureRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureRequestFindUniqueArgs>(args: SelectSubset<T, FeatureRequestFindUniqueArgs<ExtArgs>>): Prisma__FeatureRequestClient<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeatureRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeatureRequestFindUniqueOrThrowArgs} args - Arguments to find a FeatureRequest
     * @example
     * // Get one FeatureRequest
     * const featureRequest = await prisma.featureRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureRequestClient<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeatureRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestFindFirstArgs} args - Arguments to find a FeatureRequest
     * @example
     * // Get one FeatureRequest
     * const featureRequest = await prisma.featureRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureRequestFindFirstArgs>(args?: SelectSubset<T, FeatureRequestFindFirstArgs<ExtArgs>>): Prisma__FeatureRequestClient<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeatureRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestFindFirstOrThrowArgs} args - Arguments to find a FeatureRequest
     * @example
     * // Get one FeatureRequest
     * const featureRequest = await prisma.featureRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureRequestClient<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeatureRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureRequests
     * const featureRequests = await prisma.featureRequest.findMany()
     * 
     * // Get first 10 FeatureRequests
     * const featureRequests = await prisma.featureRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureRequestWithIdOnly = await prisma.featureRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureRequestFindManyArgs>(args?: SelectSubset<T, FeatureRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeatureRequest.
     * @param {FeatureRequestCreateArgs} args - Arguments to create a FeatureRequest.
     * @example
     * // Create one FeatureRequest
     * const FeatureRequest = await prisma.featureRequest.create({
     *   data: {
     *     // ... data to create a FeatureRequest
     *   }
     * })
     * 
     */
    create<T extends FeatureRequestCreateArgs>(args: SelectSubset<T, FeatureRequestCreateArgs<ExtArgs>>): Prisma__FeatureRequestClient<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeatureRequests.
     * @param {FeatureRequestCreateManyArgs} args - Arguments to create many FeatureRequests.
     * @example
     * // Create many FeatureRequests
     * const featureRequest = await prisma.featureRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureRequestCreateManyArgs>(args?: SelectSubset<T, FeatureRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureRequests and returns the data saved in the database.
     * @param {FeatureRequestCreateManyAndReturnArgs} args - Arguments to create many FeatureRequests.
     * @example
     * // Create many FeatureRequests
     * const featureRequest = await prisma.featureRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureRequests and only return the `id`
     * const featureRequestWithIdOnly = await prisma.featureRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeatureRequest.
     * @param {FeatureRequestDeleteArgs} args - Arguments to delete one FeatureRequest.
     * @example
     * // Delete one FeatureRequest
     * const FeatureRequest = await prisma.featureRequest.delete({
     *   where: {
     *     // ... filter to delete one FeatureRequest
     *   }
     * })
     * 
     */
    delete<T extends FeatureRequestDeleteArgs>(args: SelectSubset<T, FeatureRequestDeleteArgs<ExtArgs>>): Prisma__FeatureRequestClient<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeatureRequest.
     * @param {FeatureRequestUpdateArgs} args - Arguments to update one FeatureRequest.
     * @example
     * // Update one FeatureRequest
     * const featureRequest = await prisma.featureRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureRequestUpdateArgs>(args: SelectSubset<T, FeatureRequestUpdateArgs<ExtArgs>>): Prisma__FeatureRequestClient<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeatureRequests.
     * @param {FeatureRequestDeleteManyArgs} args - Arguments to filter FeatureRequests to delete.
     * @example
     * // Delete a few FeatureRequests
     * const { count } = await prisma.featureRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureRequestDeleteManyArgs>(args?: SelectSubset<T, FeatureRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureRequests
     * const featureRequest = await prisma.featureRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureRequestUpdateManyArgs>(args: SelectSubset<T, FeatureRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeatureRequest.
     * @param {FeatureRequestUpsertArgs} args - Arguments to update or create a FeatureRequest.
     * @example
     * // Update or create a FeatureRequest
     * const featureRequest = await prisma.featureRequest.upsert({
     *   create: {
     *     // ... data to create a FeatureRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureRequest we want to update
     *   }
     * })
     */
    upsert<T extends FeatureRequestUpsertArgs>(args: SelectSubset<T, FeatureRequestUpsertArgs<ExtArgs>>): Prisma__FeatureRequestClient<$Result.GetResult<Prisma.$FeatureRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestCountArgs} args - Arguments to filter FeatureRequests to count.
     * @example
     * // Count the number of FeatureRequests
     * const count = await prisma.featureRequest.count({
     *   where: {
     *     // ... the filter for the FeatureRequests we want to count
     *   }
     * })
    **/
    count<T extends FeatureRequestCountArgs>(
      args?: Subset<T, FeatureRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureRequestAggregateArgs>(args: Subset<T, FeatureRequestAggregateArgs>): Prisma.PrismaPromise<GetFeatureRequestAggregateType<T>>

    /**
     * Group by FeatureRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureRequestGroupByArgs['orderBy'] }
        : { orderBy?: FeatureRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureRequest model
   */
  readonly fields: FeatureRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureRequest model
   */ 
  interface FeatureRequestFieldRefs {
    readonly id: FieldRef<"FeatureRequest", 'Int'>
    readonly email: FieldRef<"FeatureRequest", 'String'>
    readonly message: FieldRef<"FeatureRequest", 'String'>
    readonly category: FieldRef<"FeatureRequest", 'String[]'>
    readonly userBase: FieldRef<"FeatureRequest", 'String[]'>
    readonly receivedOn: FieldRef<"FeatureRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureRequest findUnique
   */
  export type FeatureRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequest to fetch.
     */
    where: FeatureRequestWhereUniqueInput
  }

  /**
   * FeatureRequest findUniqueOrThrow
   */
  export type FeatureRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequest to fetch.
     */
    where: FeatureRequestWhereUniqueInput
  }

  /**
   * FeatureRequest findFirst
   */
  export type FeatureRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequest to fetch.
     */
    where?: FeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     */
    orderBy?: FeatureRequestOrderByWithRelationInput | FeatureRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureRequests.
     */
    cursor?: FeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureRequests.
     */
    distinct?: FeatureRequestScalarFieldEnum | FeatureRequestScalarFieldEnum[]
  }

  /**
   * FeatureRequest findFirstOrThrow
   */
  export type FeatureRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequest to fetch.
     */
    where?: FeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     */
    orderBy?: FeatureRequestOrderByWithRelationInput | FeatureRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureRequests.
     */
    cursor?: FeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureRequests.
     */
    distinct?: FeatureRequestScalarFieldEnum | FeatureRequestScalarFieldEnum[]
  }

  /**
   * FeatureRequest findMany
   */
  export type FeatureRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequests to fetch.
     */
    where?: FeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     */
    orderBy?: FeatureRequestOrderByWithRelationInput | FeatureRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureRequests.
     */
    cursor?: FeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     */
    skip?: number
    distinct?: FeatureRequestScalarFieldEnum | FeatureRequestScalarFieldEnum[]
  }

  /**
   * FeatureRequest create
   */
  export type FeatureRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a FeatureRequest.
     */
    data: XOR<FeatureRequestCreateInput, FeatureRequestUncheckedCreateInput>
  }

  /**
   * FeatureRequest createMany
   */
  export type FeatureRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureRequests.
     */
    data: FeatureRequestCreateManyInput | FeatureRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureRequest createManyAndReturn
   */
  export type FeatureRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeatureRequests.
     */
    data: FeatureRequestCreateManyInput | FeatureRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureRequest update
   */
  export type FeatureRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a FeatureRequest.
     */
    data: XOR<FeatureRequestUpdateInput, FeatureRequestUncheckedUpdateInput>
    /**
     * Choose, which FeatureRequest to update.
     */
    where: FeatureRequestWhereUniqueInput
  }

  /**
   * FeatureRequest updateMany
   */
  export type FeatureRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureRequests.
     */
    data: XOR<FeatureRequestUpdateManyMutationInput, FeatureRequestUncheckedUpdateManyInput>
    /**
     * Filter which FeatureRequests to update
     */
    where?: FeatureRequestWhereInput
  }

  /**
   * FeatureRequest upsert
   */
  export type FeatureRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the FeatureRequest to update in case it exists.
     */
    where: FeatureRequestWhereUniqueInput
    /**
     * In case the FeatureRequest found by the `where` argument doesn't exist, create a new FeatureRequest with this data.
     */
    create: XOR<FeatureRequestCreateInput, FeatureRequestUncheckedCreateInput>
    /**
     * In case the FeatureRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureRequestUpdateInput, FeatureRequestUncheckedUpdateInput>
  }

  /**
   * FeatureRequest delete
   */
  export type FeatureRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
    /**
     * Filter which FeatureRequest to delete.
     */
    where: FeatureRequestWhereUniqueInput
  }

  /**
   * FeatureRequest deleteMany
   */
  export type FeatureRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureRequests to delete
     */
    where?: FeatureRequestWhereInput
  }

  /**
   * FeatureRequest without action
   */
  export type FeatureRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     */
    select?: FeatureRequestSelect<ExtArgs> | null
  }


  /**
   * Model WaitlistRequest
   */

  export type AggregateWaitlistRequest = {
    _count: WaitlistRequestCountAggregateOutputType | null
    _avg: WaitlistRequestAvgAggregateOutputType | null
    _sum: WaitlistRequestSumAggregateOutputType | null
    _min: WaitlistRequestMinAggregateOutputType | null
    _max: WaitlistRequestMaxAggregateOutputType | null
  }

  export type WaitlistRequestAvgAggregateOutputType = {
    id: number | null
    emailsSent: number | null
  }

  export type WaitlistRequestSumAggregateOutputType = {
    id: number | null
    emailsSent: number | null
  }

  export type WaitlistRequestMinAggregateOutputType = {
    id: number | null
    email: string | null
    receivedOn: Date | null
    emailsSent: number | null
  }

  export type WaitlistRequestMaxAggregateOutputType = {
    id: number | null
    email: string | null
    receivedOn: Date | null
    emailsSent: number | null
  }

  export type WaitlistRequestCountAggregateOutputType = {
    id: number
    email: number
    receivedOn: number
    emailsSent: number
    _all: number
  }


  export type WaitlistRequestAvgAggregateInputType = {
    id?: true
    emailsSent?: true
  }

  export type WaitlistRequestSumAggregateInputType = {
    id?: true
    emailsSent?: true
  }

  export type WaitlistRequestMinAggregateInputType = {
    id?: true
    email?: true
    receivedOn?: true
    emailsSent?: true
  }

  export type WaitlistRequestMaxAggregateInputType = {
    id?: true
    email?: true
    receivedOn?: true
    emailsSent?: true
  }

  export type WaitlistRequestCountAggregateInputType = {
    id?: true
    email?: true
    receivedOn?: true
    emailsSent?: true
    _all?: true
  }

  export type WaitlistRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WaitlistRequest to aggregate.
     */
    where?: WaitlistRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitlistRequests to fetch.
     */
    orderBy?: WaitlistRequestOrderByWithRelationInput | WaitlistRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaitlistRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitlistRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitlistRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WaitlistRequests
    **/
    _count?: true | WaitlistRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WaitlistRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WaitlistRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaitlistRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaitlistRequestMaxAggregateInputType
  }

  export type GetWaitlistRequestAggregateType<T extends WaitlistRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateWaitlistRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWaitlistRequest[P]>
      : GetScalarType<T[P], AggregateWaitlistRequest[P]>
  }




  export type WaitlistRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitlistRequestWhereInput
    orderBy?: WaitlistRequestOrderByWithAggregationInput | WaitlistRequestOrderByWithAggregationInput[]
    by: WaitlistRequestScalarFieldEnum[] | WaitlistRequestScalarFieldEnum
    having?: WaitlistRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaitlistRequestCountAggregateInputType | true
    _avg?: WaitlistRequestAvgAggregateInputType
    _sum?: WaitlistRequestSumAggregateInputType
    _min?: WaitlistRequestMinAggregateInputType
    _max?: WaitlistRequestMaxAggregateInputType
  }

  export type WaitlistRequestGroupByOutputType = {
    id: number
    email: string
    receivedOn: Date
    emailsSent: number
    _count: WaitlistRequestCountAggregateOutputType | null
    _avg: WaitlistRequestAvgAggregateOutputType | null
    _sum: WaitlistRequestSumAggregateOutputType | null
    _min: WaitlistRequestMinAggregateOutputType | null
    _max: WaitlistRequestMaxAggregateOutputType | null
  }

  type GetWaitlistRequestGroupByPayload<T extends WaitlistRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WaitlistRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaitlistRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaitlistRequestGroupByOutputType[P]>
            : GetScalarType<T[P], WaitlistRequestGroupByOutputType[P]>
        }
      >
    >


  export type WaitlistRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    receivedOn?: boolean
    emailsSent?: boolean
  }, ExtArgs["result"]["waitlistRequest"]>

  export type WaitlistRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    receivedOn?: boolean
    emailsSent?: boolean
  }, ExtArgs["result"]["waitlistRequest"]>

  export type WaitlistRequestSelectScalar = {
    id?: boolean
    email?: boolean
    receivedOn?: boolean
    emailsSent?: boolean
  }


  export type $WaitlistRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WaitlistRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      receivedOn: Date
      emailsSent: number
    }, ExtArgs["result"]["waitlistRequest"]>
    composites: {}
  }

  type WaitlistRequestGetPayload<S extends boolean | null | undefined | WaitlistRequestDefaultArgs> = $Result.GetResult<Prisma.$WaitlistRequestPayload, S>

  type WaitlistRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WaitlistRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WaitlistRequestCountAggregateInputType | true
    }

  export interface WaitlistRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WaitlistRequest'], meta: { name: 'WaitlistRequest' } }
    /**
     * Find zero or one WaitlistRequest that matches the filter.
     * @param {WaitlistRequestFindUniqueArgs} args - Arguments to find a WaitlistRequest
     * @example
     * // Get one WaitlistRequest
     * const waitlistRequest = await prisma.waitlistRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WaitlistRequestFindUniqueArgs>(args: SelectSubset<T, WaitlistRequestFindUniqueArgs<ExtArgs>>): Prisma__WaitlistRequestClient<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WaitlistRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WaitlistRequestFindUniqueOrThrowArgs} args - Arguments to find a WaitlistRequest
     * @example
     * // Get one WaitlistRequest
     * const waitlistRequest = await prisma.waitlistRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WaitlistRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, WaitlistRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WaitlistRequestClient<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WaitlistRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistRequestFindFirstArgs} args - Arguments to find a WaitlistRequest
     * @example
     * // Get one WaitlistRequest
     * const waitlistRequest = await prisma.waitlistRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WaitlistRequestFindFirstArgs>(args?: SelectSubset<T, WaitlistRequestFindFirstArgs<ExtArgs>>): Prisma__WaitlistRequestClient<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WaitlistRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistRequestFindFirstOrThrowArgs} args - Arguments to find a WaitlistRequest
     * @example
     * // Get one WaitlistRequest
     * const waitlistRequest = await prisma.waitlistRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WaitlistRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, WaitlistRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__WaitlistRequestClient<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WaitlistRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WaitlistRequests
     * const waitlistRequests = await prisma.waitlistRequest.findMany()
     * 
     * // Get first 10 WaitlistRequests
     * const waitlistRequests = await prisma.waitlistRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waitlistRequestWithIdOnly = await prisma.waitlistRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WaitlistRequestFindManyArgs>(args?: SelectSubset<T, WaitlistRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WaitlistRequest.
     * @param {WaitlistRequestCreateArgs} args - Arguments to create a WaitlistRequest.
     * @example
     * // Create one WaitlistRequest
     * const WaitlistRequest = await prisma.waitlistRequest.create({
     *   data: {
     *     // ... data to create a WaitlistRequest
     *   }
     * })
     * 
     */
    create<T extends WaitlistRequestCreateArgs>(args: SelectSubset<T, WaitlistRequestCreateArgs<ExtArgs>>): Prisma__WaitlistRequestClient<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WaitlistRequests.
     * @param {WaitlistRequestCreateManyArgs} args - Arguments to create many WaitlistRequests.
     * @example
     * // Create many WaitlistRequests
     * const waitlistRequest = await prisma.waitlistRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WaitlistRequestCreateManyArgs>(args?: SelectSubset<T, WaitlistRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WaitlistRequests and returns the data saved in the database.
     * @param {WaitlistRequestCreateManyAndReturnArgs} args - Arguments to create many WaitlistRequests.
     * @example
     * // Create many WaitlistRequests
     * const waitlistRequest = await prisma.waitlistRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WaitlistRequests and only return the `id`
     * const waitlistRequestWithIdOnly = await prisma.waitlistRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WaitlistRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, WaitlistRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WaitlistRequest.
     * @param {WaitlistRequestDeleteArgs} args - Arguments to delete one WaitlistRequest.
     * @example
     * // Delete one WaitlistRequest
     * const WaitlistRequest = await prisma.waitlistRequest.delete({
     *   where: {
     *     // ... filter to delete one WaitlistRequest
     *   }
     * })
     * 
     */
    delete<T extends WaitlistRequestDeleteArgs>(args: SelectSubset<T, WaitlistRequestDeleteArgs<ExtArgs>>): Prisma__WaitlistRequestClient<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WaitlistRequest.
     * @param {WaitlistRequestUpdateArgs} args - Arguments to update one WaitlistRequest.
     * @example
     * // Update one WaitlistRequest
     * const waitlistRequest = await prisma.waitlistRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WaitlistRequestUpdateArgs>(args: SelectSubset<T, WaitlistRequestUpdateArgs<ExtArgs>>): Prisma__WaitlistRequestClient<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WaitlistRequests.
     * @param {WaitlistRequestDeleteManyArgs} args - Arguments to filter WaitlistRequests to delete.
     * @example
     * // Delete a few WaitlistRequests
     * const { count } = await prisma.waitlistRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WaitlistRequestDeleteManyArgs>(args?: SelectSubset<T, WaitlistRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WaitlistRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WaitlistRequests
     * const waitlistRequest = await prisma.waitlistRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WaitlistRequestUpdateManyArgs>(args: SelectSubset<T, WaitlistRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WaitlistRequest.
     * @param {WaitlistRequestUpsertArgs} args - Arguments to update or create a WaitlistRequest.
     * @example
     * // Update or create a WaitlistRequest
     * const waitlistRequest = await prisma.waitlistRequest.upsert({
     *   create: {
     *     // ... data to create a WaitlistRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WaitlistRequest we want to update
     *   }
     * })
     */
    upsert<T extends WaitlistRequestUpsertArgs>(args: SelectSubset<T, WaitlistRequestUpsertArgs<ExtArgs>>): Prisma__WaitlistRequestClient<$Result.GetResult<Prisma.$WaitlistRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WaitlistRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistRequestCountArgs} args - Arguments to filter WaitlistRequests to count.
     * @example
     * // Count the number of WaitlistRequests
     * const count = await prisma.waitlistRequest.count({
     *   where: {
     *     // ... the filter for the WaitlistRequests we want to count
     *   }
     * })
    **/
    count<T extends WaitlistRequestCountArgs>(
      args?: Subset<T, WaitlistRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaitlistRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WaitlistRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaitlistRequestAggregateArgs>(args: Subset<T, WaitlistRequestAggregateArgs>): Prisma.PrismaPromise<GetWaitlistRequestAggregateType<T>>

    /**
     * Group by WaitlistRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitlistRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaitlistRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaitlistRequestGroupByArgs['orderBy'] }
        : { orderBy?: WaitlistRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaitlistRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaitlistRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WaitlistRequest model
   */
  readonly fields: WaitlistRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WaitlistRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WaitlistRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WaitlistRequest model
   */ 
  interface WaitlistRequestFieldRefs {
    readonly id: FieldRef<"WaitlistRequest", 'Int'>
    readonly email: FieldRef<"WaitlistRequest", 'String'>
    readonly receivedOn: FieldRef<"WaitlistRequest", 'DateTime'>
    readonly emailsSent: FieldRef<"WaitlistRequest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WaitlistRequest findUnique
   */
  export type WaitlistRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * Filter, which WaitlistRequest to fetch.
     */
    where: WaitlistRequestWhereUniqueInput
  }

  /**
   * WaitlistRequest findUniqueOrThrow
   */
  export type WaitlistRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * Filter, which WaitlistRequest to fetch.
     */
    where: WaitlistRequestWhereUniqueInput
  }

  /**
   * WaitlistRequest findFirst
   */
  export type WaitlistRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * Filter, which WaitlistRequest to fetch.
     */
    where?: WaitlistRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitlistRequests to fetch.
     */
    orderBy?: WaitlistRequestOrderByWithRelationInput | WaitlistRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaitlistRequests.
     */
    cursor?: WaitlistRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitlistRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitlistRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaitlistRequests.
     */
    distinct?: WaitlistRequestScalarFieldEnum | WaitlistRequestScalarFieldEnum[]
  }

  /**
   * WaitlistRequest findFirstOrThrow
   */
  export type WaitlistRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * Filter, which WaitlistRequest to fetch.
     */
    where?: WaitlistRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitlistRequests to fetch.
     */
    orderBy?: WaitlistRequestOrderByWithRelationInput | WaitlistRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaitlistRequests.
     */
    cursor?: WaitlistRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitlistRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitlistRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaitlistRequests.
     */
    distinct?: WaitlistRequestScalarFieldEnum | WaitlistRequestScalarFieldEnum[]
  }

  /**
   * WaitlistRequest findMany
   */
  export type WaitlistRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * Filter, which WaitlistRequests to fetch.
     */
    where?: WaitlistRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitlistRequests to fetch.
     */
    orderBy?: WaitlistRequestOrderByWithRelationInput | WaitlistRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WaitlistRequests.
     */
    cursor?: WaitlistRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitlistRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitlistRequests.
     */
    skip?: number
    distinct?: WaitlistRequestScalarFieldEnum | WaitlistRequestScalarFieldEnum[]
  }

  /**
   * WaitlistRequest create
   */
  export type WaitlistRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a WaitlistRequest.
     */
    data: XOR<WaitlistRequestCreateInput, WaitlistRequestUncheckedCreateInput>
  }

  /**
   * WaitlistRequest createMany
   */
  export type WaitlistRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WaitlistRequests.
     */
    data: WaitlistRequestCreateManyInput | WaitlistRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WaitlistRequest createManyAndReturn
   */
  export type WaitlistRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WaitlistRequests.
     */
    data: WaitlistRequestCreateManyInput | WaitlistRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WaitlistRequest update
   */
  export type WaitlistRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a WaitlistRequest.
     */
    data: XOR<WaitlistRequestUpdateInput, WaitlistRequestUncheckedUpdateInput>
    /**
     * Choose, which WaitlistRequest to update.
     */
    where: WaitlistRequestWhereUniqueInput
  }

  /**
   * WaitlistRequest updateMany
   */
  export type WaitlistRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WaitlistRequests.
     */
    data: XOR<WaitlistRequestUpdateManyMutationInput, WaitlistRequestUncheckedUpdateManyInput>
    /**
     * Filter which WaitlistRequests to update
     */
    where?: WaitlistRequestWhereInput
  }

  /**
   * WaitlistRequest upsert
   */
  export type WaitlistRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the WaitlistRequest to update in case it exists.
     */
    where: WaitlistRequestWhereUniqueInput
    /**
     * In case the WaitlistRequest found by the `where` argument doesn't exist, create a new WaitlistRequest with this data.
     */
    create: XOR<WaitlistRequestCreateInput, WaitlistRequestUncheckedCreateInput>
    /**
     * In case the WaitlistRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaitlistRequestUpdateInput, WaitlistRequestUncheckedUpdateInput>
  }

  /**
   * WaitlistRequest delete
   */
  export type WaitlistRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
    /**
     * Filter which WaitlistRequest to delete.
     */
    where: WaitlistRequestWhereUniqueInput
  }

  /**
   * WaitlistRequest deleteMany
   */
  export type WaitlistRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WaitlistRequests to delete
     */
    where?: WaitlistRequestWhereInput
  }

  /**
   * WaitlistRequest without action
   */
  export type WaitlistRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitlistRequest
     */
    select?: WaitlistRequestSelect<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    kanbanId: number | null
  }

  export type SubjectSumAggregateOutputType = {
    kanbanId: number | null
  }

  export type SubjectMinAggregateOutputType = {
    value: string | null
    kanbanId: number | null
  }

  export type SubjectMaxAggregateOutputType = {
    value: string | null
    kanbanId: number | null
  }

  export type SubjectCountAggregateOutputType = {
    value: number
    kanbanId: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    kanbanId?: true
  }

  export type SubjectSumAggregateInputType = {
    kanbanId?: true
  }

  export type SubjectMinAggregateInputType = {
    value?: true
    kanbanId?: true
  }

  export type SubjectMaxAggregateInputType = {
    value?: true
    kanbanId?: true
  }

  export type SubjectCountAggregateInputType = {
    value?: true
    kanbanId?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    value: string
    kanbanId: number | null
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    kanbanId?: boolean
    MdxNotes?: boolean | Subject$MdxNotesArgs<ExtArgs>
    IpynbNotes?: boolean | Subject$IpynbNotesArgs<ExtArgs>
    QaPair?: boolean | Subject$QaPairArgs<ExtArgs>
    practiceExam?: boolean | Subject$practiceExamArgs<ExtArgs>
    Kanban?: boolean | Subject$KanbanArgs<ExtArgs>
    todoList?: boolean | Subject$todoListArgs<ExtArgs>
    toDo?: boolean | Subject$toDoArgs<ExtArgs>
    bibEntries?: boolean | Subject$bibEntriesArgs<ExtArgs>
    equations?: boolean | Subject$equationsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    kanbanId?: boolean
    Kanban?: boolean | Subject$KanbanArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    value?: boolean
    kanbanId?: boolean
  }

  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MdxNotes?: boolean | Subject$MdxNotesArgs<ExtArgs>
    IpynbNotes?: boolean | Subject$IpynbNotesArgs<ExtArgs>
    QaPair?: boolean | Subject$QaPairArgs<ExtArgs>
    practiceExam?: boolean | Subject$practiceExamArgs<ExtArgs>
    Kanban?: boolean | Subject$KanbanArgs<ExtArgs>
    todoList?: boolean | Subject$todoListArgs<ExtArgs>
    toDo?: boolean | Subject$toDoArgs<ExtArgs>
    bibEntries?: boolean | Subject$bibEntriesArgs<ExtArgs>
    equations?: boolean | Subject$equationsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Kanban?: boolean | Subject$KanbanArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      MdxNotes: Prisma.$MdxNotePayload<ExtArgs>[]
      IpynbNotes: Prisma.$IpynbPayload<ExtArgs>[]
      QaPair: Prisma.$QAPairPayload<ExtArgs>[]
      practiceExam: Prisma.$PracticeExamPayload<ExtArgs>[]
      Kanban: Prisma.$KanbanPayload<ExtArgs> | null
      todoList: Prisma.$ToDoListPayload<ExtArgs>[]
      toDo: Prisma.$ToDoPayload<ExtArgs>[]
      bibEntries: Prisma.$BibEntryPayload<ExtArgs>[]
      equations: Prisma.$EquationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      value: string
      kanbanId: number | null
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `value`
     * const subjectWithValueOnly = await prisma.subject.findMany({ select: { value: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `value`
     * const subjectWithValueOnly = await prisma.subject.createManyAndReturn({ 
     *   select: { value: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MdxNotes<T extends Subject$MdxNotesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$MdxNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany"> | Null>
    IpynbNotes<T extends Subject$IpynbNotesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$IpynbNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findMany"> | Null>
    QaPair<T extends Subject$QaPairArgs<ExtArgs> = {}>(args?: Subset<T, Subject$QaPairArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findMany"> | Null>
    practiceExam<T extends Subject$practiceExamArgs<ExtArgs> = {}>(args?: Subset<T, Subject$practiceExamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findMany"> | Null>
    Kanban<T extends Subject$KanbanArgs<ExtArgs> = {}>(args?: Subset<T, Subject$KanbanArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    todoList<T extends Subject$todoListArgs<ExtArgs> = {}>(args?: Subset<T, Subject$todoListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findMany"> | Null>
    toDo<T extends Subject$toDoArgs<ExtArgs> = {}>(args?: Subset<T, Subject$toDoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findMany"> | Null>
    bibEntries<T extends Subject$bibEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$bibEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany"> | Null>
    equations<T extends Subject$equationsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$equationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */ 
  interface SubjectFieldRefs {
    readonly value: FieldRef<"Subject", 'String'>
    readonly kanbanId: FieldRef<"Subject", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
  }

  /**
   * Subject.MdxNotes
   */
  export type Subject$MdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    cursor?: MdxNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * Subject.IpynbNotes
   */
  export type Subject$IpynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    where?: IpynbWhereInput
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    cursor?: IpynbWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * Subject.QaPair
   */
  export type Subject$QaPairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    where?: QAPairWhereInput
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    cursor?: QAPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * Subject.practiceExam
   */
  export type Subject$practiceExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    where?: PracticeExamWhereInput
    orderBy?: PracticeExamOrderByWithRelationInput | PracticeExamOrderByWithRelationInput[]
    cursor?: PracticeExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PracticeExamScalarFieldEnum | PracticeExamScalarFieldEnum[]
  }

  /**
   * Subject.Kanban
   */
  export type Subject$KanbanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    where?: KanbanWhereInput
  }

  /**
   * Subject.todoList
   */
  export type Subject$todoListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    where?: ToDoListWhereInput
    orderBy?: ToDoListOrderByWithRelationInput | ToDoListOrderByWithRelationInput[]
    cursor?: ToDoListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoListScalarFieldEnum | ToDoListScalarFieldEnum[]
  }

  /**
   * Subject.toDo
   */
  export type Subject$toDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    where?: ToDoWhereInput
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    cursor?: ToDoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * Subject.bibEntries
   */
  export type Subject$bibEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    cursor?: BibEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * Subject.equations
   */
  export type Subject$equationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    where?: EquationWhereInput
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    cursor?: EquationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquationScalarFieldEnum | EquationScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    kanbanId: number | null
  }

  export type TopicSumAggregateOutputType = {
    kanbanId: number | null
  }

  export type TopicMinAggregateOutputType = {
    value: string | null
    kanbanId: number | null
  }

  export type TopicMaxAggregateOutputType = {
    value: string | null
    kanbanId: number | null
  }

  export type TopicCountAggregateOutputType = {
    value: number
    kanbanId: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    kanbanId?: true
  }

  export type TopicSumAggregateInputType = {
    kanbanId?: true
  }

  export type TopicMinAggregateInputType = {
    value?: true
    kanbanId?: true
  }

  export type TopicMaxAggregateInputType = {
    value?: true
    kanbanId?: true
  }

  export type TopicCountAggregateInputType = {
    value?: true
    kanbanId?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    value: string
    kanbanId: number | null
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    kanbanId?: boolean
    MdxNotes?: boolean | Topic$MdxNotesArgs<ExtArgs>
    ipynbNotes?: boolean | Topic$ipynbNotesArgs<ExtArgs>
    QAPair?: boolean | Topic$QAPairArgs<ExtArgs>
    practiceExam?: boolean | Topic$practiceExamArgs<ExtArgs>
    toDo?: boolean | Topic$toDoArgs<ExtArgs>
    Kanban?: boolean | Topic$KanbanArgs<ExtArgs>
    todoList?: boolean | Topic$todoListArgs<ExtArgs>
    bibEntries?: boolean | Topic$bibEntriesArgs<ExtArgs>
    equations?: boolean | Topic$equationsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    kanbanId?: boolean
    Kanban?: boolean | Topic$KanbanArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    value?: boolean
    kanbanId?: boolean
  }

  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MdxNotes?: boolean | Topic$MdxNotesArgs<ExtArgs>
    ipynbNotes?: boolean | Topic$ipynbNotesArgs<ExtArgs>
    QAPair?: boolean | Topic$QAPairArgs<ExtArgs>
    practiceExam?: boolean | Topic$practiceExamArgs<ExtArgs>
    toDo?: boolean | Topic$toDoArgs<ExtArgs>
    Kanban?: boolean | Topic$KanbanArgs<ExtArgs>
    todoList?: boolean | Topic$todoListArgs<ExtArgs>
    bibEntries?: boolean | Topic$bibEntriesArgs<ExtArgs>
    equations?: boolean | Topic$equationsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Kanban?: boolean | Topic$KanbanArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      MdxNotes: Prisma.$MdxNotePayload<ExtArgs>[]
      ipynbNotes: Prisma.$IpynbPayload<ExtArgs>[]
      QAPair: Prisma.$QAPairPayload<ExtArgs>[]
      practiceExam: Prisma.$PracticeExamPayload<ExtArgs>[]
      toDo: Prisma.$ToDoPayload<ExtArgs>[]
      Kanban: Prisma.$KanbanPayload<ExtArgs> | null
      todoList: Prisma.$ToDoListPayload<ExtArgs>[]
      bibEntries: Prisma.$BibEntryPayload<ExtArgs>[]
      equations: Prisma.$EquationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      value: string
      kanbanId: number | null
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `value`
     * const topicWithValueOnly = await prisma.topic.findMany({ select: { value: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `value`
     * const topicWithValueOnly = await prisma.topic.createManyAndReturn({ 
     *   select: { value: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MdxNotes<T extends Topic$MdxNotesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$MdxNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany"> | Null>
    ipynbNotes<T extends Topic$ipynbNotesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$ipynbNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findMany"> | Null>
    QAPair<T extends Topic$QAPairArgs<ExtArgs> = {}>(args?: Subset<T, Topic$QAPairArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findMany"> | Null>
    practiceExam<T extends Topic$practiceExamArgs<ExtArgs> = {}>(args?: Subset<T, Topic$practiceExamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findMany"> | Null>
    toDo<T extends Topic$toDoArgs<ExtArgs> = {}>(args?: Subset<T, Topic$toDoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findMany"> | Null>
    Kanban<T extends Topic$KanbanArgs<ExtArgs> = {}>(args?: Subset<T, Topic$KanbanArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    todoList<T extends Topic$todoListArgs<ExtArgs> = {}>(args?: Subset<T, Topic$todoListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findMany"> | Null>
    bibEntries<T extends Topic$bibEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$bibEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany"> | Null>
    equations<T extends Topic$equationsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$equationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */ 
  interface TopicFieldRefs {
    readonly value: FieldRef<"Topic", 'String'>
    readonly kanbanId: FieldRef<"Topic", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
  }

  /**
   * Topic.MdxNotes
   */
  export type Topic$MdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    cursor?: MdxNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * Topic.ipynbNotes
   */
  export type Topic$ipynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    where?: IpynbWhereInput
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    cursor?: IpynbWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * Topic.QAPair
   */
  export type Topic$QAPairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    where?: QAPairWhereInput
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    cursor?: QAPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * Topic.practiceExam
   */
  export type Topic$practiceExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    where?: PracticeExamWhereInput
    orderBy?: PracticeExamOrderByWithRelationInput | PracticeExamOrderByWithRelationInput[]
    cursor?: PracticeExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PracticeExamScalarFieldEnum | PracticeExamScalarFieldEnum[]
  }

  /**
   * Topic.toDo
   */
  export type Topic$toDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    where?: ToDoWhereInput
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    cursor?: ToDoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * Topic.Kanban
   */
  export type Topic$KanbanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    where?: KanbanWhereInput
  }

  /**
   * Topic.todoList
   */
  export type Topic$todoListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    where?: ToDoListWhereInput
    orderBy?: ToDoListOrderByWithRelationInput | ToDoListOrderByWithRelationInput[]
    cursor?: ToDoListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoListScalarFieldEnum | ToDoListScalarFieldEnum[]
  }

  /**
   * Topic.bibEntries
   */
  export type Topic$bibEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    cursor?: BibEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * Topic.equations
   */
  export type Topic$equationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    where?: EquationWhereInput
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    cursor?: EquationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquationScalarFieldEnum | EquationScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    kanbanId: number | null
  }

  export type TagSumAggregateOutputType = {
    kanbanId: number | null
  }

  export type TagMinAggregateOutputType = {
    value: string | null
    kanbanId: number | null
  }

  export type TagMaxAggregateOutputType = {
    value: string | null
    kanbanId: number | null
  }

  export type TagCountAggregateOutputType = {
    value: number
    kanbanId: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    kanbanId?: true
  }

  export type TagSumAggregateInputType = {
    kanbanId?: true
  }

  export type TagMinAggregateInputType = {
    value?: true
    kanbanId?: true
  }

  export type TagMaxAggregateInputType = {
    value?: true
    kanbanId?: true
  }

  export type TagCountAggregateInputType = {
    value?: true
    kanbanId?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    value: string
    kanbanId: number | null
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    kanbanId?: boolean
    MdxNotes?: boolean | Tag$MdxNotesArgs<ExtArgs>
    bibEntries?: boolean | Tag$bibEntriesArgs<ExtArgs>
    ipynbNotes?: boolean | Tag$ipynbNotesArgs<ExtArgs>
    QAPair?: boolean | Tag$QAPairArgs<ExtArgs>
    practiceExam?: boolean | Tag$practiceExamArgs<ExtArgs>
    equations?: boolean | Tag$equationsArgs<ExtArgs>
    toDo?: boolean | Tag$toDoArgs<ExtArgs>
    Kanban?: boolean | Tag$KanbanArgs<ExtArgs>
    todoList?: boolean | Tag$todoListArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    kanbanId?: boolean
    Kanban?: boolean | Tag$KanbanArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    value?: boolean
    kanbanId?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MdxNotes?: boolean | Tag$MdxNotesArgs<ExtArgs>
    bibEntries?: boolean | Tag$bibEntriesArgs<ExtArgs>
    ipynbNotes?: boolean | Tag$ipynbNotesArgs<ExtArgs>
    QAPair?: boolean | Tag$QAPairArgs<ExtArgs>
    practiceExam?: boolean | Tag$practiceExamArgs<ExtArgs>
    equations?: boolean | Tag$equationsArgs<ExtArgs>
    toDo?: boolean | Tag$toDoArgs<ExtArgs>
    Kanban?: boolean | Tag$KanbanArgs<ExtArgs>
    todoList?: boolean | Tag$todoListArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Kanban?: boolean | Tag$KanbanArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      MdxNotes: Prisma.$MdxNotePayload<ExtArgs>[]
      bibEntries: Prisma.$BibEntryPayload<ExtArgs>[]
      ipynbNotes: Prisma.$IpynbPayload<ExtArgs>[]
      QAPair: Prisma.$QAPairPayload<ExtArgs>[]
      practiceExam: Prisma.$PracticeExamPayload<ExtArgs>[]
      equations: Prisma.$EquationPayload<ExtArgs>[]
      toDo: Prisma.$ToDoPayload<ExtArgs>[]
      Kanban: Prisma.$KanbanPayload<ExtArgs> | null
      todoList: Prisma.$ToDoListPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      value: string
      kanbanId: number | null
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `value`
     * const tagWithValueOnly = await prisma.tag.findMany({ select: { value: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `value`
     * const tagWithValueOnly = await prisma.tag.createManyAndReturn({ 
     *   select: { value: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MdxNotes<T extends Tag$MdxNotesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$MdxNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany"> | Null>
    bibEntries<T extends Tag$bibEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$bibEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany"> | Null>
    ipynbNotes<T extends Tag$ipynbNotesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$ipynbNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findMany"> | Null>
    QAPair<T extends Tag$QAPairArgs<ExtArgs> = {}>(args?: Subset<T, Tag$QAPairArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findMany"> | Null>
    practiceExam<T extends Tag$practiceExamArgs<ExtArgs> = {}>(args?: Subset<T, Tag$practiceExamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findMany"> | Null>
    equations<T extends Tag$equationsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$equationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findMany"> | Null>
    toDo<T extends Tag$toDoArgs<ExtArgs> = {}>(args?: Subset<T, Tag$toDoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findMany"> | Null>
    Kanban<T extends Tag$KanbanArgs<ExtArgs> = {}>(args?: Subset<T, Tag$KanbanArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    todoList<T extends Tag$todoListArgs<ExtArgs> = {}>(args?: Subset<T, Tag$todoListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly value: FieldRef<"Tag", 'String'>
    readonly kanbanId: FieldRef<"Tag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }

  /**
   * Tag.MdxNotes
   */
  export type Tag$MdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    cursor?: MdxNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * Tag.bibEntries
   */
  export type Tag$bibEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    cursor?: BibEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * Tag.ipynbNotes
   */
  export type Tag$ipynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    where?: IpynbWhereInput
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    cursor?: IpynbWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * Tag.QAPair
   */
  export type Tag$QAPairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    where?: QAPairWhereInput
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    cursor?: QAPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * Tag.practiceExam
   */
  export type Tag$practiceExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    where?: PracticeExamWhereInput
    orderBy?: PracticeExamOrderByWithRelationInput | PracticeExamOrderByWithRelationInput[]
    cursor?: PracticeExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PracticeExamScalarFieldEnum | PracticeExamScalarFieldEnum[]
  }

  /**
   * Tag.equations
   */
  export type Tag$equationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    where?: EquationWhereInput
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    cursor?: EquationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquationScalarFieldEnum | EquationScalarFieldEnum[]
  }

  /**
   * Tag.toDo
   */
  export type Tag$toDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    where?: ToDoWhereInput
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    cursor?: ToDoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * Tag.Kanban
   */
  export type Tag$KanbanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    where?: KanbanWhereInput
  }

  /**
   * Tag.todoList
   */
  export type Tag$todoListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    where?: ToDoListWhereInput
    orderBy?: ToDoListOrderByWithRelationInput | ToDoListOrderByWithRelationInput[]
    cursor?: ToDoListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoListScalarFieldEnum | ToDoListScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteMinAggregateOutputType = {
    body: string | null
    author: string | null
    source: string | null
    pinned: boolean | null
    createdAt: Date | null
  }

  export type QuoteMaxAggregateOutputType = {
    body: string | null
    author: string | null
    source: string | null
    pinned: boolean | null
    createdAt: Date | null
  }

  export type QuoteCountAggregateOutputType = {
    body: number
    author: number
    source: number
    pinned: number
    createdAt: number
    _all: number
  }


  export type QuoteMinAggregateInputType = {
    body?: true
    author?: true
    source?: true
    pinned?: true
    createdAt?: true
  }

  export type QuoteMaxAggregateInputType = {
    body?: true
    author?: true
    source?: true
    pinned?: true
    createdAt?: true
  }

  export type QuoteCountAggregateInputType = {
    body?: true
    author?: true
    source?: true
    pinned?: true
    createdAt?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    body: string
    author: string
    source: string | null
    pinned: boolean
    createdAt: Date
    _count: QuoteCountAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    body?: boolean
    author?: boolean
    source?: boolean
    pinned?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    body?: boolean
    author?: boolean
    source?: boolean
    pinned?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    body?: boolean
    author?: boolean
    source?: boolean
    pinned?: boolean
    createdAt?: boolean
  }


  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      body: string
      author: string
      source: string | null
      pinned: boolean
      createdAt: Date
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `body`
     * const quoteWithBodyOnly = await prisma.quote.findMany({ select: { body: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `body`
     * const quoteWithBodyOnly = await prisma.quote.createManyAndReturn({ 
     *   select: { body: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */ 
  interface QuoteFieldRefs {
    readonly body: FieldRef<"Quote", 'String'>
    readonly author: FieldRef<"Quote", 'String'>
    readonly source: FieldRef<"Quote", 'String'>
    readonly pinned: FieldRef<"Quote", 'Boolean'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
  }


  /**
   * Model DailyFocus
   */

  export type AggregateDailyFocus = {
    _count: DailyFocusCountAggregateOutputType | null
    _min: DailyFocusMinAggregateOutputType | null
    _max: DailyFocusMaxAggregateOutputType | null
  }

  export type DailyFocusMinAggregateOutputType = {
    value: string | null
    createdAt: Date | null
  }

  export type DailyFocusMaxAggregateOutputType = {
    value: string | null
    createdAt: Date | null
  }

  export type DailyFocusCountAggregateOutputType = {
    value: number
    createdAt: number
    _all: number
  }


  export type DailyFocusMinAggregateInputType = {
    value?: true
    createdAt?: true
  }

  export type DailyFocusMaxAggregateInputType = {
    value?: true
    createdAt?: true
  }

  export type DailyFocusCountAggregateInputType = {
    value?: true
    createdAt?: true
    _all?: true
  }

  export type DailyFocusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyFocus to aggregate.
     */
    where?: DailyFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyFoci to fetch.
     */
    orderBy?: DailyFocusOrderByWithRelationInput | DailyFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyFoci
    **/
    _count?: true | DailyFocusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyFocusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyFocusMaxAggregateInputType
  }

  export type GetDailyFocusAggregateType<T extends DailyFocusAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyFocus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyFocus[P]>
      : GetScalarType<T[P], AggregateDailyFocus[P]>
  }




  export type DailyFocusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyFocusWhereInput
    orderBy?: DailyFocusOrderByWithAggregationInput | DailyFocusOrderByWithAggregationInput[]
    by: DailyFocusScalarFieldEnum[] | DailyFocusScalarFieldEnum
    having?: DailyFocusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyFocusCountAggregateInputType | true
    _min?: DailyFocusMinAggregateInputType
    _max?: DailyFocusMaxAggregateInputType
  }

  export type DailyFocusGroupByOutputType = {
    value: string
    createdAt: Date
    _count: DailyFocusCountAggregateOutputType | null
    _min: DailyFocusMinAggregateOutputType | null
    _max: DailyFocusMaxAggregateOutputType | null
  }

  type GetDailyFocusGroupByPayload<T extends DailyFocusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyFocusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyFocusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyFocusGroupByOutputType[P]>
            : GetScalarType<T[P], DailyFocusGroupByOutputType[P]>
        }
      >
    >


  export type DailyFocusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["dailyFocus"]>

  export type DailyFocusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["dailyFocus"]>

  export type DailyFocusSelectScalar = {
    value?: boolean
    createdAt?: boolean
  }


  export type $DailyFocusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyFocus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      value: string
      createdAt: Date
    }, ExtArgs["result"]["dailyFocus"]>
    composites: {}
  }

  type DailyFocusGetPayload<S extends boolean | null | undefined | DailyFocusDefaultArgs> = $Result.GetResult<Prisma.$DailyFocusPayload, S>

  type DailyFocusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyFocusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyFocusCountAggregateInputType | true
    }

  export interface DailyFocusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyFocus'], meta: { name: 'DailyFocus' } }
    /**
     * Find zero or one DailyFocus that matches the filter.
     * @param {DailyFocusFindUniqueArgs} args - Arguments to find a DailyFocus
     * @example
     * // Get one DailyFocus
     * const dailyFocus = await prisma.dailyFocus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyFocusFindUniqueArgs>(args: SelectSubset<T, DailyFocusFindUniqueArgs<ExtArgs>>): Prisma__DailyFocusClient<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyFocus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyFocusFindUniqueOrThrowArgs} args - Arguments to find a DailyFocus
     * @example
     * // Get one DailyFocus
     * const dailyFocus = await prisma.dailyFocus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyFocusFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyFocusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyFocusClient<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyFocus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyFocusFindFirstArgs} args - Arguments to find a DailyFocus
     * @example
     * // Get one DailyFocus
     * const dailyFocus = await prisma.dailyFocus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyFocusFindFirstArgs>(args?: SelectSubset<T, DailyFocusFindFirstArgs<ExtArgs>>): Prisma__DailyFocusClient<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyFocus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyFocusFindFirstOrThrowArgs} args - Arguments to find a DailyFocus
     * @example
     * // Get one DailyFocus
     * const dailyFocus = await prisma.dailyFocus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyFocusFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyFocusFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyFocusClient<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyFoci that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyFocusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyFoci
     * const dailyFoci = await prisma.dailyFocus.findMany()
     * 
     * // Get first 10 DailyFoci
     * const dailyFoci = await prisma.dailyFocus.findMany({ take: 10 })
     * 
     * // Only select the `value`
     * const dailyFocusWithValueOnly = await prisma.dailyFocus.findMany({ select: { value: true } })
     * 
     */
    findMany<T extends DailyFocusFindManyArgs>(args?: SelectSubset<T, DailyFocusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyFocus.
     * @param {DailyFocusCreateArgs} args - Arguments to create a DailyFocus.
     * @example
     * // Create one DailyFocus
     * const DailyFocus = await prisma.dailyFocus.create({
     *   data: {
     *     // ... data to create a DailyFocus
     *   }
     * })
     * 
     */
    create<T extends DailyFocusCreateArgs>(args: SelectSubset<T, DailyFocusCreateArgs<ExtArgs>>): Prisma__DailyFocusClient<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyFoci.
     * @param {DailyFocusCreateManyArgs} args - Arguments to create many DailyFoci.
     * @example
     * // Create many DailyFoci
     * const dailyFocus = await prisma.dailyFocus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyFocusCreateManyArgs>(args?: SelectSubset<T, DailyFocusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyFoci and returns the data saved in the database.
     * @param {DailyFocusCreateManyAndReturnArgs} args - Arguments to create many DailyFoci.
     * @example
     * // Create many DailyFoci
     * const dailyFocus = await prisma.dailyFocus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyFoci and only return the `value`
     * const dailyFocusWithValueOnly = await prisma.dailyFocus.createManyAndReturn({ 
     *   select: { value: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyFocusCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyFocusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyFocus.
     * @param {DailyFocusDeleteArgs} args - Arguments to delete one DailyFocus.
     * @example
     * // Delete one DailyFocus
     * const DailyFocus = await prisma.dailyFocus.delete({
     *   where: {
     *     // ... filter to delete one DailyFocus
     *   }
     * })
     * 
     */
    delete<T extends DailyFocusDeleteArgs>(args: SelectSubset<T, DailyFocusDeleteArgs<ExtArgs>>): Prisma__DailyFocusClient<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyFocus.
     * @param {DailyFocusUpdateArgs} args - Arguments to update one DailyFocus.
     * @example
     * // Update one DailyFocus
     * const dailyFocus = await prisma.dailyFocus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyFocusUpdateArgs>(args: SelectSubset<T, DailyFocusUpdateArgs<ExtArgs>>): Prisma__DailyFocusClient<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyFoci.
     * @param {DailyFocusDeleteManyArgs} args - Arguments to filter DailyFoci to delete.
     * @example
     * // Delete a few DailyFoci
     * const { count } = await prisma.dailyFocus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyFocusDeleteManyArgs>(args?: SelectSubset<T, DailyFocusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyFocusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyFoci
     * const dailyFocus = await prisma.dailyFocus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyFocusUpdateManyArgs>(args: SelectSubset<T, DailyFocusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyFocus.
     * @param {DailyFocusUpsertArgs} args - Arguments to update or create a DailyFocus.
     * @example
     * // Update or create a DailyFocus
     * const dailyFocus = await prisma.dailyFocus.upsert({
     *   create: {
     *     // ... data to create a DailyFocus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyFocus we want to update
     *   }
     * })
     */
    upsert<T extends DailyFocusUpsertArgs>(args: SelectSubset<T, DailyFocusUpsertArgs<ExtArgs>>): Prisma__DailyFocusClient<$Result.GetResult<Prisma.$DailyFocusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyFocusCountArgs} args - Arguments to filter DailyFoci to count.
     * @example
     * // Count the number of DailyFoci
     * const count = await prisma.dailyFocus.count({
     *   where: {
     *     // ... the filter for the DailyFoci we want to count
     *   }
     * })
    **/
    count<T extends DailyFocusCountArgs>(
      args?: Subset<T, DailyFocusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyFocusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyFocusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyFocusAggregateArgs>(args: Subset<T, DailyFocusAggregateArgs>): Prisma.PrismaPromise<GetDailyFocusAggregateType<T>>

    /**
     * Group by DailyFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyFocusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyFocusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyFocusGroupByArgs['orderBy'] }
        : { orderBy?: DailyFocusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyFocusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyFocusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyFocus model
   */
  readonly fields: DailyFocusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyFocus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyFocusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyFocus model
   */ 
  interface DailyFocusFieldRefs {
    readonly value: FieldRef<"DailyFocus", 'String'>
    readonly createdAt: FieldRef<"DailyFocus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyFocus findUnique
   */
  export type DailyFocusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * Filter, which DailyFocus to fetch.
     */
    where: DailyFocusWhereUniqueInput
  }

  /**
   * DailyFocus findUniqueOrThrow
   */
  export type DailyFocusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * Filter, which DailyFocus to fetch.
     */
    where: DailyFocusWhereUniqueInput
  }

  /**
   * DailyFocus findFirst
   */
  export type DailyFocusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * Filter, which DailyFocus to fetch.
     */
    where?: DailyFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyFoci to fetch.
     */
    orderBy?: DailyFocusOrderByWithRelationInput | DailyFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyFoci.
     */
    cursor?: DailyFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyFoci.
     */
    distinct?: DailyFocusScalarFieldEnum | DailyFocusScalarFieldEnum[]
  }

  /**
   * DailyFocus findFirstOrThrow
   */
  export type DailyFocusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * Filter, which DailyFocus to fetch.
     */
    where?: DailyFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyFoci to fetch.
     */
    orderBy?: DailyFocusOrderByWithRelationInput | DailyFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyFoci.
     */
    cursor?: DailyFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyFoci.
     */
    distinct?: DailyFocusScalarFieldEnum | DailyFocusScalarFieldEnum[]
  }

  /**
   * DailyFocus findMany
   */
  export type DailyFocusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * Filter, which DailyFoci to fetch.
     */
    where?: DailyFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyFoci to fetch.
     */
    orderBy?: DailyFocusOrderByWithRelationInput | DailyFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyFoci.
     */
    cursor?: DailyFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyFoci.
     */
    skip?: number
    distinct?: DailyFocusScalarFieldEnum | DailyFocusScalarFieldEnum[]
  }

  /**
   * DailyFocus create
   */
  export type DailyFocusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * The data needed to create a DailyFocus.
     */
    data: XOR<DailyFocusCreateInput, DailyFocusUncheckedCreateInput>
  }

  /**
   * DailyFocus createMany
   */
  export type DailyFocusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyFoci.
     */
    data: DailyFocusCreateManyInput | DailyFocusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyFocus createManyAndReturn
   */
  export type DailyFocusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyFoci.
     */
    data: DailyFocusCreateManyInput | DailyFocusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyFocus update
   */
  export type DailyFocusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * The data needed to update a DailyFocus.
     */
    data: XOR<DailyFocusUpdateInput, DailyFocusUncheckedUpdateInput>
    /**
     * Choose, which DailyFocus to update.
     */
    where: DailyFocusWhereUniqueInput
  }

  /**
   * DailyFocus updateMany
   */
  export type DailyFocusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyFoci.
     */
    data: XOR<DailyFocusUpdateManyMutationInput, DailyFocusUncheckedUpdateManyInput>
    /**
     * Filter which DailyFoci to update
     */
    where?: DailyFocusWhereInput
  }

  /**
   * DailyFocus upsert
   */
  export type DailyFocusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * The filter to search for the DailyFocus to update in case it exists.
     */
    where: DailyFocusWhereUniqueInput
    /**
     * In case the DailyFocus found by the `where` argument doesn't exist, create a new DailyFocus with this data.
     */
    create: XOR<DailyFocusCreateInput, DailyFocusUncheckedCreateInput>
    /**
     * In case the DailyFocus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyFocusUpdateInput, DailyFocusUncheckedUpdateInput>
  }

  /**
   * DailyFocus delete
   */
  export type DailyFocusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
    /**
     * Filter which DailyFocus to delete.
     */
    where: DailyFocusWhereUniqueInput
  }

  /**
   * DailyFocus deleteMany
   */
  export type DailyFocusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyFoci to delete
     */
    where?: DailyFocusWhereInput
  }

  /**
   * DailyFocus without action
   */
  export type DailyFocusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyFocus
     */
    select?: DailyFocusSelect<ExtArgs> | null
  }


  /**
   * Model AutoSetting
   */

  export type AggregateAutoSetting = {
    _count: AutoSettingCountAggregateOutputType | null
    _avg: AutoSettingAvgAggregateOutputType | null
    _sum: AutoSettingSumAggregateOutputType | null
    _min: AutoSettingMinAggregateOutputType | null
    _max: AutoSettingMaxAggregateOutputType | null
  }

  export type AutoSettingAvgAggregateOutputType = {
    id: number | null
  }

  export type AutoSettingSumAggregateOutputType = {
    id: number | null
  }

  export type AutoSettingMinAggregateOutputType = {
    id: number | null
    type: $Enums.autoSetting | null
    glob: string | null
    value: string | null
  }

  export type AutoSettingMaxAggregateOutputType = {
    id: number | null
    type: $Enums.autoSetting | null
    glob: string | null
    value: string | null
  }

  export type AutoSettingCountAggregateOutputType = {
    id: number
    type: number
    glob: number
    value: number
    _all: number
  }


  export type AutoSettingAvgAggregateInputType = {
    id?: true
  }

  export type AutoSettingSumAggregateInputType = {
    id?: true
  }

  export type AutoSettingMinAggregateInputType = {
    id?: true
    type?: true
    glob?: true
    value?: true
  }

  export type AutoSettingMaxAggregateInputType = {
    id?: true
    type?: true
    glob?: true
    value?: true
  }

  export type AutoSettingCountAggregateInputType = {
    id?: true
    type?: true
    glob?: true
    value?: true
    _all?: true
  }

  export type AutoSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoSetting to aggregate.
     */
    where?: AutoSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoSettings to fetch.
     */
    orderBy?: AutoSettingOrderByWithRelationInput | AutoSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoSettings
    **/
    _count?: true | AutoSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoSettingMaxAggregateInputType
  }

  export type GetAutoSettingAggregateType<T extends AutoSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoSetting[P]>
      : GetScalarType<T[P], AggregateAutoSetting[P]>
  }




  export type AutoSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoSettingWhereInput
    orderBy?: AutoSettingOrderByWithAggregationInput | AutoSettingOrderByWithAggregationInput[]
    by: AutoSettingScalarFieldEnum[] | AutoSettingScalarFieldEnum
    having?: AutoSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoSettingCountAggregateInputType | true
    _avg?: AutoSettingAvgAggregateInputType
    _sum?: AutoSettingSumAggregateInputType
    _min?: AutoSettingMinAggregateInputType
    _max?: AutoSettingMaxAggregateInputType
  }

  export type AutoSettingGroupByOutputType = {
    id: number
    type: $Enums.autoSetting
    glob: string
    value: string
    _count: AutoSettingCountAggregateOutputType | null
    _avg: AutoSettingAvgAggregateOutputType | null
    _sum: AutoSettingSumAggregateOutputType | null
    _min: AutoSettingMinAggregateOutputType | null
    _max: AutoSettingMaxAggregateOutputType | null
  }

  type GetAutoSettingGroupByPayload<T extends AutoSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoSettingGroupByOutputType[P]>
            : GetScalarType<T[P], AutoSettingGroupByOutputType[P]>
        }
      >
    >


  export type AutoSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    glob?: boolean
    value?: boolean
  }, ExtArgs["result"]["autoSetting"]>

  export type AutoSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    glob?: boolean
    value?: boolean
  }, ExtArgs["result"]["autoSetting"]>

  export type AutoSettingSelectScalar = {
    id?: boolean
    type?: boolean
    glob?: boolean
    value?: boolean
  }


  export type $AutoSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.autoSetting
      glob: string
      value: string
    }, ExtArgs["result"]["autoSetting"]>
    composites: {}
  }

  type AutoSettingGetPayload<S extends boolean | null | undefined | AutoSettingDefaultArgs> = $Result.GetResult<Prisma.$AutoSettingPayload, S>

  type AutoSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutoSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutoSettingCountAggregateInputType | true
    }

  export interface AutoSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoSetting'], meta: { name: 'AutoSetting' } }
    /**
     * Find zero or one AutoSetting that matches the filter.
     * @param {AutoSettingFindUniqueArgs} args - Arguments to find a AutoSetting
     * @example
     * // Get one AutoSetting
     * const autoSetting = await prisma.autoSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoSettingFindUniqueArgs>(args: SelectSubset<T, AutoSettingFindUniqueArgs<ExtArgs>>): Prisma__AutoSettingClient<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutoSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutoSettingFindUniqueOrThrowArgs} args - Arguments to find a AutoSetting
     * @example
     * // Get one AutoSetting
     * const autoSetting = await prisma.autoSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoSettingClient<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutoSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoSettingFindFirstArgs} args - Arguments to find a AutoSetting
     * @example
     * // Get one AutoSetting
     * const autoSetting = await prisma.autoSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoSettingFindFirstArgs>(args?: SelectSubset<T, AutoSettingFindFirstArgs<ExtArgs>>): Prisma__AutoSettingClient<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutoSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoSettingFindFirstOrThrowArgs} args - Arguments to find a AutoSetting
     * @example
     * // Get one AutoSetting
     * const autoSetting = await prisma.autoSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoSettingClient<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutoSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoSettings
     * const autoSettings = await prisma.autoSetting.findMany()
     * 
     * // Get first 10 AutoSettings
     * const autoSettings = await prisma.autoSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoSettingWithIdOnly = await prisma.autoSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoSettingFindManyArgs>(args?: SelectSubset<T, AutoSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutoSetting.
     * @param {AutoSettingCreateArgs} args - Arguments to create a AutoSetting.
     * @example
     * // Create one AutoSetting
     * const AutoSetting = await prisma.autoSetting.create({
     *   data: {
     *     // ... data to create a AutoSetting
     *   }
     * })
     * 
     */
    create<T extends AutoSettingCreateArgs>(args: SelectSubset<T, AutoSettingCreateArgs<ExtArgs>>): Prisma__AutoSettingClient<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutoSettings.
     * @param {AutoSettingCreateManyArgs} args - Arguments to create many AutoSettings.
     * @example
     * // Create many AutoSettings
     * const autoSetting = await prisma.autoSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoSettingCreateManyArgs>(args?: SelectSubset<T, AutoSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutoSettings and returns the data saved in the database.
     * @param {AutoSettingCreateManyAndReturnArgs} args - Arguments to create many AutoSettings.
     * @example
     * // Create many AutoSettings
     * const autoSetting = await prisma.autoSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutoSettings and only return the `id`
     * const autoSettingWithIdOnly = await prisma.autoSetting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutoSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, AutoSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutoSetting.
     * @param {AutoSettingDeleteArgs} args - Arguments to delete one AutoSetting.
     * @example
     * // Delete one AutoSetting
     * const AutoSetting = await prisma.autoSetting.delete({
     *   where: {
     *     // ... filter to delete one AutoSetting
     *   }
     * })
     * 
     */
    delete<T extends AutoSettingDeleteArgs>(args: SelectSubset<T, AutoSettingDeleteArgs<ExtArgs>>): Prisma__AutoSettingClient<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutoSetting.
     * @param {AutoSettingUpdateArgs} args - Arguments to update one AutoSetting.
     * @example
     * // Update one AutoSetting
     * const autoSetting = await prisma.autoSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoSettingUpdateArgs>(args: SelectSubset<T, AutoSettingUpdateArgs<ExtArgs>>): Prisma__AutoSettingClient<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutoSettings.
     * @param {AutoSettingDeleteManyArgs} args - Arguments to filter AutoSettings to delete.
     * @example
     * // Delete a few AutoSettings
     * const { count } = await prisma.autoSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoSettingDeleteManyArgs>(args?: SelectSubset<T, AutoSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoSettings
     * const autoSetting = await prisma.autoSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoSettingUpdateManyArgs>(args: SelectSubset<T, AutoSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoSetting.
     * @param {AutoSettingUpsertArgs} args - Arguments to update or create a AutoSetting.
     * @example
     * // Update or create a AutoSetting
     * const autoSetting = await prisma.autoSetting.upsert({
     *   create: {
     *     // ... data to create a AutoSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoSetting we want to update
     *   }
     * })
     */
    upsert<T extends AutoSettingUpsertArgs>(args: SelectSubset<T, AutoSettingUpsertArgs<ExtArgs>>): Prisma__AutoSettingClient<$Result.GetResult<Prisma.$AutoSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutoSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoSettingCountArgs} args - Arguments to filter AutoSettings to count.
     * @example
     * // Count the number of AutoSettings
     * const count = await prisma.autoSetting.count({
     *   where: {
     *     // ... the filter for the AutoSettings we want to count
     *   }
     * })
    **/
    count<T extends AutoSettingCountArgs>(
      args?: Subset<T, AutoSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoSettingAggregateArgs>(args: Subset<T, AutoSettingAggregateArgs>): Prisma.PrismaPromise<GetAutoSettingAggregateType<T>>

    /**
     * Group by AutoSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoSettingGroupByArgs['orderBy'] }
        : { orderBy?: AutoSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoSetting model
   */
  readonly fields: AutoSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoSetting model
   */ 
  interface AutoSettingFieldRefs {
    readonly id: FieldRef<"AutoSetting", 'Int'>
    readonly type: FieldRef<"AutoSetting", 'autoSetting'>
    readonly glob: FieldRef<"AutoSetting", 'String'>
    readonly value: FieldRef<"AutoSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AutoSetting findUnique
   */
  export type AutoSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * Filter, which AutoSetting to fetch.
     */
    where: AutoSettingWhereUniqueInput
  }

  /**
   * AutoSetting findUniqueOrThrow
   */
  export type AutoSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * Filter, which AutoSetting to fetch.
     */
    where: AutoSettingWhereUniqueInput
  }

  /**
   * AutoSetting findFirst
   */
  export type AutoSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * Filter, which AutoSetting to fetch.
     */
    where?: AutoSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoSettings to fetch.
     */
    orderBy?: AutoSettingOrderByWithRelationInput | AutoSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoSettings.
     */
    cursor?: AutoSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoSettings.
     */
    distinct?: AutoSettingScalarFieldEnum | AutoSettingScalarFieldEnum[]
  }

  /**
   * AutoSetting findFirstOrThrow
   */
  export type AutoSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * Filter, which AutoSetting to fetch.
     */
    where?: AutoSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoSettings to fetch.
     */
    orderBy?: AutoSettingOrderByWithRelationInput | AutoSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoSettings.
     */
    cursor?: AutoSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoSettings.
     */
    distinct?: AutoSettingScalarFieldEnum | AutoSettingScalarFieldEnum[]
  }

  /**
   * AutoSetting findMany
   */
  export type AutoSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * Filter, which AutoSettings to fetch.
     */
    where?: AutoSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoSettings to fetch.
     */
    orderBy?: AutoSettingOrderByWithRelationInput | AutoSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoSettings.
     */
    cursor?: AutoSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoSettings.
     */
    skip?: number
    distinct?: AutoSettingScalarFieldEnum | AutoSettingScalarFieldEnum[]
  }

  /**
   * AutoSetting create
   */
  export type AutoSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * The data needed to create a AutoSetting.
     */
    data: XOR<AutoSettingCreateInput, AutoSettingUncheckedCreateInput>
  }

  /**
   * AutoSetting createMany
   */
  export type AutoSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoSettings.
     */
    data: AutoSettingCreateManyInput | AutoSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutoSetting createManyAndReturn
   */
  export type AutoSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutoSettings.
     */
    data: AutoSettingCreateManyInput | AutoSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutoSetting update
   */
  export type AutoSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * The data needed to update a AutoSetting.
     */
    data: XOR<AutoSettingUpdateInput, AutoSettingUncheckedUpdateInput>
    /**
     * Choose, which AutoSetting to update.
     */
    where: AutoSettingWhereUniqueInput
  }

  /**
   * AutoSetting updateMany
   */
  export type AutoSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoSettings.
     */
    data: XOR<AutoSettingUpdateManyMutationInput, AutoSettingUncheckedUpdateManyInput>
    /**
     * Filter which AutoSettings to update
     */
    where?: AutoSettingWhereInput
  }

  /**
   * AutoSetting upsert
   */
  export type AutoSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * The filter to search for the AutoSetting to update in case it exists.
     */
    where: AutoSettingWhereUniqueInput
    /**
     * In case the AutoSetting found by the `where` argument doesn't exist, create a new AutoSetting with this data.
     */
    create: XOR<AutoSettingCreateInput, AutoSettingUncheckedCreateInput>
    /**
     * In case the AutoSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoSettingUpdateInput, AutoSettingUncheckedUpdateInput>
  }

  /**
   * AutoSetting delete
   */
  export type AutoSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
    /**
     * Filter which AutoSetting to delete.
     */
    where: AutoSettingWhereUniqueInput
  }

  /**
   * AutoSetting deleteMany
   */
  export type AutoSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoSettings to delete
     */
    where?: AutoSettingWhereInput
  }

  /**
   * AutoSetting without action
   */
  export type AutoSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoSetting
     */
    select?: AutoSettingSelect<ExtArgs> | null
  }


  /**
   * Model ReadingList
   */

  export type AggregateReadingList = {
    _count: ReadingListCountAggregateOutputType | null
    _min: ReadingListMinAggregateOutputType | null
    _max: ReadingListMaxAggregateOutputType | null
  }

  export type ReadingListMinAggregateOutputType = {
    name: string | null
    description: string | null
    createdAt: Date | null
    lastUpdate: Date | null
  }

  export type ReadingListMaxAggregateOutputType = {
    name: string | null
    description: string | null
    createdAt: Date | null
    lastUpdate: Date | null
  }

  export type ReadingListCountAggregateOutputType = {
    name: number
    description: number
    createdAt: number
    lastUpdate: number
    _all: number
  }


  export type ReadingListMinAggregateInputType = {
    name?: true
    description?: true
    createdAt?: true
    lastUpdate?: true
  }

  export type ReadingListMaxAggregateInputType = {
    name?: true
    description?: true
    createdAt?: true
    lastUpdate?: true
  }

  export type ReadingListCountAggregateInputType = {
    name?: true
    description?: true
    createdAt?: true
    lastUpdate?: true
    _all?: true
  }

  export type ReadingListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReadingList to aggregate.
     */
    where?: ReadingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingLists to fetch.
     */
    orderBy?: ReadingListOrderByWithRelationInput | ReadingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReadingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReadingLists
    **/
    _count?: true | ReadingListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReadingListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReadingListMaxAggregateInputType
  }

  export type GetReadingListAggregateType<T extends ReadingListAggregateArgs> = {
        [P in keyof T & keyof AggregateReadingList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReadingList[P]>
      : GetScalarType<T[P], AggregateReadingList[P]>
  }




  export type ReadingListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingListWhereInput
    orderBy?: ReadingListOrderByWithAggregationInput | ReadingListOrderByWithAggregationInput[]
    by: ReadingListScalarFieldEnum[] | ReadingListScalarFieldEnum
    having?: ReadingListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReadingListCountAggregateInputType | true
    _min?: ReadingListMinAggregateInputType
    _max?: ReadingListMaxAggregateInputType
  }

  export type ReadingListGroupByOutputType = {
    name: string
    description: string | null
    createdAt: Date
    lastUpdate: Date
    _count: ReadingListCountAggregateOutputType | null
    _min: ReadingListMinAggregateOutputType | null
    _max: ReadingListMaxAggregateOutputType | null
  }

  type GetReadingListGroupByPayload<T extends ReadingListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReadingListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReadingListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReadingListGroupByOutputType[P]>
            : GetScalarType<T[P], ReadingListGroupByOutputType[P]>
        }
      >
    >


  export type ReadingListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
    bibEntries?: boolean | ReadingList$bibEntriesArgs<ExtArgs>
    mdxNotes?: boolean | ReadingList$mdxNotesArgs<ExtArgs>
    ipynbNotes?: boolean | ReadingList$ipynbNotesArgs<ExtArgs>
    _count?: boolean | ReadingListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readingList"]>

  export type ReadingListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
  }, ExtArgs["result"]["readingList"]>

  export type ReadingListSelectScalar = {
    name?: boolean
    description?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
  }

  export type ReadingListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bibEntries?: boolean | ReadingList$bibEntriesArgs<ExtArgs>
    mdxNotes?: boolean | ReadingList$mdxNotesArgs<ExtArgs>
    ipynbNotes?: boolean | ReadingList$ipynbNotesArgs<ExtArgs>
    _count?: boolean | ReadingListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReadingListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReadingListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReadingList"
    objects: {
      bibEntries: Prisma.$BibEntryPayload<ExtArgs>[]
      mdxNotes: Prisma.$MdxNotePayload<ExtArgs>[]
      ipynbNotes: Prisma.$IpynbPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      createdAt: Date
      lastUpdate: Date
    }, ExtArgs["result"]["readingList"]>
    composites: {}
  }

  type ReadingListGetPayload<S extends boolean | null | undefined | ReadingListDefaultArgs> = $Result.GetResult<Prisma.$ReadingListPayload, S>

  type ReadingListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReadingListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReadingListCountAggregateInputType | true
    }

  export interface ReadingListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReadingList'], meta: { name: 'ReadingList' } }
    /**
     * Find zero or one ReadingList that matches the filter.
     * @param {ReadingListFindUniqueArgs} args - Arguments to find a ReadingList
     * @example
     * // Get one ReadingList
     * const readingList = await prisma.readingList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReadingListFindUniqueArgs>(args: SelectSubset<T, ReadingListFindUniqueArgs<ExtArgs>>): Prisma__ReadingListClient<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReadingList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReadingListFindUniqueOrThrowArgs} args - Arguments to find a ReadingList
     * @example
     * // Get one ReadingList
     * const readingList = await prisma.readingList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReadingListFindUniqueOrThrowArgs>(args: SelectSubset<T, ReadingListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReadingListClient<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReadingList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingListFindFirstArgs} args - Arguments to find a ReadingList
     * @example
     * // Get one ReadingList
     * const readingList = await prisma.readingList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReadingListFindFirstArgs>(args?: SelectSubset<T, ReadingListFindFirstArgs<ExtArgs>>): Prisma__ReadingListClient<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReadingList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingListFindFirstOrThrowArgs} args - Arguments to find a ReadingList
     * @example
     * // Get one ReadingList
     * const readingList = await prisma.readingList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReadingListFindFirstOrThrowArgs>(args?: SelectSubset<T, ReadingListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReadingListClient<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReadingLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReadingLists
     * const readingLists = await prisma.readingList.findMany()
     * 
     * // Get first 10 ReadingLists
     * const readingLists = await prisma.readingList.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const readingListWithNameOnly = await prisma.readingList.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends ReadingListFindManyArgs>(args?: SelectSubset<T, ReadingListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReadingList.
     * @param {ReadingListCreateArgs} args - Arguments to create a ReadingList.
     * @example
     * // Create one ReadingList
     * const ReadingList = await prisma.readingList.create({
     *   data: {
     *     // ... data to create a ReadingList
     *   }
     * })
     * 
     */
    create<T extends ReadingListCreateArgs>(args: SelectSubset<T, ReadingListCreateArgs<ExtArgs>>): Prisma__ReadingListClient<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReadingLists.
     * @param {ReadingListCreateManyArgs} args - Arguments to create many ReadingLists.
     * @example
     * // Create many ReadingLists
     * const readingList = await prisma.readingList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReadingListCreateManyArgs>(args?: SelectSubset<T, ReadingListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReadingLists and returns the data saved in the database.
     * @param {ReadingListCreateManyAndReturnArgs} args - Arguments to create many ReadingLists.
     * @example
     * // Create many ReadingLists
     * const readingList = await prisma.readingList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReadingLists and only return the `name`
     * const readingListWithNameOnly = await prisma.readingList.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReadingListCreateManyAndReturnArgs>(args?: SelectSubset<T, ReadingListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReadingList.
     * @param {ReadingListDeleteArgs} args - Arguments to delete one ReadingList.
     * @example
     * // Delete one ReadingList
     * const ReadingList = await prisma.readingList.delete({
     *   where: {
     *     // ... filter to delete one ReadingList
     *   }
     * })
     * 
     */
    delete<T extends ReadingListDeleteArgs>(args: SelectSubset<T, ReadingListDeleteArgs<ExtArgs>>): Prisma__ReadingListClient<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReadingList.
     * @param {ReadingListUpdateArgs} args - Arguments to update one ReadingList.
     * @example
     * // Update one ReadingList
     * const readingList = await prisma.readingList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReadingListUpdateArgs>(args: SelectSubset<T, ReadingListUpdateArgs<ExtArgs>>): Prisma__ReadingListClient<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReadingLists.
     * @param {ReadingListDeleteManyArgs} args - Arguments to filter ReadingLists to delete.
     * @example
     * // Delete a few ReadingLists
     * const { count } = await prisma.readingList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReadingListDeleteManyArgs>(args?: SelectSubset<T, ReadingListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReadingLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReadingLists
     * const readingList = await prisma.readingList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReadingListUpdateManyArgs>(args: SelectSubset<T, ReadingListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReadingList.
     * @param {ReadingListUpsertArgs} args - Arguments to update or create a ReadingList.
     * @example
     * // Update or create a ReadingList
     * const readingList = await prisma.readingList.upsert({
     *   create: {
     *     // ... data to create a ReadingList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReadingList we want to update
     *   }
     * })
     */
    upsert<T extends ReadingListUpsertArgs>(args: SelectSubset<T, ReadingListUpsertArgs<ExtArgs>>): Prisma__ReadingListClient<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReadingLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingListCountArgs} args - Arguments to filter ReadingLists to count.
     * @example
     * // Count the number of ReadingLists
     * const count = await prisma.readingList.count({
     *   where: {
     *     // ... the filter for the ReadingLists we want to count
     *   }
     * })
    **/
    count<T extends ReadingListCountArgs>(
      args?: Subset<T, ReadingListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReadingListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReadingList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReadingListAggregateArgs>(args: Subset<T, ReadingListAggregateArgs>): Prisma.PrismaPromise<GetReadingListAggregateType<T>>

    /**
     * Group by ReadingList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReadingListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReadingListGroupByArgs['orderBy'] }
        : { orderBy?: ReadingListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReadingListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReadingListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReadingList model
   */
  readonly fields: ReadingListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReadingList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReadingListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bibEntries<T extends ReadingList$bibEntriesArgs<ExtArgs> = {}>(args?: Subset<T, ReadingList$bibEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany"> | Null>
    mdxNotes<T extends ReadingList$mdxNotesArgs<ExtArgs> = {}>(args?: Subset<T, ReadingList$mdxNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany"> | Null>
    ipynbNotes<T extends ReadingList$ipynbNotesArgs<ExtArgs> = {}>(args?: Subset<T, ReadingList$ipynbNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReadingList model
   */ 
  interface ReadingListFieldRefs {
    readonly name: FieldRef<"ReadingList", 'String'>
    readonly description: FieldRef<"ReadingList", 'String'>
    readonly createdAt: FieldRef<"ReadingList", 'DateTime'>
    readonly lastUpdate: FieldRef<"ReadingList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReadingList findUnique
   */
  export type ReadingListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * Filter, which ReadingList to fetch.
     */
    where: ReadingListWhereUniqueInput
  }

  /**
   * ReadingList findUniqueOrThrow
   */
  export type ReadingListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * Filter, which ReadingList to fetch.
     */
    where: ReadingListWhereUniqueInput
  }

  /**
   * ReadingList findFirst
   */
  export type ReadingListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * Filter, which ReadingList to fetch.
     */
    where?: ReadingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingLists to fetch.
     */
    orderBy?: ReadingListOrderByWithRelationInput | ReadingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReadingLists.
     */
    cursor?: ReadingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReadingLists.
     */
    distinct?: ReadingListScalarFieldEnum | ReadingListScalarFieldEnum[]
  }

  /**
   * ReadingList findFirstOrThrow
   */
  export type ReadingListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * Filter, which ReadingList to fetch.
     */
    where?: ReadingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingLists to fetch.
     */
    orderBy?: ReadingListOrderByWithRelationInput | ReadingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReadingLists.
     */
    cursor?: ReadingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReadingLists.
     */
    distinct?: ReadingListScalarFieldEnum | ReadingListScalarFieldEnum[]
  }

  /**
   * ReadingList findMany
   */
  export type ReadingListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * Filter, which ReadingLists to fetch.
     */
    where?: ReadingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingLists to fetch.
     */
    orderBy?: ReadingListOrderByWithRelationInput | ReadingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReadingLists.
     */
    cursor?: ReadingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingLists.
     */
    skip?: number
    distinct?: ReadingListScalarFieldEnum | ReadingListScalarFieldEnum[]
  }

  /**
   * ReadingList create
   */
  export type ReadingListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * The data needed to create a ReadingList.
     */
    data: XOR<ReadingListCreateInput, ReadingListUncheckedCreateInput>
  }

  /**
   * ReadingList createMany
   */
  export type ReadingListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReadingLists.
     */
    data: ReadingListCreateManyInput | ReadingListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReadingList createManyAndReturn
   */
  export type ReadingListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReadingLists.
     */
    data: ReadingListCreateManyInput | ReadingListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReadingList update
   */
  export type ReadingListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * The data needed to update a ReadingList.
     */
    data: XOR<ReadingListUpdateInput, ReadingListUncheckedUpdateInput>
    /**
     * Choose, which ReadingList to update.
     */
    where: ReadingListWhereUniqueInput
  }

  /**
   * ReadingList updateMany
   */
  export type ReadingListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReadingLists.
     */
    data: XOR<ReadingListUpdateManyMutationInput, ReadingListUncheckedUpdateManyInput>
    /**
     * Filter which ReadingLists to update
     */
    where?: ReadingListWhereInput
  }

  /**
   * ReadingList upsert
   */
  export type ReadingListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * The filter to search for the ReadingList to update in case it exists.
     */
    where: ReadingListWhereUniqueInput
    /**
     * In case the ReadingList found by the `where` argument doesn't exist, create a new ReadingList with this data.
     */
    create: XOR<ReadingListCreateInput, ReadingListUncheckedCreateInput>
    /**
     * In case the ReadingList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReadingListUpdateInput, ReadingListUncheckedUpdateInput>
  }

  /**
   * ReadingList delete
   */
  export type ReadingListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    /**
     * Filter which ReadingList to delete.
     */
    where: ReadingListWhereUniqueInput
  }

  /**
   * ReadingList deleteMany
   */
  export type ReadingListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReadingLists to delete
     */
    where?: ReadingListWhereInput
  }

  /**
   * ReadingList.bibEntries
   */
  export type ReadingList$bibEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    cursor?: BibEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * ReadingList.mdxNotes
   */
  export type ReadingList$mdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    cursor?: MdxNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * ReadingList.ipynbNotes
   */
  export type ReadingList$ipynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    where?: IpynbWhereInput
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    cursor?: IpynbWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * ReadingList without action
   */
  export type ReadingListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
  }


  /**
   * Model BibEntry
   */

  export type AggregateBibEntry = {
    _count: BibEntryCountAggregateOutputType | null
    _avg: BibEntryAvgAggregateOutputType | null
    _sum: BibEntrySumAggregateOutputType | null
    _min: BibEntryMinAggregateOutputType | null
    _max: BibEntryMaxAggregateOutputType | null
  }

  export type BibEntryAvgAggregateOutputType = {
    BibId: number | null
  }

  export type BibEntrySumAggregateOutputType = {
    BibId: number | null
  }

  export type BibEntryMinAggregateOutputType = {
    id: string | null
    BibId: number | null
    OwnWork: boolean | null
    ColleaguesWork: boolean | null
    read: boolean | null
    htmlCitation: string | null
    PdfPath: string | null
    address: string | null
    annote: string | null
    author: string | null
    booktitle: string | null
    chapter: string | null
    crossref: string | null
    doi: string | null
    edition: string | null
    editor: string | null
    email: string | null
    howpublished: string | null
    institution: string | null
    journal: string | null
    month: string | null
    note: string | null
    number: string | null
    organization: string | null
    pages: string | null
    publisher: string | null
    school: string | null
    series: string | null
    title: string | null
    volume: string | null
    type: string | null
    year: string | null
    numpages: string | null
    url: string | null
    issue: string | null
    issn: string | null
    abstract: string | null
    urldate: string | null
    keywords: string | null
    copyright: string | null
    added: Date | null
  }

  export type BibEntryMaxAggregateOutputType = {
    id: string | null
    BibId: number | null
    OwnWork: boolean | null
    ColleaguesWork: boolean | null
    read: boolean | null
    htmlCitation: string | null
    PdfPath: string | null
    address: string | null
    annote: string | null
    author: string | null
    booktitle: string | null
    chapter: string | null
    crossref: string | null
    doi: string | null
    edition: string | null
    editor: string | null
    email: string | null
    howpublished: string | null
    institution: string | null
    journal: string | null
    month: string | null
    note: string | null
    number: string | null
    organization: string | null
    pages: string | null
    publisher: string | null
    school: string | null
    series: string | null
    title: string | null
    volume: string | null
    type: string | null
    year: string | null
    numpages: string | null
    url: string | null
    issue: string | null
    issn: string | null
    abstract: string | null
    urldate: string | null
    keywords: string | null
    copyright: string | null
    added: Date | null
  }

  export type BibEntryCountAggregateOutputType = {
    id: number
    BibId: number
    OwnWork: number
    ColleaguesWork: number
    read: number
    htmlCitation: number
    PdfPath: number
    address: number
    annote: number
    author: number
    booktitle: number
    chapter: number
    crossref: number
    doi: number
    edition: number
    editor: number
    email: number
    howpublished: number
    institution: number
    journal: number
    month: number
    note: number
    number: number
    organization: number
    pages: number
    publisher: number
    school: number
    series: number
    title: number
    volume: number
    type: number
    year: number
    numpages: number
    url: number
    issue: number
    issn: number
    abstract: number
    urldate: number
    keywords: number
    copyright: number
    added: number
    _all: number
  }


  export type BibEntryAvgAggregateInputType = {
    BibId?: true
  }

  export type BibEntrySumAggregateInputType = {
    BibId?: true
  }

  export type BibEntryMinAggregateInputType = {
    id?: true
    BibId?: true
    OwnWork?: true
    ColleaguesWork?: true
    read?: true
    htmlCitation?: true
    PdfPath?: true
    address?: true
    annote?: true
    author?: true
    booktitle?: true
    chapter?: true
    crossref?: true
    doi?: true
    edition?: true
    editor?: true
    email?: true
    howpublished?: true
    institution?: true
    journal?: true
    month?: true
    note?: true
    number?: true
    organization?: true
    pages?: true
    publisher?: true
    school?: true
    series?: true
    title?: true
    volume?: true
    type?: true
    year?: true
    numpages?: true
    url?: true
    issue?: true
    issn?: true
    abstract?: true
    urldate?: true
    keywords?: true
    copyright?: true
    added?: true
  }

  export type BibEntryMaxAggregateInputType = {
    id?: true
    BibId?: true
    OwnWork?: true
    ColleaguesWork?: true
    read?: true
    htmlCitation?: true
    PdfPath?: true
    address?: true
    annote?: true
    author?: true
    booktitle?: true
    chapter?: true
    crossref?: true
    doi?: true
    edition?: true
    editor?: true
    email?: true
    howpublished?: true
    institution?: true
    journal?: true
    month?: true
    note?: true
    number?: true
    organization?: true
    pages?: true
    publisher?: true
    school?: true
    series?: true
    title?: true
    volume?: true
    type?: true
    year?: true
    numpages?: true
    url?: true
    issue?: true
    issn?: true
    abstract?: true
    urldate?: true
    keywords?: true
    copyright?: true
    added?: true
  }

  export type BibEntryCountAggregateInputType = {
    id?: true
    BibId?: true
    OwnWork?: true
    ColleaguesWork?: true
    read?: true
    htmlCitation?: true
    PdfPath?: true
    address?: true
    annote?: true
    author?: true
    booktitle?: true
    chapter?: true
    crossref?: true
    doi?: true
    edition?: true
    editor?: true
    email?: true
    howpublished?: true
    institution?: true
    journal?: true
    month?: true
    note?: true
    number?: true
    organization?: true
    pages?: true
    publisher?: true
    school?: true
    series?: true
    title?: true
    volume?: true
    type?: true
    year?: true
    numpages?: true
    url?: true
    issue?: true
    issn?: true
    abstract?: true
    urldate?: true
    keywords?: true
    copyright?: true
    added?: true
    _all?: true
  }

  export type BibEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BibEntry to aggregate.
     */
    where?: BibEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BibEntries to fetch.
     */
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BibEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BibEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BibEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BibEntries
    **/
    _count?: true | BibEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BibEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BibEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BibEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BibEntryMaxAggregateInputType
  }

  export type GetBibEntryAggregateType<T extends BibEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateBibEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBibEntry[P]>
      : GetScalarType<T[P], AggregateBibEntry[P]>
  }




  export type BibEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithAggregationInput | BibEntryOrderByWithAggregationInput[]
    by: BibEntryScalarFieldEnum[] | BibEntryScalarFieldEnum
    having?: BibEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BibEntryCountAggregateInputType | true
    _avg?: BibEntryAvgAggregateInputType
    _sum?: BibEntrySumAggregateInputType
    _min?: BibEntryMinAggregateInputType
    _max?: BibEntryMaxAggregateInputType
  }

  export type BibEntryGroupByOutputType = {
    id: string
    BibId: number | null
    OwnWork: boolean
    ColleaguesWork: boolean
    read: boolean
    htmlCitation: string | null
    PdfPath: string | null
    address: string | null
    annote: string | null
    author: string | null
    booktitle: string | null
    chapter: string | null
    crossref: string | null
    doi: string | null
    edition: string | null
    editor: string | null
    email: string | null
    howpublished: string | null
    institution: string | null
    journal: string | null
    month: string | null
    note: string | null
    number: string | null
    organization: string | null
    pages: string | null
    publisher: string | null
    school: string | null
    series: string | null
    title: string | null
    volume: string | null
    type: string | null
    year: string | null
    numpages: string | null
    url: string | null
    issue: string | null
    issn: string | null
    abstract: string | null
    urldate: string | null
    keywords: string | null
    copyright: string | null
    added: Date
    _count: BibEntryCountAggregateOutputType | null
    _avg: BibEntryAvgAggregateOutputType | null
    _sum: BibEntrySumAggregateOutputType | null
    _min: BibEntryMinAggregateOutputType | null
    _max: BibEntryMaxAggregateOutputType | null
  }

  type GetBibEntryGroupByPayload<T extends BibEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BibEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BibEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BibEntryGroupByOutputType[P]>
            : GetScalarType<T[P], BibEntryGroupByOutputType[P]>
        }
      >
    >


  export type BibEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    BibId?: boolean
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: boolean
    PdfPath?: boolean
    address?: boolean
    annote?: boolean
    author?: boolean
    booktitle?: boolean
    chapter?: boolean
    crossref?: boolean
    doi?: boolean
    edition?: boolean
    editor?: boolean
    email?: boolean
    howpublished?: boolean
    institution?: boolean
    journal?: boolean
    month?: boolean
    note?: boolean
    number?: boolean
    organization?: boolean
    pages?: boolean
    publisher?: boolean
    school?: boolean
    series?: boolean
    title?: boolean
    volume?: boolean
    type?: boolean
    year?: boolean
    numpages?: boolean
    url?: boolean
    issue?: boolean
    issn?: boolean
    abstract?: boolean
    urldate?: boolean
    keywords?: boolean
    copyright?: boolean
    added?: boolean
    Bib?: boolean | BibEntry$BibArgs<ExtArgs>
    citationGroups?: boolean | BibEntry$citationGroupsArgs<ExtArgs>
    tags?: boolean | BibEntry$tagsArgs<ExtArgs>
    topics?: boolean | BibEntry$topicsArgs<ExtArgs>
    subjects?: boolean | BibEntry$subjectsArgs<ExtArgs>
    MdxNotes?: boolean | BibEntry$MdxNotesArgs<ExtArgs>
    ipynbNotes?: boolean | BibEntry$ipynbNotesArgs<ExtArgs>
    readingList?: boolean | BibEntry$readingListArgs<ExtArgs>
    _count?: boolean | BibEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bibEntry"]>

  export type BibEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    BibId?: boolean
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: boolean
    PdfPath?: boolean
    address?: boolean
    annote?: boolean
    author?: boolean
    booktitle?: boolean
    chapter?: boolean
    crossref?: boolean
    doi?: boolean
    edition?: boolean
    editor?: boolean
    email?: boolean
    howpublished?: boolean
    institution?: boolean
    journal?: boolean
    month?: boolean
    note?: boolean
    number?: boolean
    organization?: boolean
    pages?: boolean
    publisher?: boolean
    school?: boolean
    series?: boolean
    title?: boolean
    volume?: boolean
    type?: boolean
    year?: boolean
    numpages?: boolean
    url?: boolean
    issue?: boolean
    issn?: boolean
    abstract?: boolean
    urldate?: boolean
    keywords?: boolean
    copyright?: boolean
    added?: boolean
    Bib?: boolean | BibEntry$BibArgs<ExtArgs>
  }, ExtArgs["result"]["bibEntry"]>

  export type BibEntrySelectScalar = {
    id?: boolean
    BibId?: boolean
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: boolean
    PdfPath?: boolean
    address?: boolean
    annote?: boolean
    author?: boolean
    booktitle?: boolean
    chapter?: boolean
    crossref?: boolean
    doi?: boolean
    edition?: boolean
    editor?: boolean
    email?: boolean
    howpublished?: boolean
    institution?: boolean
    journal?: boolean
    month?: boolean
    note?: boolean
    number?: boolean
    organization?: boolean
    pages?: boolean
    publisher?: boolean
    school?: boolean
    series?: boolean
    title?: boolean
    volume?: boolean
    type?: boolean
    year?: boolean
    numpages?: boolean
    url?: boolean
    issue?: boolean
    issn?: boolean
    abstract?: boolean
    urldate?: boolean
    keywords?: boolean
    copyright?: boolean
    added?: boolean
  }

  export type BibEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bib?: boolean | BibEntry$BibArgs<ExtArgs>
    citationGroups?: boolean | BibEntry$citationGroupsArgs<ExtArgs>
    tags?: boolean | BibEntry$tagsArgs<ExtArgs>
    topics?: boolean | BibEntry$topicsArgs<ExtArgs>
    subjects?: boolean | BibEntry$subjectsArgs<ExtArgs>
    MdxNotes?: boolean | BibEntry$MdxNotesArgs<ExtArgs>
    ipynbNotes?: boolean | BibEntry$ipynbNotesArgs<ExtArgs>
    readingList?: boolean | BibEntry$readingListArgs<ExtArgs>
    _count?: boolean | BibEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BibEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bib?: boolean | BibEntry$BibArgs<ExtArgs>
  }

  export type $BibEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BibEntry"
    objects: {
      Bib: Prisma.$BibPayload<ExtArgs> | null
      citationGroups: Prisma.$CitationsGroupPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      MdxNotes: Prisma.$MdxNotePayload<ExtArgs>[]
      ipynbNotes: Prisma.$IpynbPayload<ExtArgs>[]
      readingList: Prisma.$ReadingListPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      BibId: number | null
      OwnWork: boolean
      ColleaguesWork: boolean
      read: boolean
      htmlCitation: string | null
      PdfPath: string | null
      address: string | null
      annote: string | null
      author: string | null
      booktitle: string | null
      chapter: string | null
      crossref: string | null
      doi: string | null
      edition: string | null
      editor: string | null
      email: string | null
      howpublished: string | null
      institution: string | null
      journal: string | null
      month: string | null
      note: string | null
      number: string | null
      organization: string | null
      pages: string | null
      publisher: string | null
      school: string | null
      series: string | null
      title: string | null
      volume: string | null
      type: string | null
      year: string | null
      numpages: string | null
      url: string | null
      issue: string | null
      issn: string | null
      abstract: string | null
      urldate: string | null
      keywords: string | null
      copyright: string | null
      added: Date
    }, ExtArgs["result"]["bibEntry"]>
    composites: {}
  }

  type BibEntryGetPayload<S extends boolean | null | undefined | BibEntryDefaultArgs> = $Result.GetResult<Prisma.$BibEntryPayload, S>

  type BibEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BibEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BibEntryCountAggregateInputType | true
    }

  export interface BibEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BibEntry'], meta: { name: 'BibEntry' } }
    /**
     * Find zero or one BibEntry that matches the filter.
     * @param {BibEntryFindUniqueArgs} args - Arguments to find a BibEntry
     * @example
     * // Get one BibEntry
     * const bibEntry = await prisma.bibEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BibEntryFindUniqueArgs>(args: SelectSubset<T, BibEntryFindUniqueArgs<ExtArgs>>): Prisma__BibEntryClient<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BibEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BibEntryFindUniqueOrThrowArgs} args - Arguments to find a BibEntry
     * @example
     * // Get one BibEntry
     * const bibEntry = await prisma.bibEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BibEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, BibEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BibEntryClient<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BibEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibEntryFindFirstArgs} args - Arguments to find a BibEntry
     * @example
     * // Get one BibEntry
     * const bibEntry = await prisma.bibEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BibEntryFindFirstArgs>(args?: SelectSubset<T, BibEntryFindFirstArgs<ExtArgs>>): Prisma__BibEntryClient<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BibEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibEntryFindFirstOrThrowArgs} args - Arguments to find a BibEntry
     * @example
     * // Get one BibEntry
     * const bibEntry = await prisma.bibEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BibEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, BibEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BibEntryClient<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BibEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BibEntries
     * const bibEntries = await prisma.bibEntry.findMany()
     * 
     * // Get first 10 BibEntries
     * const bibEntries = await prisma.bibEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bibEntryWithIdOnly = await prisma.bibEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BibEntryFindManyArgs>(args?: SelectSubset<T, BibEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BibEntry.
     * @param {BibEntryCreateArgs} args - Arguments to create a BibEntry.
     * @example
     * // Create one BibEntry
     * const BibEntry = await prisma.bibEntry.create({
     *   data: {
     *     // ... data to create a BibEntry
     *   }
     * })
     * 
     */
    create<T extends BibEntryCreateArgs>(args: SelectSubset<T, BibEntryCreateArgs<ExtArgs>>): Prisma__BibEntryClient<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BibEntries.
     * @param {BibEntryCreateManyArgs} args - Arguments to create many BibEntries.
     * @example
     * // Create many BibEntries
     * const bibEntry = await prisma.bibEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BibEntryCreateManyArgs>(args?: SelectSubset<T, BibEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BibEntries and returns the data saved in the database.
     * @param {BibEntryCreateManyAndReturnArgs} args - Arguments to create many BibEntries.
     * @example
     * // Create many BibEntries
     * const bibEntry = await prisma.bibEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BibEntries and only return the `id`
     * const bibEntryWithIdOnly = await prisma.bibEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BibEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, BibEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BibEntry.
     * @param {BibEntryDeleteArgs} args - Arguments to delete one BibEntry.
     * @example
     * // Delete one BibEntry
     * const BibEntry = await prisma.bibEntry.delete({
     *   where: {
     *     // ... filter to delete one BibEntry
     *   }
     * })
     * 
     */
    delete<T extends BibEntryDeleteArgs>(args: SelectSubset<T, BibEntryDeleteArgs<ExtArgs>>): Prisma__BibEntryClient<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BibEntry.
     * @param {BibEntryUpdateArgs} args - Arguments to update one BibEntry.
     * @example
     * // Update one BibEntry
     * const bibEntry = await prisma.bibEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BibEntryUpdateArgs>(args: SelectSubset<T, BibEntryUpdateArgs<ExtArgs>>): Prisma__BibEntryClient<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BibEntries.
     * @param {BibEntryDeleteManyArgs} args - Arguments to filter BibEntries to delete.
     * @example
     * // Delete a few BibEntries
     * const { count } = await prisma.bibEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BibEntryDeleteManyArgs>(args?: SelectSubset<T, BibEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BibEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BibEntries
     * const bibEntry = await prisma.bibEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BibEntryUpdateManyArgs>(args: SelectSubset<T, BibEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BibEntry.
     * @param {BibEntryUpsertArgs} args - Arguments to update or create a BibEntry.
     * @example
     * // Update or create a BibEntry
     * const bibEntry = await prisma.bibEntry.upsert({
     *   create: {
     *     // ... data to create a BibEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BibEntry we want to update
     *   }
     * })
     */
    upsert<T extends BibEntryUpsertArgs>(args: SelectSubset<T, BibEntryUpsertArgs<ExtArgs>>): Prisma__BibEntryClient<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BibEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibEntryCountArgs} args - Arguments to filter BibEntries to count.
     * @example
     * // Count the number of BibEntries
     * const count = await prisma.bibEntry.count({
     *   where: {
     *     // ... the filter for the BibEntries we want to count
     *   }
     * })
    **/
    count<T extends BibEntryCountArgs>(
      args?: Subset<T, BibEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BibEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BibEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BibEntryAggregateArgs>(args: Subset<T, BibEntryAggregateArgs>): Prisma.PrismaPromise<GetBibEntryAggregateType<T>>

    /**
     * Group by BibEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BibEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BibEntryGroupByArgs['orderBy'] }
        : { orderBy?: BibEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BibEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBibEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BibEntry model
   */
  readonly fields: BibEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BibEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BibEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Bib<T extends BibEntry$BibArgs<ExtArgs> = {}>(args?: Subset<T, BibEntry$BibArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    citationGroups<T extends BibEntry$citationGroupsArgs<ExtArgs> = {}>(args?: Subset<T, BibEntry$citationGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends BibEntry$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BibEntry$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    topics<T extends BibEntry$topicsArgs<ExtArgs> = {}>(args?: Subset<T, BibEntry$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends BibEntry$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, BibEntry$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    MdxNotes<T extends BibEntry$MdxNotesArgs<ExtArgs> = {}>(args?: Subset<T, BibEntry$MdxNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany"> | Null>
    ipynbNotes<T extends BibEntry$ipynbNotesArgs<ExtArgs> = {}>(args?: Subset<T, BibEntry$ipynbNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findMany"> | Null>
    readingList<T extends BibEntry$readingListArgs<ExtArgs> = {}>(args?: Subset<T, BibEntry$readingListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BibEntry model
   */ 
  interface BibEntryFieldRefs {
    readonly id: FieldRef<"BibEntry", 'String'>
    readonly BibId: FieldRef<"BibEntry", 'Int'>
    readonly OwnWork: FieldRef<"BibEntry", 'Boolean'>
    readonly ColleaguesWork: FieldRef<"BibEntry", 'Boolean'>
    readonly read: FieldRef<"BibEntry", 'Boolean'>
    readonly htmlCitation: FieldRef<"BibEntry", 'String'>
    readonly PdfPath: FieldRef<"BibEntry", 'String'>
    readonly address: FieldRef<"BibEntry", 'String'>
    readonly annote: FieldRef<"BibEntry", 'String'>
    readonly author: FieldRef<"BibEntry", 'String'>
    readonly booktitle: FieldRef<"BibEntry", 'String'>
    readonly chapter: FieldRef<"BibEntry", 'String'>
    readonly crossref: FieldRef<"BibEntry", 'String'>
    readonly doi: FieldRef<"BibEntry", 'String'>
    readonly edition: FieldRef<"BibEntry", 'String'>
    readonly editor: FieldRef<"BibEntry", 'String'>
    readonly email: FieldRef<"BibEntry", 'String'>
    readonly howpublished: FieldRef<"BibEntry", 'String'>
    readonly institution: FieldRef<"BibEntry", 'String'>
    readonly journal: FieldRef<"BibEntry", 'String'>
    readonly month: FieldRef<"BibEntry", 'String'>
    readonly note: FieldRef<"BibEntry", 'String'>
    readonly number: FieldRef<"BibEntry", 'String'>
    readonly organization: FieldRef<"BibEntry", 'String'>
    readonly pages: FieldRef<"BibEntry", 'String'>
    readonly publisher: FieldRef<"BibEntry", 'String'>
    readonly school: FieldRef<"BibEntry", 'String'>
    readonly series: FieldRef<"BibEntry", 'String'>
    readonly title: FieldRef<"BibEntry", 'String'>
    readonly volume: FieldRef<"BibEntry", 'String'>
    readonly type: FieldRef<"BibEntry", 'String'>
    readonly year: FieldRef<"BibEntry", 'String'>
    readonly numpages: FieldRef<"BibEntry", 'String'>
    readonly url: FieldRef<"BibEntry", 'String'>
    readonly issue: FieldRef<"BibEntry", 'String'>
    readonly issn: FieldRef<"BibEntry", 'String'>
    readonly abstract: FieldRef<"BibEntry", 'String'>
    readonly urldate: FieldRef<"BibEntry", 'String'>
    readonly keywords: FieldRef<"BibEntry", 'String'>
    readonly copyright: FieldRef<"BibEntry", 'String'>
    readonly added: FieldRef<"BibEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BibEntry findUnique
   */
  export type BibEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * Filter, which BibEntry to fetch.
     */
    where: BibEntryWhereUniqueInput
  }

  /**
   * BibEntry findUniqueOrThrow
   */
  export type BibEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * Filter, which BibEntry to fetch.
     */
    where: BibEntryWhereUniqueInput
  }

  /**
   * BibEntry findFirst
   */
  export type BibEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * Filter, which BibEntry to fetch.
     */
    where?: BibEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BibEntries to fetch.
     */
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BibEntries.
     */
    cursor?: BibEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BibEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BibEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BibEntries.
     */
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * BibEntry findFirstOrThrow
   */
  export type BibEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * Filter, which BibEntry to fetch.
     */
    where?: BibEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BibEntries to fetch.
     */
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BibEntries.
     */
    cursor?: BibEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BibEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BibEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BibEntries.
     */
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * BibEntry findMany
   */
  export type BibEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * Filter, which BibEntries to fetch.
     */
    where?: BibEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BibEntries to fetch.
     */
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BibEntries.
     */
    cursor?: BibEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BibEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BibEntries.
     */
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * BibEntry create
   */
  export type BibEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a BibEntry.
     */
    data: XOR<BibEntryCreateInput, BibEntryUncheckedCreateInput>
  }

  /**
   * BibEntry createMany
   */
  export type BibEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BibEntries.
     */
    data: BibEntryCreateManyInput | BibEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BibEntry createManyAndReturn
   */
  export type BibEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BibEntries.
     */
    data: BibEntryCreateManyInput | BibEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BibEntry update
   */
  export type BibEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a BibEntry.
     */
    data: XOR<BibEntryUpdateInput, BibEntryUncheckedUpdateInput>
    /**
     * Choose, which BibEntry to update.
     */
    where: BibEntryWhereUniqueInput
  }

  /**
   * BibEntry updateMany
   */
  export type BibEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BibEntries.
     */
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyInput>
    /**
     * Filter which BibEntries to update
     */
    where?: BibEntryWhereInput
  }

  /**
   * BibEntry upsert
   */
  export type BibEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the BibEntry to update in case it exists.
     */
    where: BibEntryWhereUniqueInput
    /**
     * In case the BibEntry found by the `where` argument doesn't exist, create a new BibEntry with this data.
     */
    create: XOR<BibEntryCreateInput, BibEntryUncheckedCreateInput>
    /**
     * In case the BibEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BibEntryUpdateInput, BibEntryUncheckedUpdateInput>
  }

  /**
   * BibEntry delete
   */
  export type BibEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    /**
     * Filter which BibEntry to delete.
     */
    where: BibEntryWhereUniqueInput
  }

  /**
   * BibEntry deleteMany
   */
  export type BibEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BibEntries to delete
     */
    where?: BibEntryWhereInput
  }

  /**
   * BibEntry.Bib
   */
  export type BibEntry$BibArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    where?: BibWhereInput
  }

  /**
   * BibEntry.citationGroups
   */
  export type BibEntry$citationGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    where?: CitationsGroupWhereInput
    orderBy?: CitationsGroupOrderByWithRelationInput | CitationsGroupOrderByWithRelationInput[]
    cursor?: CitationsGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitationsGroupScalarFieldEnum | CitationsGroupScalarFieldEnum[]
  }

  /**
   * BibEntry.tags
   */
  export type BibEntry$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * BibEntry.topics
   */
  export type BibEntry$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * BibEntry.subjects
   */
  export type BibEntry$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * BibEntry.MdxNotes
   */
  export type BibEntry$MdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    cursor?: MdxNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * BibEntry.ipynbNotes
   */
  export type BibEntry$ipynbNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    where?: IpynbWhereInput
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    cursor?: IpynbWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * BibEntry.readingList
   */
  export type BibEntry$readingListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    where?: ReadingListWhereInput
    orderBy?: ReadingListOrderByWithRelationInput | ReadingListOrderByWithRelationInput[]
    cursor?: ReadingListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadingListScalarFieldEnum | ReadingListScalarFieldEnum[]
  }

  /**
   * BibEntry without action
   */
  export type BibEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
  }


  /**
   * Model CitationsGroup
   */

  export type AggregateCitationsGroup = {
    _count: CitationsGroupCountAggregateOutputType | null
    _min: CitationsGroupMinAggregateOutputType | null
    _max: CitationsGroupMaxAggregateOutputType | null
  }

  export type CitationsGroupMinAggregateOutputType = {
    name: string | null
    description: string | null
  }

  export type CitationsGroupMaxAggregateOutputType = {
    name: string | null
    description: string | null
  }

  export type CitationsGroupCountAggregateOutputType = {
    name: number
    description: number
    _all: number
  }


  export type CitationsGroupMinAggregateInputType = {
    name?: true
    description?: true
  }

  export type CitationsGroupMaxAggregateInputType = {
    name?: true
    description?: true
  }

  export type CitationsGroupCountAggregateInputType = {
    name?: true
    description?: true
    _all?: true
  }

  export type CitationsGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CitationsGroup to aggregate.
     */
    where?: CitationsGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitationsGroups to fetch.
     */
    orderBy?: CitationsGroupOrderByWithRelationInput | CitationsGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CitationsGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitationsGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitationsGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CitationsGroups
    **/
    _count?: true | CitationsGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitationsGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitationsGroupMaxAggregateInputType
  }

  export type GetCitationsGroupAggregateType<T extends CitationsGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCitationsGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCitationsGroup[P]>
      : GetScalarType<T[P], AggregateCitationsGroup[P]>
  }




  export type CitationsGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitationsGroupWhereInput
    orderBy?: CitationsGroupOrderByWithAggregationInput | CitationsGroupOrderByWithAggregationInput[]
    by: CitationsGroupScalarFieldEnum[] | CitationsGroupScalarFieldEnum
    having?: CitationsGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitationsGroupCountAggregateInputType | true
    _min?: CitationsGroupMinAggregateInputType
    _max?: CitationsGroupMaxAggregateInputType
  }

  export type CitationsGroupGroupByOutputType = {
    name: string
    description: string | null
    _count: CitationsGroupCountAggregateOutputType | null
    _min: CitationsGroupMinAggregateOutputType | null
    _max: CitationsGroupMaxAggregateOutputType | null
  }

  type GetCitationsGroupGroupByPayload<T extends CitationsGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitationsGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitationsGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitationsGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CitationsGroupGroupByOutputType[P]>
        }
      >
    >


  export type CitationsGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    entries?: boolean | CitationsGroup$entriesArgs<ExtArgs>
    _count?: boolean | CitationsGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["citationsGroup"]>

  export type CitationsGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["citationsGroup"]>

  export type CitationsGroupSelectScalar = {
    name?: boolean
    description?: boolean
  }

  export type CitationsGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | CitationsGroup$entriesArgs<ExtArgs>
    _count?: boolean | CitationsGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CitationsGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CitationsGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CitationsGroup"
    objects: {
      entries: Prisma.$BibEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
    }, ExtArgs["result"]["citationsGroup"]>
    composites: {}
  }

  type CitationsGroupGetPayload<S extends boolean | null | undefined | CitationsGroupDefaultArgs> = $Result.GetResult<Prisma.$CitationsGroupPayload, S>

  type CitationsGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CitationsGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CitationsGroupCountAggregateInputType | true
    }

  export interface CitationsGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CitationsGroup'], meta: { name: 'CitationsGroup' } }
    /**
     * Find zero or one CitationsGroup that matches the filter.
     * @param {CitationsGroupFindUniqueArgs} args - Arguments to find a CitationsGroup
     * @example
     * // Get one CitationsGroup
     * const citationsGroup = await prisma.citationsGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CitationsGroupFindUniqueArgs>(args: SelectSubset<T, CitationsGroupFindUniqueArgs<ExtArgs>>): Prisma__CitationsGroupClient<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CitationsGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CitationsGroupFindUniqueOrThrowArgs} args - Arguments to find a CitationsGroup
     * @example
     * // Get one CitationsGroup
     * const citationsGroup = await prisma.citationsGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CitationsGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, CitationsGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CitationsGroupClient<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CitationsGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationsGroupFindFirstArgs} args - Arguments to find a CitationsGroup
     * @example
     * // Get one CitationsGroup
     * const citationsGroup = await prisma.citationsGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CitationsGroupFindFirstArgs>(args?: SelectSubset<T, CitationsGroupFindFirstArgs<ExtArgs>>): Prisma__CitationsGroupClient<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CitationsGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationsGroupFindFirstOrThrowArgs} args - Arguments to find a CitationsGroup
     * @example
     * // Get one CitationsGroup
     * const citationsGroup = await prisma.citationsGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CitationsGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, CitationsGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CitationsGroupClient<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CitationsGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationsGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CitationsGroups
     * const citationsGroups = await prisma.citationsGroup.findMany()
     * 
     * // Get first 10 CitationsGroups
     * const citationsGroups = await prisma.citationsGroup.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const citationsGroupWithNameOnly = await prisma.citationsGroup.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends CitationsGroupFindManyArgs>(args?: SelectSubset<T, CitationsGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CitationsGroup.
     * @param {CitationsGroupCreateArgs} args - Arguments to create a CitationsGroup.
     * @example
     * // Create one CitationsGroup
     * const CitationsGroup = await prisma.citationsGroup.create({
     *   data: {
     *     // ... data to create a CitationsGroup
     *   }
     * })
     * 
     */
    create<T extends CitationsGroupCreateArgs>(args: SelectSubset<T, CitationsGroupCreateArgs<ExtArgs>>): Prisma__CitationsGroupClient<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CitationsGroups.
     * @param {CitationsGroupCreateManyArgs} args - Arguments to create many CitationsGroups.
     * @example
     * // Create many CitationsGroups
     * const citationsGroup = await prisma.citationsGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CitationsGroupCreateManyArgs>(args?: SelectSubset<T, CitationsGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CitationsGroups and returns the data saved in the database.
     * @param {CitationsGroupCreateManyAndReturnArgs} args - Arguments to create many CitationsGroups.
     * @example
     * // Create many CitationsGroups
     * const citationsGroup = await prisma.citationsGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CitationsGroups and only return the `name`
     * const citationsGroupWithNameOnly = await prisma.citationsGroup.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CitationsGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, CitationsGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CitationsGroup.
     * @param {CitationsGroupDeleteArgs} args - Arguments to delete one CitationsGroup.
     * @example
     * // Delete one CitationsGroup
     * const CitationsGroup = await prisma.citationsGroup.delete({
     *   where: {
     *     // ... filter to delete one CitationsGroup
     *   }
     * })
     * 
     */
    delete<T extends CitationsGroupDeleteArgs>(args: SelectSubset<T, CitationsGroupDeleteArgs<ExtArgs>>): Prisma__CitationsGroupClient<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CitationsGroup.
     * @param {CitationsGroupUpdateArgs} args - Arguments to update one CitationsGroup.
     * @example
     * // Update one CitationsGroup
     * const citationsGroup = await prisma.citationsGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CitationsGroupUpdateArgs>(args: SelectSubset<T, CitationsGroupUpdateArgs<ExtArgs>>): Prisma__CitationsGroupClient<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CitationsGroups.
     * @param {CitationsGroupDeleteManyArgs} args - Arguments to filter CitationsGroups to delete.
     * @example
     * // Delete a few CitationsGroups
     * const { count } = await prisma.citationsGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CitationsGroupDeleteManyArgs>(args?: SelectSubset<T, CitationsGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CitationsGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationsGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CitationsGroups
     * const citationsGroup = await prisma.citationsGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CitationsGroupUpdateManyArgs>(args: SelectSubset<T, CitationsGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CitationsGroup.
     * @param {CitationsGroupUpsertArgs} args - Arguments to update or create a CitationsGroup.
     * @example
     * // Update or create a CitationsGroup
     * const citationsGroup = await prisma.citationsGroup.upsert({
     *   create: {
     *     // ... data to create a CitationsGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CitationsGroup we want to update
     *   }
     * })
     */
    upsert<T extends CitationsGroupUpsertArgs>(args: SelectSubset<T, CitationsGroupUpsertArgs<ExtArgs>>): Prisma__CitationsGroupClient<$Result.GetResult<Prisma.$CitationsGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CitationsGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationsGroupCountArgs} args - Arguments to filter CitationsGroups to count.
     * @example
     * // Count the number of CitationsGroups
     * const count = await prisma.citationsGroup.count({
     *   where: {
     *     // ... the filter for the CitationsGroups we want to count
     *   }
     * })
    **/
    count<T extends CitationsGroupCountArgs>(
      args?: Subset<T, CitationsGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitationsGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CitationsGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationsGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitationsGroupAggregateArgs>(args: Subset<T, CitationsGroupAggregateArgs>): Prisma.PrismaPromise<GetCitationsGroupAggregateType<T>>

    /**
     * Group by CitationsGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationsGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CitationsGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CitationsGroupGroupByArgs['orderBy'] }
        : { orderBy?: CitationsGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CitationsGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitationsGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CitationsGroup model
   */
  readonly fields: CitationsGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CitationsGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CitationsGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends CitationsGroup$entriesArgs<ExtArgs> = {}>(args?: Subset<T, CitationsGroup$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CitationsGroup model
   */ 
  interface CitationsGroupFieldRefs {
    readonly name: FieldRef<"CitationsGroup", 'String'>
    readonly description: FieldRef<"CitationsGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CitationsGroup findUnique
   */
  export type CitationsGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * Filter, which CitationsGroup to fetch.
     */
    where: CitationsGroupWhereUniqueInput
  }

  /**
   * CitationsGroup findUniqueOrThrow
   */
  export type CitationsGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * Filter, which CitationsGroup to fetch.
     */
    where: CitationsGroupWhereUniqueInput
  }

  /**
   * CitationsGroup findFirst
   */
  export type CitationsGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * Filter, which CitationsGroup to fetch.
     */
    where?: CitationsGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitationsGroups to fetch.
     */
    orderBy?: CitationsGroupOrderByWithRelationInput | CitationsGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CitationsGroups.
     */
    cursor?: CitationsGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitationsGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitationsGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CitationsGroups.
     */
    distinct?: CitationsGroupScalarFieldEnum | CitationsGroupScalarFieldEnum[]
  }

  /**
   * CitationsGroup findFirstOrThrow
   */
  export type CitationsGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * Filter, which CitationsGroup to fetch.
     */
    where?: CitationsGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitationsGroups to fetch.
     */
    orderBy?: CitationsGroupOrderByWithRelationInput | CitationsGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CitationsGroups.
     */
    cursor?: CitationsGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitationsGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitationsGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CitationsGroups.
     */
    distinct?: CitationsGroupScalarFieldEnum | CitationsGroupScalarFieldEnum[]
  }

  /**
   * CitationsGroup findMany
   */
  export type CitationsGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * Filter, which CitationsGroups to fetch.
     */
    where?: CitationsGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitationsGroups to fetch.
     */
    orderBy?: CitationsGroupOrderByWithRelationInput | CitationsGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CitationsGroups.
     */
    cursor?: CitationsGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitationsGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitationsGroups.
     */
    skip?: number
    distinct?: CitationsGroupScalarFieldEnum | CitationsGroupScalarFieldEnum[]
  }

  /**
   * CitationsGroup create
   */
  export type CitationsGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a CitationsGroup.
     */
    data: XOR<CitationsGroupCreateInput, CitationsGroupUncheckedCreateInput>
  }

  /**
   * CitationsGroup createMany
   */
  export type CitationsGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CitationsGroups.
     */
    data: CitationsGroupCreateManyInput | CitationsGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CitationsGroup createManyAndReturn
   */
  export type CitationsGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CitationsGroups.
     */
    data: CitationsGroupCreateManyInput | CitationsGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CitationsGroup update
   */
  export type CitationsGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a CitationsGroup.
     */
    data: XOR<CitationsGroupUpdateInput, CitationsGroupUncheckedUpdateInput>
    /**
     * Choose, which CitationsGroup to update.
     */
    where: CitationsGroupWhereUniqueInput
  }

  /**
   * CitationsGroup updateMany
   */
  export type CitationsGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CitationsGroups.
     */
    data: XOR<CitationsGroupUpdateManyMutationInput, CitationsGroupUncheckedUpdateManyInput>
    /**
     * Filter which CitationsGroups to update
     */
    where?: CitationsGroupWhereInput
  }

  /**
   * CitationsGroup upsert
   */
  export type CitationsGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the CitationsGroup to update in case it exists.
     */
    where: CitationsGroupWhereUniqueInput
    /**
     * In case the CitationsGroup found by the `where` argument doesn't exist, create a new CitationsGroup with this data.
     */
    create: XOR<CitationsGroupCreateInput, CitationsGroupUncheckedCreateInput>
    /**
     * In case the CitationsGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CitationsGroupUpdateInput, CitationsGroupUncheckedUpdateInput>
  }

  /**
   * CitationsGroup delete
   */
  export type CitationsGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
    /**
     * Filter which CitationsGroup to delete.
     */
    where: CitationsGroupWhereUniqueInput
  }

  /**
   * CitationsGroup deleteMany
   */
  export type CitationsGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CitationsGroups to delete
     */
    where?: CitationsGroupWhereInput
  }

  /**
   * CitationsGroup.entries
   */
  export type CitationsGroup$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    cursor?: BibEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * CitationsGroup without action
   */
  export type CitationsGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitationsGroup
     */
    select?: CitationsGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationsGroupInclude<ExtArgs> | null
  }


  /**
   * Model Bib
   */

  export type AggregateBib = {
    _count: BibCountAggregateOutputType | null
    _avg: BibAvgAggregateOutputType | null
    _sum: BibSumAggregateOutputType | null
    _min: BibMinAggregateOutputType | null
    _max: BibMaxAggregateOutputType | null
  }

  export type BibAvgAggregateOutputType = {
    id: number | null
  }

  export type BibSumAggregateOutputType = {
    id: number | null
  }

  export type BibMinAggregateOutputType = {
    id: number | null
    filename: string | null
    firstSync: Date | null
    lastSync: Date | null
  }

  export type BibMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    firstSync: Date | null
    lastSync: Date | null
  }

  export type BibCountAggregateOutputType = {
    id: number
    filename: number
    firstSync: number
    lastSync: number
    _all: number
  }


  export type BibAvgAggregateInputType = {
    id?: true
  }

  export type BibSumAggregateInputType = {
    id?: true
  }

  export type BibMinAggregateInputType = {
    id?: true
    filename?: true
    firstSync?: true
    lastSync?: true
  }

  export type BibMaxAggregateInputType = {
    id?: true
    filename?: true
    firstSync?: true
    lastSync?: true
  }

  export type BibCountAggregateInputType = {
    id?: true
    filename?: true
    firstSync?: true
    lastSync?: true
    _all?: true
  }

  export type BibAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bib to aggregate.
     */
    where?: BibWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bibs to fetch.
     */
    orderBy?: BibOrderByWithRelationInput | BibOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BibWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bibs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bibs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bibs
    **/
    _count?: true | BibCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BibAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BibSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BibMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BibMaxAggregateInputType
  }

  export type GetBibAggregateType<T extends BibAggregateArgs> = {
        [P in keyof T & keyof AggregateBib]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBib[P]>
      : GetScalarType<T[P], AggregateBib[P]>
  }




  export type BibGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BibWhereInput
    orderBy?: BibOrderByWithAggregationInput | BibOrderByWithAggregationInput[]
    by: BibScalarFieldEnum[] | BibScalarFieldEnum
    having?: BibScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BibCountAggregateInputType | true
    _avg?: BibAvgAggregateInputType
    _sum?: BibSumAggregateInputType
    _min?: BibMinAggregateInputType
    _max?: BibMaxAggregateInputType
  }

  export type BibGroupByOutputType = {
    id: number
    filename: string
    firstSync: Date
    lastSync: Date
    _count: BibCountAggregateOutputType | null
    _avg: BibAvgAggregateOutputType | null
    _sum: BibSumAggregateOutputType | null
    _min: BibMinAggregateOutputType | null
    _max: BibMaxAggregateOutputType | null
  }

  type GetBibGroupByPayload<T extends BibGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BibGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BibGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BibGroupByOutputType[P]>
            : GetScalarType<T[P], BibGroupByOutputType[P]>
        }
      >
    >


  export type BibSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    firstSync?: boolean
    lastSync?: boolean
    entries?: boolean | Bib$entriesArgs<ExtArgs>
    _count?: boolean | BibCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bib"]>

  export type BibSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    firstSync?: boolean
    lastSync?: boolean
  }, ExtArgs["result"]["bib"]>

  export type BibSelectScalar = {
    id?: boolean
    filename?: boolean
    firstSync?: boolean
    lastSync?: boolean
  }

  export type BibInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | Bib$entriesArgs<ExtArgs>
    _count?: boolean | BibCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BibIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BibPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bib"
    objects: {
      entries: Prisma.$BibEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filename: string
      firstSync: Date
      lastSync: Date
    }, ExtArgs["result"]["bib"]>
    composites: {}
  }

  type BibGetPayload<S extends boolean | null | undefined | BibDefaultArgs> = $Result.GetResult<Prisma.$BibPayload, S>

  type BibCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BibFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BibCountAggregateInputType | true
    }

  export interface BibDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bib'], meta: { name: 'Bib' } }
    /**
     * Find zero or one Bib that matches the filter.
     * @param {BibFindUniqueArgs} args - Arguments to find a Bib
     * @example
     * // Get one Bib
     * const bib = await prisma.bib.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BibFindUniqueArgs>(args: SelectSubset<T, BibFindUniqueArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bib that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BibFindUniqueOrThrowArgs} args - Arguments to find a Bib
     * @example
     * // Get one Bib
     * const bib = await prisma.bib.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BibFindUniqueOrThrowArgs>(args: SelectSubset<T, BibFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bib that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibFindFirstArgs} args - Arguments to find a Bib
     * @example
     * // Get one Bib
     * const bib = await prisma.bib.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BibFindFirstArgs>(args?: SelectSubset<T, BibFindFirstArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bib that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibFindFirstOrThrowArgs} args - Arguments to find a Bib
     * @example
     * // Get one Bib
     * const bib = await prisma.bib.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BibFindFirstOrThrowArgs>(args?: SelectSubset<T, BibFindFirstOrThrowArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bibs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bibs
     * const bibs = await prisma.bib.findMany()
     * 
     * // Get first 10 Bibs
     * const bibs = await prisma.bib.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bibWithIdOnly = await prisma.bib.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BibFindManyArgs>(args?: SelectSubset<T, BibFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bib.
     * @param {BibCreateArgs} args - Arguments to create a Bib.
     * @example
     * // Create one Bib
     * const Bib = await prisma.bib.create({
     *   data: {
     *     // ... data to create a Bib
     *   }
     * })
     * 
     */
    create<T extends BibCreateArgs>(args: SelectSubset<T, BibCreateArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bibs.
     * @param {BibCreateManyArgs} args - Arguments to create many Bibs.
     * @example
     * // Create many Bibs
     * const bib = await prisma.bib.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BibCreateManyArgs>(args?: SelectSubset<T, BibCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bibs and returns the data saved in the database.
     * @param {BibCreateManyAndReturnArgs} args - Arguments to create many Bibs.
     * @example
     * // Create many Bibs
     * const bib = await prisma.bib.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bibs and only return the `id`
     * const bibWithIdOnly = await prisma.bib.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BibCreateManyAndReturnArgs>(args?: SelectSubset<T, BibCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bib.
     * @param {BibDeleteArgs} args - Arguments to delete one Bib.
     * @example
     * // Delete one Bib
     * const Bib = await prisma.bib.delete({
     *   where: {
     *     // ... filter to delete one Bib
     *   }
     * })
     * 
     */
    delete<T extends BibDeleteArgs>(args: SelectSubset<T, BibDeleteArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bib.
     * @param {BibUpdateArgs} args - Arguments to update one Bib.
     * @example
     * // Update one Bib
     * const bib = await prisma.bib.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BibUpdateArgs>(args: SelectSubset<T, BibUpdateArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bibs.
     * @param {BibDeleteManyArgs} args - Arguments to filter Bibs to delete.
     * @example
     * // Delete a few Bibs
     * const { count } = await prisma.bib.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BibDeleteManyArgs>(args?: SelectSubset<T, BibDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bibs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bibs
     * const bib = await prisma.bib.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BibUpdateManyArgs>(args: SelectSubset<T, BibUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bib.
     * @param {BibUpsertArgs} args - Arguments to update or create a Bib.
     * @example
     * // Update or create a Bib
     * const bib = await prisma.bib.upsert({
     *   create: {
     *     // ... data to create a Bib
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bib we want to update
     *   }
     * })
     */
    upsert<T extends BibUpsertArgs>(args: SelectSubset<T, BibUpsertArgs<ExtArgs>>): Prisma__BibClient<$Result.GetResult<Prisma.$BibPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bibs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibCountArgs} args - Arguments to filter Bibs to count.
     * @example
     * // Count the number of Bibs
     * const count = await prisma.bib.count({
     *   where: {
     *     // ... the filter for the Bibs we want to count
     *   }
     * })
    **/
    count<T extends BibCountArgs>(
      args?: Subset<T, BibCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BibCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bib.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BibAggregateArgs>(args: Subset<T, BibAggregateArgs>): Prisma.PrismaPromise<GetBibAggregateType<T>>

    /**
     * Group by Bib.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BibGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BibGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BibGroupByArgs['orderBy'] }
        : { orderBy?: BibGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BibGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBibGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bib model
   */
  readonly fields: BibFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bib.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BibClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends Bib$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Bib$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bib model
   */ 
  interface BibFieldRefs {
    readonly id: FieldRef<"Bib", 'Int'>
    readonly filename: FieldRef<"Bib", 'String'>
    readonly firstSync: FieldRef<"Bib", 'DateTime'>
    readonly lastSync: FieldRef<"Bib", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bib findUnique
   */
  export type BibFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * Filter, which Bib to fetch.
     */
    where: BibWhereUniqueInput
  }

  /**
   * Bib findUniqueOrThrow
   */
  export type BibFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * Filter, which Bib to fetch.
     */
    where: BibWhereUniqueInput
  }

  /**
   * Bib findFirst
   */
  export type BibFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * Filter, which Bib to fetch.
     */
    where?: BibWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bibs to fetch.
     */
    orderBy?: BibOrderByWithRelationInput | BibOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bibs.
     */
    cursor?: BibWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bibs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bibs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bibs.
     */
    distinct?: BibScalarFieldEnum | BibScalarFieldEnum[]
  }

  /**
   * Bib findFirstOrThrow
   */
  export type BibFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * Filter, which Bib to fetch.
     */
    where?: BibWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bibs to fetch.
     */
    orderBy?: BibOrderByWithRelationInput | BibOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bibs.
     */
    cursor?: BibWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bibs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bibs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bibs.
     */
    distinct?: BibScalarFieldEnum | BibScalarFieldEnum[]
  }

  /**
   * Bib findMany
   */
  export type BibFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * Filter, which Bibs to fetch.
     */
    where?: BibWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bibs to fetch.
     */
    orderBy?: BibOrderByWithRelationInput | BibOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bibs.
     */
    cursor?: BibWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bibs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bibs.
     */
    skip?: number
    distinct?: BibScalarFieldEnum | BibScalarFieldEnum[]
  }

  /**
   * Bib create
   */
  export type BibCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * The data needed to create a Bib.
     */
    data: XOR<BibCreateInput, BibUncheckedCreateInput>
  }

  /**
   * Bib createMany
   */
  export type BibCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bibs.
     */
    data: BibCreateManyInput | BibCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bib createManyAndReturn
   */
  export type BibCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bibs.
     */
    data: BibCreateManyInput | BibCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bib update
   */
  export type BibUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * The data needed to update a Bib.
     */
    data: XOR<BibUpdateInput, BibUncheckedUpdateInput>
    /**
     * Choose, which Bib to update.
     */
    where: BibWhereUniqueInput
  }

  /**
   * Bib updateMany
   */
  export type BibUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bibs.
     */
    data: XOR<BibUpdateManyMutationInput, BibUncheckedUpdateManyInput>
    /**
     * Filter which Bibs to update
     */
    where?: BibWhereInput
  }

  /**
   * Bib upsert
   */
  export type BibUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * The filter to search for the Bib to update in case it exists.
     */
    where: BibWhereUniqueInput
    /**
     * In case the Bib found by the `where` argument doesn't exist, create a new Bib with this data.
     */
    create: XOR<BibCreateInput, BibUncheckedCreateInput>
    /**
     * In case the Bib was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BibUpdateInput, BibUncheckedUpdateInput>
  }

  /**
   * Bib delete
   */
  export type BibDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
    /**
     * Filter which Bib to delete.
     */
    where: BibWhereUniqueInput
  }

  /**
   * Bib deleteMany
   */
  export type BibDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bibs to delete
     */
    where?: BibWhereInput
  }

  /**
   * Bib.entries
   */
  export type Bib$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    cursor?: BibEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * Bib without action
   */
  export type BibDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bib
     */
    select?: BibSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibInclude<ExtArgs> | null
  }


  /**
   * Model GoogleCalendarAuth
   */

  export type AggregateGoogleCalendarAuth = {
    _count: GoogleCalendarAuthCountAggregateOutputType | null
    _avg: GoogleCalendarAuthAvgAggregateOutputType | null
    _sum: GoogleCalendarAuthSumAggregateOutputType | null
    _min: GoogleCalendarAuthMinAggregateOutputType | null
    _max: GoogleCalendarAuthMaxAggregateOutputType | null
  }

  export type GoogleCalendarAuthAvgAggregateOutputType = {
    id: number | null
  }

  export type GoogleCalendarAuthSumAggregateOutputType = {
    id: number | null
  }

  export type GoogleCalendarAuthMinAggregateOutputType = {
    id: number | null
    auth: string | null
  }

  export type GoogleCalendarAuthMaxAggregateOutputType = {
    id: number | null
    auth: string | null
  }

  export type GoogleCalendarAuthCountAggregateOutputType = {
    id: number
    auth: number
    _all: number
  }


  export type GoogleCalendarAuthAvgAggregateInputType = {
    id?: true
  }

  export type GoogleCalendarAuthSumAggregateInputType = {
    id?: true
  }

  export type GoogleCalendarAuthMinAggregateInputType = {
    id?: true
    auth?: true
  }

  export type GoogleCalendarAuthMaxAggregateInputType = {
    id?: true
    auth?: true
  }

  export type GoogleCalendarAuthCountAggregateInputType = {
    id?: true
    auth?: true
    _all?: true
  }

  export type GoogleCalendarAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleCalendarAuth to aggregate.
     */
    where?: GoogleCalendarAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleCalendarAuths to fetch.
     */
    orderBy?: GoogleCalendarAuthOrderByWithRelationInput | GoogleCalendarAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoogleCalendarAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleCalendarAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleCalendarAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoogleCalendarAuths
    **/
    _count?: true | GoogleCalendarAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoogleCalendarAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoogleCalendarAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoogleCalendarAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoogleCalendarAuthMaxAggregateInputType
  }

  export type GetGoogleCalendarAuthAggregateType<T extends GoogleCalendarAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogleCalendarAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogleCalendarAuth[P]>
      : GetScalarType<T[P], AggregateGoogleCalendarAuth[P]>
  }




  export type GoogleCalendarAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoogleCalendarAuthWhereInput
    orderBy?: GoogleCalendarAuthOrderByWithAggregationInput | GoogleCalendarAuthOrderByWithAggregationInput[]
    by: GoogleCalendarAuthScalarFieldEnum[] | GoogleCalendarAuthScalarFieldEnum
    having?: GoogleCalendarAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoogleCalendarAuthCountAggregateInputType | true
    _avg?: GoogleCalendarAuthAvgAggregateInputType
    _sum?: GoogleCalendarAuthSumAggregateInputType
    _min?: GoogleCalendarAuthMinAggregateInputType
    _max?: GoogleCalendarAuthMaxAggregateInputType
  }

  export type GoogleCalendarAuthGroupByOutputType = {
    id: number
    auth: string | null
    _count: GoogleCalendarAuthCountAggregateOutputType | null
    _avg: GoogleCalendarAuthAvgAggregateOutputType | null
    _sum: GoogleCalendarAuthSumAggregateOutputType | null
    _min: GoogleCalendarAuthMinAggregateOutputType | null
    _max: GoogleCalendarAuthMaxAggregateOutputType | null
  }

  type GetGoogleCalendarAuthGroupByPayload<T extends GoogleCalendarAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoogleCalendarAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoogleCalendarAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoogleCalendarAuthGroupByOutputType[P]>
            : GetScalarType<T[P], GoogleCalendarAuthGroupByOutputType[P]>
        }
      >
    >


  export type GoogleCalendarAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth?: boolean
  }, ExtArgs["result"]["googleCalendarAuth"]>

  export type GoogleCalendarAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth?: boolean
  }, ExtArgs["result"]["googleCalendarAuth"]>

  export type GoogleCalendarAuthSelectScalar = {
    id?: boolean
    auth?: boolean
  }


  export type $GoogleCalendarAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoogleCalendarAuth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      auth: string | null
    }, ExtArgs["result"]["googleCalendarAuth"]>
    composites: {}
  }

  type GoogleCalendarAuthGetPayload<S extends boolean | null | undefined | GoogleCalendarAuthDefaultArgs> = $Result.GetResult<Prisma.$GoogleCalendarAuthPayload, S>

  type GoogleCalendarAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoogleCalendarAuthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoogleCalendarAuthCountAggregateInputType | true
    }

  export interface GoogleCalendarAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoogleCalendarAuth'], meta: { name: 'GoogleCalendarAuth' } }
    /**
     * Find zero or one GoogleCalendarAuth that matches the filter.
     * @param {GoogleCalendarAuthFindUniqueArgs} args - Arguments to find a GoogleCalendarAuth
     * @example
     * // Get one GoogleCalendarAuth
     * const googleCalendarAuth = await prisma.googleCalendarAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoogleCalendarAuthFindUniqueArgs>(args: SelectSubset<T, GoogleCalendarAuthFindUniqueArgs<ExtArgs>>): Prisma__GoogleCalendarAuthClient<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GoogleCalendarAuth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoogleCalendarAuthFindUniqueOrThrowArgs} args - Arguments to find a GoogleCalendarAuth
     * @example
     * // Get one GoogleCalendarAuth
     * const googleCalendarAuth = await prisma.googleCalendarAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoogleCalendarAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, GoogleCalendarAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoogleCalendarAuthClient<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GoogleCalendarAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarAuthFindFirstArgs} args - Arguments to find a GoogleCalendarAuth
     * @example
     * // Get one GoogleCalendarAuth
     * const googleCalendarAuth = await prisma.googleCalendarAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoogleCalendarAuthFindFirstArgs>(args?: SelectSubset<T, GoogleCalendarAuthFindFirstArgs<ExtArgs>>): Prisma__GoogleCalendarAuthClient<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GoogleCalendarAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarAuthFindFirstOrThrowArgs} args - Arguments to find a GoogleCalendarAuth
     * @example
     * // Get one GoogleCalendarAuth
     * const googleCalendarAuth = await prisma.googleCalendarAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoogleCalendarAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, GoogleCalendarAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoogleCalendarAuthClient<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GoogleCalendarAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoogleCalendarAuths
     * const googleCalendarAuths = await prisma.googleCalendarAuth.findMany()
     * 
     * // Get first 10 GoogleCalendarAuths
     * const googleCalendarAuths = await prisma.googleCalendarAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const googleCalendarAuthWithIdOnly = await prisma.googleCalendarAuth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoogleCalendarAuthFindManyArgs>(args?: SelectSubset<T, GoogleCalendarAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GoogleCalendarAuth.
     * @param {GoogleCalendarAuthCreateArgs} args - Arguments to create a GoogleCalendarAuth.
     * @example
     * // Create one GoogleCalendarAuth
     * const GoogleCalendarAuth = await prisma.googleCalendarAuth.create({
     *   data: {
     *     // ... data to create a GoogleCalendarAuth
     *   }
     * })
     * 
     */
    create<T extends GoogleCalendarAuthCreateArgs>(args: SelectSubset<T, GoogleCalendarAuthCreateArgs<ExtArgs>>): Prisma__GoogleCalendarAuthClient<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GoogleCalendarAuths.
     * @param {GoogleCalendarAuthCreateManyArgs} args - Arguments to create many GoogleCalendarAuths.
     * @example
     * // Create many GoogleCalendarAuths
     * const googleCalendarAuth = await prisma.googleCalendarAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoogleCalendarAuthCreateManyArgs>(args?: SelectSubset<T, GoogleCalendarAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoogleCalendarAuths and returns the data saved in the database.
     * @param {GoogleCalendarAuthCreateManyAndReturnArgs} args - Arguments to create many GoogleCalendarAuths.
     * @example
     * // Create many GoogleCalendarAuths
     * const googleCalendarAuth = await prisma.googleCalendarAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoogleCalendarAuths and only return the `id`
     * const googleCalendarAuthWithIdOnly = await prisma.googleCalendarAuth.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoogleCalendarAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, GoogleCalendarAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GoogleCalendarAuth.
     * @param {GoogleCalendarAuthDeleteArgs} args - Arguments to delete one GoogleCalendarAuth.
     * @example
     * // Delete one GoogleCalendarAuth
     * const GoogleCalendarAuth = await prisma.googleCalendarAuth.delete({
     *   where: {
     *     // ... filter to delete one GoogleCalendarAuth
     *   }
     * })
     * 
     */
    delete<T extends GoogleCalendarAuthDeleteArgs>(args: SelectSubset<T, GoogleCalendarAuthDeleteArgs<ExtArgs>>): Prisma__GoogleCalendarAuthClient<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GoogleCalendarAuth.
     * @param {GoogleCalendarAuthUpdateArgs} args - Arguments to update one GoogleCalendarAuth.
     * @example
     * // Update one GoogleCalendarAuth
     * const googleCalendarAuth = await prisma.googleCalendarAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoogleCalendarAuthUpdateArgs>(args: SelectSubset<T, GoogleCalendarAuthUpdateArgs<ExtArgs>>): Prisma__GoogleCalendarAuthClient<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GoogleCalendarAuths.
     * @param {GoogleCalendarAuthDeleteManyArgs} args - Arguments to filter GoogleCalendarAuths to delete.
     * @example
     * // Delete a few GoogleCalendarAuths
     * const { count } = await prisma.googleCalendarAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoogleCalendarAuthDeleteManyArgs>(args?: SelectSubset<T, GoogleCalendarAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoogleCalendarAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoogleCalendarAuths
     * const googleCalendarAuth = await prisma.googleCalendarAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoogleCalendarAuthUpdateManyArgs>(args: SelectSubset<T, GoogleCalendarAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoogleCalendarAuth.
     * @param {GoogleCalendarAuthUpsertArgs} args - Arguments to update or create a GoogleCalendarAuth.
     * @example
     * // Update or create a GoogleCalendarAuth
     * const googleCalendarAuth = await prisma.googleCalendarAuth.upsert({
     *   create: {
     *     // ... data to create a GoogleCalendarAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoogleCalendarAuth we want to update
     *   }
     * })
     */
    upsert<T extends GoogleCalendarAuthUpsertArgs>(args: SelectSubset<T, GoogleCalendarAuthUpsertArgs<ExtArgs>>): Prisma__GoogleCalendarAuthClient<$Result.GetResult<Prisma.$GoogleCalendarAuthPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GoogleCalendarAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarAuthCountArgs} args - Arguments to filter GoogleCalendarAuths to count.
     * @example
     * // Count the number of GoogleCalendarAuths
     * const count = await prisma.googleCalendarAuth.count({
     *   where: {
     *     // ... the filter for the GoogleCalendarAuths we want to count
     *   }
     * })
    **/
    count<T extends GoogleCalendarAuthCountArgs>(
      args?: Subset<T, GoogleCalendarAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoogleCalendarAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoogleCalendarAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoogleCalendarAuthAggregateArgs>(args: Subset<T, GoogleCalendarAuthAggregateArgs>): Prisma.PrismaPromise<GetGoogleCalendarAuthAggregateType<T>>

    /**
     * Group by GoogleCalendarAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoogleCalendarAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoogleCalendarAuthGroupByArgs['orderBy'] }
        : { orderBy?: GoogleCalendarAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoogleCalendarAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogleCalendarAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoogleCalendarAuth model
   */
  readonly fields: GoogleCalendarAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoogleCalendarAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoogleCalendarAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoogleCalendarAuth model
   */ 
  interface GoogleCalendarAuthFieldRefs {
    readonly id: FieldRef<"GoogleCalendarAuth", 'Int'>
    readonly auth: FieldRef<"GoogleCalendarAuth", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GoogleCalendarAuth findUnique
   */
  export type GoogleCalendarAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarAuth to fetch.
     */
    where: GoogleCalendarAuthWhereUniqueInput
  }

  /**
   * GoogleCalendarAuth findUniqueOrThrow
   */
  export type GoogleCalendarAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarAuth to fetch.
     */
    where: GoogleCalendarAuthWhereUniqueInput
  }

  /**
   * GoogleCalendarAuth findFirst
   */
  export type GoogleCalendarAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarAuth to fetch.
     */
    where?: GoogleCalendarAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleCalendarAuths to fetch.
     */
    orderBy?: GoogleCalendarAuthOrderByWithRelationInput | GoogleCalendarAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleCalendarAuths.
     */
    cursor?: GoogleCalendarAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleCalendarAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleCalendarAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleCalendarAuths.
     */
    distinct?: GoogleCalendarAuthScalarFieldEnum | GoogleCalendarAuthScalarFieldEnum[]
  }

  /**
   * GoogleCalendarAuth findFirstOrThrow
   */
  export type GoogleCalendarAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarAuth to fetch.
     */
    where?: GoogleCalendarAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleCalendarAuths to fetch.
     */
    orderBy?: GoogleCalendarAuthOrderByWithRelationInput | GoogleCalendarAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleCalendarAuths.
     */
    cursor?: GoogleCalendarAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleCalendarAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleCalendarAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleCalendarAuths.
     */
    distinct?: GoogleCalendarAuthScalarFieldEnum | GoogleCalendarAuthScalarFieldEnum[]
  }

  /**
   * GoogleCalendarAuth findMany
   */
  export type GoogleCalendarAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarAuths to fetch.
     */
    where?: GoogleCalendarAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleCalendarAuths to fetch.
     */
    orderBy?: GoogleCalendarAuthOrderByWithRelationInput | GoogleCalendarAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoogleCalendarAuths.
     */
    cursor?: GoogleCalendarAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleCalendarAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleCalendarAuths.
     */
    skip?: number
    distinct?: GoogleCalendarAuthScalarFieldEnum | GoogleCalendarAuthScalarFieldEnum[]
  }

  /**
   * GoogleCalendarAuth create
   */
  export type GoogleCalendarAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * The data needed to create a GoogleCalendarAuth.
     */
    data?: XOR<GoogleCalendarAuthCreateInput, GoogleCalendarAuthUncheckedCreateInput>
  }

  /**
   * GoogleCalendarAuth createMany
   */
  export type GoogleCalendarAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoogleCalendarAuths.
     */
    data: GoogleCalendarAuthCreateManyInput | GoogleCalendarAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoogleCalendarAuth createManyAndReturn
   */
  export type GoogleCalendarAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GoogleCalendarAuths.
     */
    data: GoogleCalendarAuthCreateManyInput | GoogleCalendarAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoogleCalendarAuth update
   */
  export type GoogleCalendarAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * The data needed to update a GoogleCalendarAuth.
     */
    data: XOR<GoogleCalendarAuthUpdateInput, GoogleCalendarAuthUncheckedUpdateInput>
    /**
     * Choose, which GoogleCalendarAuth to update.
     */
    where: GoogleCalendarAuthWhereUniqueInput
  }

  /**
   * GoogleCalendarAuth updateMany
   */
  export type GoogleCalendarAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoogleCalendarAuths.
     */
    data: XOR<GoogleCalendarAuthUpdateManyMutationInput, GoogleCalendarAuthUncheckedUpdateManyInput>
    /**
     * Filter which GoogleCalendarAuths to update
     */
    where?: GoogleCalendarAuthWhereInput
  }

  /**
   * GoogleCalendarAuth upsert
   */
  export type GoogleCalendarAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * The filter to search for the GoogleCalendarAuth to update in case it exists.
     */
    where: GoogleCalendarAuthWhereUniqueInput
    /**
     * In case the GoogleCalendarAuth found by the `where` argument doesn't exist, create a new GoogleCalendarAuth with this data.
     */
    create: XOR<GoogleCalendarAuthCreateInput, GoogleCalendarAuthUncheckedCreateInput>
    /**
     * In case the GoogleCalendarAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoogleCalendarAuthUpdateInput, GoogleCalendarAuthUncheckedUpdateInput>
  }

  /**
   * GoogleCalendarAuth delete
   */
  export type GoogleCalendarAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
    /**
     * Filter which GoogleCalendarAuth to delete.
     */
    where: GoogleCalendarAuthWhereUniqueInput
  }

  /**
   * GoogleCalendarAuth deleteMany
   */
  export type GoogleCalendarAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleCalendarAuths to delete
     */
    where?: GoogleCalendarAuthWhereInput
  }

  /**
   * GoogleCalendarAuth without action
   */
  export type GoogleCalendarAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarAuth
     */
    select?: GoogleCalendarAuthSelect<ExtArgs> | null
  }


  /**
   * Model Snippet
   */

  export type AggregateSnippet = {
    _count: SnippetCountAggregateOutputType | null
    _avg: SnippetAvgAggregateOutputType | null
    _sum: SnippetSumAggregateOutputType | null
    _min: SnippetMinAggregateOutputType | null
    _max: SnippetMaxAggregateOutputType | null
  }

  export type SnippetAvgAggregateOutputType = {
    id: number | null
  }

  export type SnippetSumAggregateOutputType = {
    id: number | null
  }

  export type SnippetMinAggregateOutputType = {
    id: number | null
    content: string | null
    description: string | null
    language: $Enums.Technologies | null
  }

  export type SnippetMaxAggregateOutputType = {
    id: number | null
    content: string | null
    description: string | null
    language: $Enums.Technologies | null
  }

  export type SnippetCountAggregateOutputType = {
    id: number
    content: number
    description: number
    keywords: number
    language: number
    _all: number
  }


  export type SnippetAvgAggregateInputType = {
    id?: true
  }

  export type SnippetSumAggregateInputType = {
    id?: true
  }

  export type SnippetMinAggregateInputType = {
    id?: true
    content?: true
    description?: true
    language?: true
  }

  export type SnippetMaxAggregateInputType = {
    id?: true
    content?: true
    description?: true
    language?: true
  }

  export type SnippetCountAggregateInputType = {
    id?: true
    content?: true
    description?: true
    keywords?: true
    language?: true
    _all?: true
  }

  export type SnippetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snippet to aggregate.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Snippets
    **/
    _count?: true | SnippetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SnippetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SnippetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SnippetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SnippetMaxAggregateInputType
  }

  export type GetSnippetAggregateType<T extends SnippetAggregateArgs> = {
        [P in keyof T & keyof AggregateSnippet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnippet[P]>
      : GetScalarType<T[P], AggregateSnippet[P]>
  }




  export type SnippetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnippetWhereInput
    orderBy?: SnippetOrderByWithAggregationInput | SnippetOrderByWithAggregationInput[]
    by: SnippetScalarFieldEnum[] | SnippetScalarFieldEnum
    having?: SnippetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SnippetCountAggregateInputType | true
    _avg?: SnippetAvgAggregateInputType
    _sum?: SnippetSumAggregateInputType
    _min?: SnippetMinAggregateInputType
    _max?: SnippetMaxAggregateInputType
  }

  export type SnippetGroupByOutputType = {
    id: number
    content: string
    description: string
    keywords: string[]
    language: $Enums.Technologies
    _count: SnippetCountAggregateOutputType | null
    _avg: SnippetAvgAggregateOutputType | null
    _sum: SnippetSumAggregateOutputType | null
    _min: SnippetMinAggregateOutputType | null
    _max: SnippetMaxAggregateOutputType | null
  }

  type GetSnippetGroupByPayload<T extends SnippetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SnippetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SnippetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SnippetGroupByOutputType[P]>
            : GetScalarType<T[P], SnippetGroupByOutputType[P]>
        }
      >
    >


  export type SnippetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    description?: boolean
    keywords?: boolean
    language?: boolean
  }, ExtArgs["result"]["snippet"]>

  export type SnippetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    description?: boolean
    keywords?: boolean
    language?: boolean
  }, ExtArgs["result"]["snippet"]>

  export type SnippetSelectScalar = {
    id?: boolean
    content?: boolean
    description?: boolean
    keywords?: boolean
    language?: boolean
  }


  export type $SnippetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Snippet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      description: string
      keywords: string[]
      language: $Enums.Technologies
    }, ExtArgs["result"]["snippet"]>
    composites: {}
  }

  type SnippetGetPayload<S extends boolean | null | undefined | SnippetDefaultArgs> = $Result.GetResult<Prisma.$SnippetPayload, S>

  type SnippetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SnippetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SnippetCountAggregateInputType | true
    }

  export interface SnippetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Snippet'], meta: { name: 'Snippet' } }
    /**
     * Find zero or one Snippet that matches the filter.
     * @param {SnippetFindUniqueArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SnippetFindUniqueArgs>(args: SelectSubset<T, SnippetFindUniqueArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Snippet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SnippetFindUniqueOrThrowArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SnippetFindUniqueOrThrowArgs>(args: SelectSubset<T, SnippetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Snippet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindFirstArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SnippetFindFirstArgs>(args?: SelectSubset<T, SnippetFindFirstArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Snippet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindFirstOrThrowArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SnippetFindFirstOrThrowArgs>(args?: SelectSubset<T, SnippetFindFirstOrThrowArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Snippets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Snippets
     * const snippets = await prisma.snippet.findMany()
     * 
     * // Get first 10 Snippets
     * const snippets = await prisma.snippet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const snippetWithIdOnly = await prisma.snippet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SnippetFindManyArgs>(args?: SelectSubset<T, SnippetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Snippet.
     * @param {SnippetCreateArgs} args - Arguments to create a Snippet.
     * @example
     * // Create one Snippet
     * const Snippet = await prisma.snippet.create({
     *   data: {
     *     // ... data to create a Snippet
     *   }
     * })
     * 
     */
    create<T extends SnippetCreateArgs>(args: SelectSubset<T, SnippetCreateArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Snippets.
     * @param {SnippetCreateManyArgs} args - Arguments to create many Snippets.
     * @example
     * // Create many Snippets
     * const snippet = await prisma.snippet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SnippetCreateManyArgs>(args?: SelectSubset<T, SnippetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Snippets and returns the data saved in the database.
     * @param {SnippetCreateManyAndReturnArgs} args - Arguments to create many Snippets.
     * @example
     * // Create many Snippets
     * const snippet = await prisma.snippet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Snippets and only return the `id`
     * const snippetWithIdOnly = await prisma.snippet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SnippetCreateManyAndReturnArgs>(args?: SelectSubset<T, SnippetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Snippet.
     * @param {SnippetDeleteArgs} args - Arguments to delete one Snippet.
     * @example
     * // Delete one Snippet
     * const Snippet = await prisma.snippet.delete({
     *   where: {
     *     // ... filter to delete one Snippet
     *   }
     * })
     * 
     */
    delete<T extends SnippetDeleteArgs>(args: SelectSubset<T, SnippetDeleteArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Snippet.
     * @param {SnippetUpdateArgs} args - Arguments to update one Snippet.
     * @example
     * // Update one Snippet
     * const snippet = await prisma.snippet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SnippetUpdateArgs>(args: SelectSubset<T, SnippetUpdateArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Snippets.
     * @param {SnippetDeleteManyArgs} args - Arguments to filter Snippets to delete.
     * @example
     * // Delete a few Snippets
     * const { count } = await prisma.snippet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SnippetDeleteManyArgs>(args?: SelectSubset<T, SnippetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snippets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Snippets
     * const snippet = await prisma.snippet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SnippetUpdateManyArgs>(args: SelectSubset<T, SnippetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Snippet.
     * @param {SnippetUpsertArgs} args - Arguments to update or create a Snippet.
     * @example
     * // Update or create a Snippet
     * const snippet = await prisma.snippet.upsert({
     *   create: {
     *     // ... data to create a Snippet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Snippet we want to update
     *   }
     * })
     */
    upsert<T extends SnippetUpsertArgs>(args: SelectSubset<T, SnippetUpsertArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Snippets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetCountArgs} args - Arguments to filter Snippets to count.
     * @example
     * // Count the number of Snippets
     * const count = await prisma.snippet.count({
     *   where: {
     *     // ... the filter for the Snippets we want to count
     *   }
     * })
    **/
    count<T extends SnippetCountArgs>(
      args?: Subset<T, SnippetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SnippetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Snippet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SnippetAggregateArgs>(args: Subset<T, SnippetAggregateArgs>): Prisma.PrismaPromise<GetSnippetAggregateType<T>>

    /**
     * Group by Snippet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SnippetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SnippetGroupByArgs['orderBy'] }
        : { orderBy?: SnippetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SnippetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnippetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Snippet model
   */
  readonly fields: SnippetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Snippet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SnippetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Snippet model
   */ 
  interface SnippetFieldRefs {
    readonly id: FieldRef<"Snippet", 'Int'>
    readonly content: FieldRef<"Snippet", 'String'>
    readonly description: FieldRef<"Snippet", 'String'>
    readonly keywords: FieldRef<"Snippet", 'String[]'>
    readonly language: FieldRef<"Snippet", 'Technologies'>
  }
    

  // Custom InputTypes
  /**
   * Snippet findUnique
   */
  export type SnippetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet findUniqueOrThrow
   */
  export type SnippetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet findFirst
   */
  export type SnippetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snippets.
     */
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet findFirstOrThrow
   */
  export type SnippetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snippets.
     */
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet findMany
   */
  export type SnippetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Filter, which Snippets to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet create
   */
  export type SnippetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * The data needed to create a Snippet.
     */
    data: XOR<SnippetCreateInput, SnippetUncheckedCreateInput>
  }

  /**
   * Snippet createMany
   */
  export type SnippetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Snippets.
     */
    data: SnippetCreateManyInput | SnippetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Snippet createManyAndReturn
   */
  export type SnippetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Snippets.
     */
    data: SnippetCreateManyInput | SnippetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Snippet update
   */
  export type SnippetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * The data needed to update a Snippet.
     */
    data: XOR<SnippetUpdateInput, SnippetUncheckedUpdateInput>
    /**
     * Choose, which Snippet to update.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet updateMany
   */
  export type SnippetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Snippets.
     */
    data: XOR<SnippetUpdateManyMutationInput, SnippetUncheckedUpdateManyInput>
    /**
     * Filter which Snippets to update
     */
    where?: SnippetWhereInput
  }

  /**
   * Snippet upsert
   */
  export type SnippetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * The filter to search for the Snippet to update in case it exists.
     */
    where: SnippetWhereUniqueInput
    /**
     * In case the Snippet found by the `where` argument doesn't exist, create a new Snippet with this data.
     */
    create: XOR<SnippetCreateInput, SnippetUncheckedCreateInput>
    /**
     * In case the Snippet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SnippetUpdateInput, SnippetUncheckedUpdateInput>
  }

  /**
   * Snippet delete
   */
  export type SnippetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Filter which Snippet to delete.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet deleteMany
   */
  export type SnippetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snippets to delete
     */
    where?: SnippetWhereInput
  }

  /**
   * Snippet without action
   */
  export type SnippetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
  }


  /**
   * Model RelatedValues
   */

  export type AggregateRelatedValues = {
    _count: RelatedValuesCountAggregateOutputType | null
    _avg: RelatedValuesAvgAggregateOutputType | null
    _sum: RelatedValuesSumAggregateOutputType | null
    _min: RelatedValuesMinAggregateOutputType | null
    _max: RelatedValuesMaxAggregateOutputType | null
  }

  export type RelatedValuesAvgAggregateOutputType = {
    id: number | null
    output: number | null
    equationId: number | null
  }

  export type RelatedValuesSumAggregateOutputType = {
    id: number | null
    output: number | null
    equationId: number[]
  }

  export type RelatedValuesMinAggregateOutputType = {
    id: number | null
    output: number | null
  }

  export type RelatedValuesMaxAggregateOutputType = {
    id: number | null
    output: number | null
  }

  export type RelatedValuesCountAggregateOutputType = {
    id: number
    input: number
    output: number
    equationId: number
    _all: number
  }


  export type RelatedValuesAvgAggregateInputType = {
    id?: true
    output?: true
    equationId?: true
  }

  export type RelatedValuesSumAggregateInputType = {
    id?: true
    output?: true
    equationId?: true
  }

  export type RelatedValuesMinAggregateInputType = {
    id?: true
    output?: true
  }

  export type RelatedValuesMaxAggregateInputType = {
    id?: true
    output?: true
  }

  export type RelatedValuesCountAggregateInputType = {
    id?: true
    input?: true
    output?: true
    equationId?: true
    _all?: true
  }

  export type RelatedValuesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelatedValues to aggregate.
     */
    where?: RelatedValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedValues to fetch.
     */
    orderBy?: RelatedValuesOrderByWithRelationInput | RelatedValuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelatedValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelatedValues
    **/
    _count?: true | RelatedValuesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelatedValuesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelatedValuesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelatedValuesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelatedValuesMaxAggregateInputType
  }

  export type GetRelatedValuesAggregateType<T extends RelatedValuesAggregateArgs> = {
        [P in keyof T & keyof AggregateRelatedValues]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelatedValues[P]>
      : GetScalarType<T[P], AggregateRelatedValues[P]>
  }




  export type RelatedValuesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedValuesWhereInput
    orderBy?: RelatedValuesOrderByWithAggregationInput | RelatedValuesOrderByWithAggregationInput[]
    by: RelatedValuesScalarFieldEnum[] | RelatedValuesScalarFieldEnum
    having?: RelatedValuesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelatedValuesCountAggregateInputType | true
    _avg?: RelatedValuesAvgAggregateInputType
    _sum?: RelatedValuesSumAggregateInputType
    _min?: RelatedValuesMinAggregateInputType
    _max?: RelatedValuesMaxAggregateInputType
  }

  export type RelatedValuesGroupByOutputType = {
    id: number
    input: JsonValue
    output: number
    equationId: number[]
    _count: RelatedValuesCountAggregateOutputType | null
    _avg: RelatedValuesAvgAggregateOutputType | null
    _sum: RelatedValuesSumAggregateOutputType | null
    _min: RelatedValuesMinAggregateOutputType | null
    _max: RelatedValuesMaxAggregateOutputType | null
  }

  type GetRelatedValuesGroupByPayload<T extends RelatedValuesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelatedValuesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelatedValuesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelatedValuesGroupByOutputType[P]>
            : GetScalarType<T[P], RelatedValuesGroupByOutputType[P]>
        }
      >
    >


  export type RelatedValuesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    input?: boolean
    output?: boolean
    equationId?: boolean
    equations?: boolean | RelatedValues$equationsArgs<ExtArgs>
    _count?: boolean | RelatedValuesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedValues"]>

  export type RelatedValuesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    input?: boolean
    output?: boolean
    equationId?: boolean
  }, ExtArgs["result"]["relatedValues"]>

  export type RelatedValuesSelectScalar = {
    id?: boolean
    input?: boolean
    output?: boolean
    equationId?: boolean
  }

  export type RelatedValuesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equations?: boolean | RelatedValues$equationsArgs<ExtArgs>
    _count?: boolean | RelatedValuesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RelatedValuesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RelatedValuesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelatedValues"
    objects: {
      equations: Prisma.$EquationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      input: Prisma.JsonValue
      output: number
      equationId: number[]
    }, ExtArgs["result"]["relatedValues"]>
    composites: {}
  }

  type RelatedValuesGetPayload<S extends boolean | null | undefined | RelatedValuesDefaultArgs> = $Result.GetResult<Prisma.$RelatedValuesPayload, S>

  type RelatedValuesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelatedValuesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelatedValuesCountAggregateInputType | true
    }

  export interface RelatedValuesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelatedValues'], meta: { name: 'RelatedValues' } }
    /**
     * Find zero or one RelatedValues that matches the filter.
     * @param {RelatedValuesFindUniqueArgs} args - Arguments to find a RelatedValues
     * @example
     * // Get one RelatedValues
     * const relatedValues = await prisma.relatedValues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelatedValuesFindUniqueArgs>(args: SelectSubset<T, RelatedValuesFindUniqueArgs<ExtArgs>>): Prisma__RelatedValuesClient<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RelatedValues that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RelatedValuesFindUniqueOrThrowArgs} args - Arguments to find a RelatedValues
     * @example
     * // Get one RelatedValues
     * const relatedValues = await prisma.relatedValues.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelatedValuesFindUniqueOrThrowArgs>(args: SelectSubset<T, RelatedValuesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelatedValuesClient<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RelatedValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedValuesFindFirstArgs} args - Arguments to find a RelatedValues
     * @example
     * // Get one RelatedValues
     * const relatedValues = await prisma.relatedValues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelatedValuesFindFirstArgs>(args?: SelectSubset<T, RelatedValuesFindFirstArgs<ExtArgs>>): Prisma__RelatedValuesClient<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RelatedValues that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedValuesFindFirstOrThrowArgs} args - Arguments to find a RelatedValues
     * @example
     * // Get one RelatedValues
     * const relatedValues = await prisma.relatedValues.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelatedValuesFindFirstOrThrowArgs>(args?: SelectSubset<T, RelatedValuesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelatedValuesClient<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RelatedValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedValuesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelatedValues
     * const relatedValues = await prisma.relatedValues.findMany()
     * 
     * // Get first 10 RelatedValues
     * const relatedValues = await prisma.relatedValues.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relatedValuesWithIdOnly = await prisma.relatedValues.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelatedValuesFindManyArgs>(args?: SelectSubset<T, RelatedValuesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RelatedValues.
     * @param {RelatedValuesCreateArgs} args - Arguments to create a RelatedValues.
     * @example
     * // Create one RelatedValues
     * const RelatedValues = await prisma.relatedValues.create({
     *   data: {
     *     // ... data to create a RelatedValues
     *   }
     * })
     * 
     */
    create<T extends RelatedValuesCreateArgs>(args: SelectSubset<T, RelatedValuesCreateArgs<ExtArgs>>): Prisma__RelatedValuesClient<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RelatedValues.
     * @param {RelatedValuesCreateManyArgs} args - Arguments to create many RelatedValues.
     * @example
     * // Create many RelatedValues
     * const relatedValues = await prisma.relatedValues.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelatedValuesCreateManyArgs>(args?: SelectSubset<T, RelatedValuesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelatedValues and returns the data saved in the database.
     * @param {RelatedValuesCreateManyAndReturnArgs} args - Arguments to create many RelatedValues.
     * @example
     * // Create many RelatedValues
     * const relatedValues = await prisma.relatedValues.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelatedValues and only return the `id`
     * const relatedValuesWithIdOnly = await prisma.relatedValues.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelatedValuesCreateManyAndReturnArgs>(args?: SelectSubset<T, RelatedValuesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RelatedValues.
     * @param {RelatedValuesDeleteArgs} args - Arguments to delete one RelatedValues.
     * @example
     * // Delete one RelatedValues
     * const RelatedValues = await prisma.relatedValues.delete({
     *   where: {
     *     // ... filter to delete one RelatedValues
     *   }
     * })
     * 
     */
    delete<T extends RelatedValuesDeleteArgs>(args: SelectSubset<T, RelatedValuesDeleteArgs<ExtArgs>>): Prisma__RelatedValuesClient<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RelatedValues.
     * @param {RelatedValuesUpdateArgs} args - Arguments to update one RelatedValues.
     * @example
     * // Update one RelatedValues
     * const relatedValues = await prisma.relatedValues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelatedValuesUpdateArgs>(args: SelectSubset<T, RelatedValuesUpdateArgs<ExtArgs>>): Prisma__RelatedValuesClient<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RelatedValues.
     * @param {RelatedValuesDeleteManyArgs} args - Arguments to filter RelatedValues to delete.
     * @example
     * // Delete a few RelatedValues
     * const { count } = await prisma.relatedValues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelatedValuesDeleteManyArgs>(args?: SelectSubset<T, RelatedValuesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelatedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedValuesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelatedValues
     * const relatedValues = await prisma.relatedValues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelatedValuesUpdateManyArgs>(args: SelectSubset<T, RelatedValuesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RelatedValues.
     * @param {RelatedValuesUpsertArgs} args - Arguments to update or create a RelatedValues.
     * @example
     * // Update or create a RelatedValues
     * const relatedValues = await prisma.relatedValues.upsert({
     *   create: {
     *     // ... data to create a RelatedValues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelatedValues we want to update
     *   }
     * })
     */
    upsert<T extends RelatedValuesUpsertArgs>(args: SelectSubset<T, RelatedValuesUpsertArgs<ExtArgs>>): Prisma__RelatedValuesClient<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RelatedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedValuesCountArgs} args - Arguments to filter RelatedValues to count.
     * @example
     * // Count the number of RelatedValues
     * const count = await prisma.relatedValues.count({
     *   where: {
     *     // ... the filter for the RelatedValues we want to count
     *   }
     * })
    **/
    count<T extends RelatedValuesCountArgs>(
      args?: Subset<T, RelatedValuesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelatedValuesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelatedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedValuesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelatedValuesAggregateArgs>(args: Subset<T, RelatedValuesAggregateArgs>): Prisma.PrismaPromise<GetRelatedValuesAggregateType<T>>

    /**
     * Group by RelatedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedValuesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelatedValuesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelatedValuesGroupByArgs['orderBy'] }
        : { orderBy?: RelatedValuesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelatedValuesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelatedValuesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelatedValues model
   */
  readonly fields: RelatedValuesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelatedValues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelatedValuesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equations<T extends RelatedValues$equationsArgs<ExtArgs> = {}>(args?: Subset<T, RelatedValues$equationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelatedValues model
   */ 
  interface RelatedValuesFieldRefs {
    readonly id: FieldRef<"RelatedValues", 'Int'>
    readonly input: FieldRef<"RelatedValues", 'Json'>
    readonly output: FieldRef<"RelatedValues", 'Float'>
    readonly equationId: FieldRef<"RelatedValues", 'Int[]'>
  }
    

  // Custom InputTypes
  /**
   * RelatedValues findUnique
   */
  export type RelatedValuesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * Filter, which RelatedValues to fetch.
     */
    where: RelatedValuesWhereUniqueInput
  }

  /**
   * RelatedValues findUniqueOrThrow
   */
  export type RelatedValuesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * Filter, which RelatedValues to fetch.
     */
    where: RelatedValuesWhereUniqueInput
  }

  /**
   * RelatedValues findFirst
   */
  export type RelatedValuesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * Filter, which RelatedValues to fetch.
     */
    where?: RelatedValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedValues to fetch.
     */
    orderBy?: RelatedValuesOrderByWithRelationInput | RelatedValuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedValues.
     */
    cursor?: RelatedValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedValues.
     */
    distinct?: RelatedValuesScalarFieldEnum | RelatedValuesScalarFieldEnum[]
  }

  /**
   * RelatedValues findFirstOrThrow
   */
  export type RelatedValuesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * Filter, which RelatedValues to fetch.
     */
    where?: RelatedValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedValues to fetch.
     */
    orderBy?: RelatedValuesOrderByWithRelationInput | RelatedValuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedValues.
     */
    cursor?: RelatedValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedValues.
     */
    distinct?: RelatedValuesScalarFieldEnum | RelatedValuesScalarFieldEnum[]
  }

  /**
   * RelatedValues findMany
   */
  export type RelatedValuesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * Filter, which RelatedValues to fetch.
     */
    where?: RelatedValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedValues to fetch.
     */
    orderBy?: RelatedValuesOrderByWithRelationInput | RelatedValuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelatedValues.
     */
    cursor?: RelatedValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedValues.
     */
    skip?: number
    distinct?: RelatedValuesScalarFieldEnum | RelatedValuesScalarFieldEnum[]
  }

  /**
   * RelatedValues create
   */
  export type RelatedValuesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * The data needed to create a RelatedValues.
     */
    data: XOR<RelatedValuesCreateInput, RelatedValuesUncheckedCreateInput>
  }

  /**
   * RelatedValues createMany
   */
  export type RelatedValuesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelatedValues.
     */
    data: RelatedValuesCreateManyInput | RelatedValuesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelatedValues createManyAndReturn
   */
  export type RelatedValuesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RelatedValues.
     */
    data: RelatedValuesCreateManyInput | RelatedValuesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelatedValues update
   */
  export type RelatedValuesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * The data needed to update a RelatedValues.
     */
    data: XOR<RelatedValuesUpdateInput, RelatedValuesUncheckedUpdateInput>
    /**
     * Choose, which RelatedValues to update.
     */
    where: RelatedValuesWhereUniqueInput
  }

  /**
   * RelatedValues updateMany
   */
  export type RelatedValuesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelatedValues.
     */
    data: XOR<RelatedValuesUpdateManyMutationInput, RelatedValuesUncheckedUpdateManyInput>
    /**
     * Filter which RelatedValues to update
     */
    where?: RelatedValuesWhereInput
  }

  /**
   * RelatedValues upsert
   */
  export type RelatedValuesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * The filter to search for the RelatedValues to update in case it exists.
     */
    where: RelatedValuesWhereUniqueInput
    /**
     * In case the RelatedValues found by the `where` argument doesn't exist, create a new RelatedValues with this data.
     */
    create: XOR<RelatedValuesCreateInput, RelatedValuesUncheckedCreateInput>
    /**
     * In case the RelatedValues was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelatedValuesUpdateInput, RelatedValuesUncheckedUpdateInput>
  }

  /**
   * RelatedValues delete
   */
  export type RelatedValuesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    /**
     * Filter which RelatedValues to delete.
     */
    where: RelatedValuesWhereUniqueInput
  }

  /**
   * RelatedValues deleteMany
   */
  export type RelatedValuesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelatedValues to delete
     */
    where?: RelatedValuesWhereInput
  }

  /**
   * RelatedValues.equations
   */
  export type RelatedValues$equationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    where?: EquationWhereInput
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    cursor?: EquationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquationScalarFieldEnum | EquationScalarFieldEnum[]
  }

  /**
   * RelatedValues without action
   */
  export type RelatedValuesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
  }


  /**
   * Model Equation
   */

  export type AggregateEquation = {
    _count: EquationCountAggregateOutputType | null
    _avg: EquationAvgAggregateOutputType | null
    _sum: EquationSumAggregateOutputType | null
    _min: EquationMinAggregateOutputType | null
    _max: EquationMaxAggregateOutputType | null
  }

  export type EquationAvgAggregateOutputType = {
    id: number | null
  }

  export type EquationSumAggregateOutputType = {
    id: number | null
  }

  export type EquationMinAggregateOutputType = {
    id: number | null
    equationId: string | null
    title: string | null
    desc: string | null
    content: string | null
    asPython: string | null
    createdAt: Date | null
  }

  export type EquationMaxAggregateOutputType = {
    id: number | null
    equationId: string | null
    title: string | null
    desc: string | null
    content: string | null
    asPython: string | null
    createdAt: Date | null
  }

  export type EquationCountAggregateOutputType = {
    id: number
    equationId: number
    title: number
    desc: number
    content: number
    asPython: number
    variableLegend: number
    variables: number
    keywords: number
    createdAt: number
    _all: number
  }


  export type EquationAvgAggregateInputType = {
    id?: true
  }

  export type EquationSumAggregateInputType = {
    id?: true
  }

  export type EquationMinAggregateInputType = {
    id?: true
    equationId?: true
    title?: true
    desc?: true
    content?: true
    asPython?: true
    createdAt?: true
  }

  export type EquationMaxAggregateInputType = {
    id?: true
    equationId?: true
    title?: true
    desc?: true
    content?: true
    asPython?: true
    createdAt?: true
  }

  export type EquationCountAggregateInputType = {
    id?: true
    equationId?: true
    title?: true
    desc?: true
    content?: true
    asPython?: true
    variableLegend?: true
    variables?: true
    keywords?: true
    createdAt?: true
    _all?: true
  }

  export type EquationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equation to aggregate.
     */
    where?: EquationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equations to fetch.
     */
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equations
    **/
    _count?: true | EquationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquationMaxAggregateInputType
  }

  export type GetEquationAggregateType<T extends EquationAggregateArgs> = {
        [P in keyof T & keyof AggregateEquation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquation[P]>
      : GetScalarType<T[P], AggregateEquation[P]>
  }




  export type EquationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquationWhereInput
    orderBy?: EquationOrderByWithAggregationInput | EquationOrderByWithAggregationInput[]
    by: EquationScalarFieldEnum[] | EquationScalarFieldEnum
    having?: EquationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquationCountAggregateInputType | true
    _avg?: EquationAvgAggregateInputType
    _sum?: EquationSumAggregateInputType
    _min?: EquationMinAggregateInputType
    _max?: EquationMaxAggregateInputType
  }

  export type EquationGroupByOutputType = {
    id: number
    equationId: string | null
    title: string
    desc: string | null
    content: string
    asPython: string | null
    variableLegend: JsonValue | null
    variables: string[]
    keywords: string[]
    createdAt: Date
    _count: EquationCountAggregateOutputType | null
    _avg: EquationAvgAggregateOutputType | null
    _sum: EquationSumAggregateOutputType | null
    _min: EquationMinAggregateOutputType | null
    _max: EquationMaxAggregateOutputType | null
  }

  type GetEquationGroupByPayload<T extends EquationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquationGroupByOutputType[P]>
            : GetScalarType<T[P], EquationGroupByOutputType[P]>
        }
      >
    >


  export type EquationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equationId?: boolean
    title?: boolean
    desc?: boolean
    content?: boolean
    asPython?: boolean
    variableLegend?: boolean
    variables?: boolean
    keywords?: boolean
    createdAt?: boolean
    relatedValues?: boolean | Equation$relatedValuesArgs<ExtArgs>
    tags?: boolean | Equation$tagsArgs<ExtArgs>
    topics?: boolean | Equation$topicsArgs<ExtArgs>
    subjects?: boolean | Equation$subjectsArgs<ExtArgs>
    mdxNotes?: boolean | Equation$mdxNotesArgs<ExtArgs>
    _count?: boolean | EquationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equation"]>

  export type EquationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equationId?: boolean
    title?: boolean
    desc?: boolean
    content?: boolean
    asPython?: boolean
    variableLegend?: boolean
    variables?: boolean
    keywords?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["equation"]>

  export type EquationSelectScalar = {
    id?: boolean
    equationId?: boolean
    title?: boolean
    desc?: boolean
    content?: boolean
    asPython?: boolean
    variableLegend?: boolean
    variables?: boolean
    keywords?: boolean
    createdAt?: boolean
  }

  export type EquationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedValues?: boolean | Equation$relatedValuesArgs<ExtArgs>
    tags?: boolean | Equation$tagsArgs<ExtArgs>
    topics?: boolean | Equation$topicsArgs<ExtArgs>
    subjects?: boolean | Equation$subjectsArgs<ExtArgs>
    mdxNotes?: boolean | Equation$mdxNotesArgs<ExtArgs>
    _count?: boolean | EquationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equation"
    objects: {
      relatedValues: Prisma.$RelatedValuesPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      mdxNotes: Prisma.$MdxNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      equationId: string | null
      title: string
      desc: string | null
      content: string
      asPython: string | null
      variableLegend: Prisma.JsonValue | null
      variables: string[]
      keywords: string[]
      createdAt: Date
    }, ExtArgs["result"]["equation"]>
    composites: {}
  }

  type EquationGetPayload<S extends boolean | null | undefined | EquationDefaultArgs> = $Result.GetResult<Prisma.$EquationPayload, S>

  type EquationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquationCountAggregateInputType | true
    }

  export interface EquationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equation'], meta: { name: 'Equation' } }
    /**
     * Find zero or one Equation that matches the filter.
     * @param {EquationFindUniqueArgs} args - Arguments to find a Equation
     * @example
     * // Get one Equation
     * const equation = await prisma.equation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquationFindUniqueArgs>(args: SelectSubset<T, EquationFindUniqueArgs<ExtArgs>>): Prisma__EquationClient<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Equation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EquationFindUniqueOrThrowArgs} args - Arguments to find a Equation
     * @example
     * // Get one Equation
     * const equation = await prisma.equation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquationFindUniqueOrThrowArgs>(args: SelectSubset<T, EquationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquationClient<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Equation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquationFindFirstArgs} args - Arguments to find a Equation
     * @example
     * // Get one Equation
     * const equation = await prisma.equation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquationFindFirstArgs>(args?: SelectSubset<T, EquationFindFirstArgs<ExtArgs>>): Prisma__EquationClient<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Equation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquationFindFirstOrThrowArgs} args - Arguments to find a Equation
     * @example
     * // Get one Equation
     * const equation = await prisma.equation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquationFindFirstOrThrowArgs>(args?: SelectSubset<T, EquationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquationClient<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Equations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equations
     * const equations = await prisma.equation.findMany()
     * 
     * // Get first 10 Equations
     * const equations = await prisma.equation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equationWithIdOnly = await prisma.equation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquationFindManyArgs>(args?: SelectSubset<T, EquationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Equation.
     * @param {EquationCreateArgs} args - Arguments to create a Equation.
     * @example
     * // Create one Equation
     * const Equation = await prisma.equation.create({
     *   data: {
     *     // ... data to create a Equation
     *   }
     * })
     * 
     */
    create<T extends EquationCreateArgs>(args: SelectSubset<T, EquationCreateArgs<ExtArgs>>): Prisma__EquationClient<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Equations.
     * @param {EquationCreateManyArgs} args - Arguments to create many Equations.
     * @example
     * // Create many Equations
     * const equation = await prisma.equation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquationCreateManyArgs>(args?: SelectSubset<T, EquationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equations and returns the data saved in the database.
     * @param {EquationCreateManyAndReturnArgs} args - Arguments to create many Equations.
     * @example
     * // Create many Equations
     * const equation = await prisma.equation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equations and only return the `id`
     * const equationWithIdOnly = await prisma.equation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquationCreateManyAndReturnArgs>(args?: SelectSubset<T, EquationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Equation.
     * @param {EquationDeleteArgs} args - Arguments to delete one Equation.
     * @example
     * // Delete one Equation
     * const Equation = await prisma.equation.delete({
     *   where: {
     *     // ... filter to delete one Equation
     *   }
     * })
     * 
     */
    delete<T extends EquationDeleteArgs>(args: SelectSubset<T, EquationDeleteArgs<ExtArgs>>): Prisma__EquationClient<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Equation.
     * @param {EquationUpdateArgs} args - Arguments to update one Equation.
     * @example
     * // Update one Equation
     * const equation = await prisma.equation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquationUpdateArgs>(args: SelectSubset<T, EquationUpdateArgs<ExtArgs>>): Prisma__EquationClient<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Equations.
     * @param {EquationDeleteManyArgs} args - Arguments to filter Equations to delete.
     * @example
     * // Delete a few Equations
     * const { count } = await prisma.equation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquationDeleteManyArgs>(args?: SelectSubset<T, EquationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equations
     * const equation = await prisma.equation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquationUpdateManyArgs>(args: SelectSubset<T, EquationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equation.
     * @param {EquationUpsertArgs} args - Arguments to update or create a Equation.
     * @example
     * // Update or create a Equation
     * const equation = await prisma.equation.upsert({
     *   create: {
     *     // ... data to create a Equation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equation we want to update
     *   }
     * })
     */
    upsert<T extends EquationUpsertArgs>(args: SelectSubset<T, EquationUpsertArgs<ExtArgs>>): Prisma__EquationClient<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Equations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquationCountArgs} args - Arguments to filter Equations to count.
     * @example
     * // Count the number of Equations
     * const count = await prisma.equation.count({
     *   where: {
     *     // ... the filter for the Equations we want to count
     *   }
     * })
    **/
    count<T extends EquationCountArgs>(
      args?: Subset<T, EquationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquationAggregateArgs>(args: Subset<T, EquationAggregateArgs>): Prisma.PrismaPromise<GetEquationAggregateType<T>>

    /**
     * Group by Equation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquationGroupByArgs['orderBy'] }
        : { orderBy?: EquationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equation model
   */
  readonly fields: EquationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relatedValues<T extends Equation$relatedValuesArgs<ExtArgs> = {}>(args?: Subset<T, Equation$relatedValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedValuesPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends Equation$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Equation$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    topics<T extends Equation$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Equation$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends Equation$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Equation$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    mdxNotes<T extends Equation$mdxNotesArgs<ExtArgs> = {}>(args?: Subset<T, Equation$mdxNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equation model
   */ 
  interface EquationFieldRefs {
    readonly id: FieldRef<"Equation", 'Int'>
    readonly equationId: FieldRef<"Equation", 'String'>
    readonly title: FieldRef<"Equation", 'String'>
    readonly desc: FieldRef<"Equation", 'String'>
    readonly content: FieldRef<"Equation", 'String'>
    readonly asPython: FieldRef<"Equation", 'String'>
    readonly variableLegend: FieldRef<"Equation", 'Json'>
    readonly variables: FieldRef<"Equation", 'String[]'>
    readonly keywords: FieldRef<"Equation", 'String[]'>
    readonly createdAt: FieldRef<"Equation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equation findUnique
   */
  export type EquationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * Filter, which Equation to fetch.
     */
    where: EquationWhereUniqueInput
  }

  /**
   * Equation findUniqueOrThrow
   */
  export type EquationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * Filter, which Equation to fetch.
     */
    where: EquationWhereUniqueInput
  }

  /**
   * Equation findFirst
   */
  export type EquationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * Filter, which Equation to fetch.
     */
    where?: EquationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equations to fetch.
     */
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equations.
     */
    cursor?: EquationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equations.
     */
    distinct?: EquationScalarFieldEnum | EquationScalarFieldEnum[]
  }

  /**
   * Equation findFirstOrThrow
   */
  export type EquationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * Filter, which Equation to fetch.
     */
    where?: EquationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equations to fetch.
     */
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equations.
     */
    cursor?: EquationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equations.
     */
    distinct?: EquationScalarFieldEnum | EquationScalarFieldEnum[]
  }

  /**
   * Equation findMany
   */
  export type EquationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * Filter, which Equations to fetch.
     */
    where?: EquationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equations to fetch.
     */
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equations.
     */
    cursor?: EquationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equations.
     */
    skip?: number
    distinct?: EquationScalarFieldEnum | EquationScalarFieldEnum[]
  }

  /**
   * Equation create
   */
  export type EquationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * The data needed to create a Equation.
     */
    data: XOR<EquationCreateInput, EquationUncheckedCreateInput>
  }

  /**
   * Equation createMany
   */
  export type EquationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equations.
     */
    data: EquationCreateManyInput | EquationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equation createManyAndReturn
   */
  export type EquationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Equations.
     */
    data: EquationCreateManyInput | EquationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equation update
   */
  export type EquationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * The data needed to update a Equation.
     */
    data: XOR<EquationUpdateInput, EquationUncheckedUpdateInput>
    /**
     * Choose, which Equation to update.
     */
    where: EquationWhereUniqueInput
  }

  /**
   * Equation updateMany
   */
  export type EquationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equations.
     */
    data: XOR<EquationUpdateManyMutationInput, EquationUncheckedUpdateManyInput>
    /**
     * Filter which Equations to update
     */
    where?: EquationWhereInput
  }

  /**
   * Equation upsert
   */
  export type EquationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * The filter to search for the Equation to update in case it exists.
     */
    where: EquationWhereUniqueInput
    /**
     * In case the Equation found by the `where` argument doesn't exist, create a new Equation with this data.
     */
    create: XOR<EquationCreateInput, EquationUncheckedCreateInput>
    /**
     * In case the Equation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquationUpdateInput, EquationUncheckedUpdateInput>
  }

  /**
   * Equation delete
   */
  export type EquationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    /**
     * Filter which Equation to delete.
     */
    where: EquationWhereUniqueInput
  }

  /**
   * Equation deleteMany
   */
  export type EquationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equations to delete
     */
    where?: EquationWhereInput
  }

  /**
   * Equation.relatedValues
   */
  export type Equation$relatedValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedValues
     */
    select?: RelatedValuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedValuesInclude<ExtArgs> | null
    where?: RelatedValuesWhereInput
    orderBy?: RelatedValuesOrderByWithRelationInput | RelatedValuesOrderByWithRelationInput[]
    cursor?: RelatedValuesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelatedValuesScalarFieldEnum | RelatedValuesScalarFieldEnum[]
  }

  /**
   * Equation.tags
   */
  export type Equation$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Equation.topics
   */
  export type Equation$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Equation.subjects
   */
  export type Equation$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Equation.mdxNotes
   */
  export type Equation$mdxNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    cursor?: MdxNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * Equation without action
   */
  export type EquationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
  }


  /**
   * Model Definition
   */

  export type AggregateDefinition = {
    _count: DefinitionCountAggregateOutputType | null
    _avg: DefinitionAvgAggregateOutputType | null
    _sum: DefinitionSumAggregateOutputType | null
    _min: DefinitionMinAggregateOutputType | null
    _max: DefinitionMaxAggregateOutputType | null
  }

  export type DefinitionAvgAggregateOutputType = {
    mdxNoteId: number | null
  }

  export type DefinitionSumAggregateOutputType = {
    mdxNoteId: number | null
  }

  export type DefinitionMinAggregateOutputType = {
    id: string | null
    label: string | null
    content: string | null
    alphabeticalLabel: string | null
    mdxNoteId: number | null
  }

  export type DefinitionMaxAggregateOutputType = {
    id: string | null
    label: string | null
    content: string | null
    alphabeticalLabel: string | null
    mdxNoteId: number | null
  }

  export type DefinitionCountAggregateOutputType = {
    id: number
    label: number
    content: number
    alphabeticalLabel: number
    mdxNoteId: number
    _all: number
  }


  export type DefinitionAvgAggregateInputType = {
    mdxNoteId?: true
  }

  export type DefinitionSumAggregateInputType = {
    mdxNoteId?: true
  }

  export type DefinitionMinAggregateInputType = {
    id?: true
    label?: true
    content?: true
    alphabeticalLabel?: true
    mdxNoteId?: true
  }

  export type DefinitionMaxAggregateInputType = {
    id?: true
    label?: true
    content?: true
    alphabeticalLabel?: true
    mdxNoteId?: true
  }

  export type DefinitionCountAggregateInputType = {
    id?: true
    label?: true
    content?: true
    alphabeticalLabel?: true
    mdxNoteId?: true
    _all?: true
  }

  export type DefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Definition to aggregate.
     */
    where?: DefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Definitions to fetch.
     */
    orderBy?: DefinitionOrderByWithRelationInput | DefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Definitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Definitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Definitions
    **/
    _count?: true | DefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefinitionMaxAggregateInputType
  }

  export type GetDefinitionAggregateType<T extends DefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefinition[P]>
      : GetScalarType<T[P], AggregateDefinition[P]>
  }




  export type DefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefinitionWhereInput
    orderBy?: DefinitionOrderByWithAggregationInput | DefinitionOrderByWithAggregationInput[]
    by: DefinitionScalarFieldEnum[] | DefinitionScalarFieldEnum
    having?: DefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefinitionCountAggregateInputType | true
    _avg?: DefinitionAvgAggregateInputType
    _sum?: DefinitionSumAggregateInputType
    _min?: DefinitionMinAggregateInputType
    _max?: DefinitionMaxAggregateInputType
  }

  export type DefinitionGroupByOutputType = {
    id: string
    label: string | null
    content: string | null
    alphabeticalLabel: string | null
    mdxNoteId: number | null
    _count: DefinitionCountAggregateOutputType | null
    _avg: DefinitionAvgAggregateOutputType | null
    _sum: DefinitionSumAggregateOutputType | null
    _min: DefinitionMinAggregateOutputType | null
    _max: DefinitionMaxAggregateOutputType | null
  }

  type GetDefinitionGroupByPayload<T extends DefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], DefinitionGroupByOutputType[P]>
        }
      >
    >


  export type DefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    content?: boolean
    alphabeticalLabel?: boolean
    mdxNoteId?: boolean
    mdxNote?: boolean | Definition$mdxNoteArgs<ExtArgs>
  }, ExtArgs["result"]["definition"]>

  export type DefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    content?: boolean
    alphabeticalLabel?: boolean
    mdxNoteId?: boolean
    mdxNote?: boolean | Definition$mdxNoteArgs<ExtArgs>
  }, ExtArgs["result"]["definition"]>

  export type DefinitionSelectScalar = {
    id?: boolean
    label?: boolean
    content?: boolean
    alphabeticalLabel?: boolean
    mdxNoteId?: boolean
  }

  export type DefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mdxNote?: boolean | Definition$mdxNoteArgs<ExtArgs>
  }
  export type DefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mdxNote?: boolean | Definition$mdxNoteArgs<ExtArgs>
  }

  export type $DefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Definition"
    objects: {
      mdxNote: Prisma.$MdxNotePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string | null
      content: string | null
      alphabeticalLabel: string | null
      mdxNoteId: number | null
    }, ExtArgs["result"]["definition"]>
    composites: {}
  }

  type DefinitionGetPayload<S extends boolean | null | undefined | DefinitionDefaultArgs> = $Result.GetResult<Prisma.$DefinitionPayload, S>

  type DefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DefinitionCountAggregateInputType | true
    }

  export interface DefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Definition'], meta: { name: 'Definition' } }
    /**
     * Find zero or one Definition that matches the filter.
     * @param {DefinitionFindUniqueArgs} args - Arguments to find a Definition
     * @example
     * // Get one Definition
     * const definition = await prisma.definition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefinitionFindUniqueArgs>(args: SelectSubset<T, DefinitionFindUniqueArgs<ExtArgs>>): Prisma__DefinitionClient<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Definition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DefinitionFindUniqueOrThrowArgs} args - Arguments to find a Definition
     * @example
     * // Get one Definition
     * const definition = await prisma.definition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, DefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefinitionClient<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Definition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefinitionFindFirstArgs} args - Arguments to find a Definition
     * @example
     * // Get one Definition
     * const definition = await prisma.definition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefinitionFindFirstArgs>(args?: SelectSubset<T, DefinitionFindFirstArgs<ExtArgs>>): Prisma__DefinitionClient<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Definition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefinitionFindFirstOrThrowArgs} args - Arguments to find a Definition
     * @example
     * // Get one Definition
     * const definition = await prisma.definition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, DefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefinitionClient<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Definitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Definitions
     * const definitions = await prisma.definition.findMany()
     * 
     * // Get first 10 Definitions
     * const definitions = await prisma.definition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const definitionWithIdOnly = await prisma.definition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefinitionFindManyArgs>(args?: SelectSubset<T, DefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Definition.
     * @param {DefinitionCreateArgs} args - Arguments to create a Definition.
     * @example
     * // Create one Definition
     * const Definition = await prisma.definition.create({
     *   data: {
     *     // ... data to create a Definition
     *   }
     * })
     * 
     */
    create<T extends DefinitionCreateArgs>(args: SelectSubset<T, DefinitionCreateArgs<ExtArgs>>): Prisma__DefinitionClient<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Definitions.
     * @param {DefinitionCreateManyArgs} args - Arguments to create many Definitions.
     * @example
     * // Create many Definitions
     * const definition = await prisma.definition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefinitionCreateManyArgs>(args?: SelectSubset<T, DefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Definitions and returns the data saved in the database.
     * @param {DefinitionCreateManyAndReturnArgs} args - Arguments to create many Definitions.
     * @example
     * // Create many Definitions
     * const definition = await prisma.definition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Definitions and only return the `id`
     * const definitionWithIdOnly = await prisma.definition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, DefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Definition.
     * @param {DefinitionDeleteArgs} args - Arguments to delete one Definition.
     * @example
     * // Delete one Definition
     * const Definition = await prisma.definition.delete({
     *   where: {
     *     // ... filter to delete one Definition
     *   }
     * })
     * 
     */
    delete<T extends DefinitionDeleteArgs>(args: SelectSubset<T, DefinitionDeleteArgs<ExtArgs>>): Prisma__DefinitionClient<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Definition.
     * @param {DefinitionUpdateArgs} args - Arguments to update one Definition.
     * @example
     * // Update one Definition
     * const definition = await prisma.definition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefinitionUpdateArgs>(args: SelectSubset<T, DefinitionUpdateArgs<ExtArgs>>): Prisma__DefinitionClient<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Definitions.
     * @param {DefinitionDeleteManyArgs} args - Arguments to filter Definitions to delete.
     * @example
     * // Delete a few Definitions
     * const { count } = await prisma.definition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefinitionDeleteManyArgs>(args?: SelectSubset<T, DefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Definitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Definitions
     * const definition = await prisma.definition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefinitionUpdateManyArgs>(args: SelectSubset<T, DefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Definition.
     * @param {DefinitionUpsertArgs} args - Arguments to update or create a Definition.
     * @example
     * // Update or create a Definition
     * const definition = await prisma.definition.upsert({
     *   create: {
     *     // ... data to create a Definition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Definition we want to update
     *   }
     * })
     */
    upsert<T extends DefinitionUpsertArgs>(args: SelectSubset<T, DefinitionUpsertArgs<ExtArgs>>): Prisma__DefinitionClient<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Definitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefinitionCountArgs} args - Arguments to filter Definitions to count.
     * @example
     * // Count the number of Definitions
     * const count = await prisma.definition.count({
     *   where: {
     *     // ... the filter for the Definitions we want to count
     *   }
     * })
    **/
    count<T extends DefinitionCountArgs>(
      args?: Subset<T, DefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Definition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefinitionAggregateArgs>(args: Subset<T, DefinitionAggregateArgs>): Prisma.PrismaPromise<GetDefinitionAggregateType<T>>

    /**
     * Group by Definition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefinitionGroupByArgs['orderBy'] }
        : { orderBy?: DefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Definition model
   */
  readonly fields: DefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Definition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mdxNote<T extends Definition$mdxNoteArgs<ExtArgs> = {}>(args?: Subset<T, Definition$mdxNoteArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Definition model
   */ 
  interface DefinitionFieldRefs {
    readonly id: FieldRef<"Definition", 'String'>
    readonly label: FieldRef<"Definition", 'String'>
    readonly content: FieldRef<"Definition", 'String'>
    readonly alphabeticalLabel: FieldRef<"Definition", 'String'>
    readonly mdxNoteId: FieldRef<"Definition", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Definition findUnique
   */
  export type DefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * Filter, which Definition to fetch.
     */
    where: DefinitionWhereUniqueInput
  }

  /**
   * Definition findUniqueOrThrow
   */
  export type DefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * Filter, which Definition to fetch.
     */
    where: DefinitionWhereUniqueInput
  }

  /**
   * Definition findFirst
   */
  export type DefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * Filter, which Definition to fetch.
     */
    where?: DefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Definitions to fetch.
     */
    orderBy?: DefinitionOrderByWithRelationInput | DefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Definitions.
     */
    cursor?: DefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Definitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Definitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Definitions.
     */
    distinct?: DefinitionScalarFieldEnum | DefinitionScalarFieldEnum[]
  }

  /**
   * Definition findFirstOrThrow
   */
  export type DefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * Filter, which Definition to fetch.
     */
    where?: DefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Definitions to fetch.
     */
    orderBy?: DefinitionOrderByWithRelationInput | DefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Definitions.
     */
    cursor?: DefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Definitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Definitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Definitions.
     */
    distinct?: DefinitionScalarFieldEnum | DefinitionScalarFieldEnum[]
  }

  /**
   * Definition findMany
   */
  export type DefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * Filter, which Definitions to fetch.
     */
    where?: DefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Definitions to fetch.
     */
    orderBy?: DefinitionOrderByWithRelationInput | DefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Definitions.
     */
    cursor?: DefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Definitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Definitions.
     */
    skip?: number
    distinct?: DefinitionScalarFieldEnum | DefinitionScalarFieldEnum[]
  }

  /**
   * Definition create
   */
  export type DefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a Definition.
     */
    data: XOR<DefinitionCreateInput, DefinitionUncheckedCreateInput>
  }

  /**
   * Definition createMany
   */
  export type DefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Definitions.
     */
    data: DefinitionCreateManyInput | DefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Definition createManyAndReturn
   */
  export type DefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Definitions.
     */
    data: DefinitionCreateManyInput | DefinitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Definition update
   */
  export type DefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a Definition.
     */
    data: XOR<DefinitionUpdateInput, DefinitionUncheckedUpdateInput>
    /**
     * Choose, which Definition to update.
     */
    where: DefinitionWhereUniqueInput
  }

  /**
   * Definition updateMany
   */
  export type DefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Definitions.
     */
    data: XOR<DefinitionUpdateManyMutationInput, DefinitionUncheckedUpdateManyInput>
    /**
     * Filter which Definitions to update
     */
    where?: DefinitionWhereInput
  }

  /**
   * Definition upsert
   */
  export type DefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the Definition to update in case it exists.
     */
    where: DefinitionWhereUniqueInput
    /**
     * In case the Definition found by the `where` argument doesn't exist, create a new Definition with this data.
     */
    create: XOR<DefinitionCreateInput, DefinitionUncheckedCreateInput>
    /**
     * In case the Definition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefinitionUpdateInput, DefinitionUncheckedUpdateInput>
  }

  /**
   * Definition delete
   */
  export type DefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    /**
     * Filter which Definition to delete.
     */
    where: DefinitionWhereUniqueInput
  }

  /**
   * Definition deleteMany
   */
  export type DefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Definitions to delete
     */
    where?: DefinitionWhereInput
  }

  /**
   * Definition.mdxNote
   */
  export type Definition$mdxNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
  }

  /**
   * Definition without action
   */
  export type DefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: number | null
    tooltips: boolean | null
    title: string | null
    summary_showCitations: boolean | null
    summary_showTags: boolean | null
    landingImageAlign: $Enums.ImageAlignment | null
    lockedLandingImage: string | null
    cleanOnSync: boolean | null
    firstSync: Date | null
    lastSync: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: number | null
    tooltips: boolean | null
    title: string | null
    summary_showCitations: boolean | null
    summary_showTags: boolean | null
    landingImageAlign: $Enums.ImageAlignment | null
    lockedLandingImage: string | null
    cleanOnSync: boolean | null
    firstSync: Date | null
    lastSync: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    tooltips: number
    title: number
    summary_showCitations: number
    summary_showTags: number
    landingImageAlign: number
    lockedLandingImage: number
    cleanOnSync: number
    firstSync: number
    lastSync: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    tooltips?: true
    title?: true
    summary_showCitations?: true
    summary_showTags?: true
    landingImageAlign?: true
    lockedLandingImage?: true
    cleanOnSync?: true
    firstSync?: true
    lastSync?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    tooltips?: true
    title?: true
    summary_showCitations?: true
    summary_showTags?: true
    landingImageAlign?: true
    lockedLandingImage?: true
    cleanOnSync?: true
    firstSync?: true
    lastSync?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    tooltips?: true
    title?: true
    summary_showCitations?: true
    summary_showTags?: true
    landingImageAlign?: true
    lockedLandingImage?: true
    cleanOnSync?: true
    firstSync?: true
    lastSync?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: number
    tooltips: boolean
    title: string
    summary_showCitations: boolean
    summary_showTags: boolean
    landingImageAlign: $Enums.ImageAlignment
    lockedLandingImage: string | null
    cleanOnSync: boolean
    firstSync: Date
    lastSync: Date
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tooltips?: boolean
    title?: boolean
    summary_showCitations?: boolean
    summary_showTags?: boolean
    landingImageAlign?: boolean
    lockedLandingImage?: boolean
    cleanOnSync?: boolean
    firstSync?: boolean
    lastSync?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tooltips?: boolean
    title?: boolean
    summary_showCitations?: boolean
    summary_showTags?: boolean
    landingImageAlign?: boolean
    lockedLandingImage?: boolean
    cleanOnSync?: boolean
    firstSync?: boolean
    lastSync?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    tooltips?: boolean
    title?: boolean
    summary_showCitations?: boolean
    summary_showTags?: boolean
    landingImageAlign?: boolean
    lockedLandingImage?: boolean
    cleanOnSync?: boolean
    firstSync?: boolean
    lastSync?: boolean
  }


  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tooltips: boolean
      title: string
      summary_showCitations: boolean
      summary_showTags: boolean
      landingImageAlign: $Enums.ImageAlignment
      lockedLandingImage: string | null
      cleanOnSync: boolean
      firstSync: Date
      lastSync: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */ 
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'Int'>
    readonly tooltips: FieldRef<"Settings", 'Boolean'>
    readonly title: FieldRef<"Settings", 'String'>
    readonly summary_showCitations: FieldRef<"Settings", 'Boolean'>
    readonly summary_showTags: FieldRef<"Settings", 'Boolean'>
    readonly landingImageAlign: FieldRef<"Settings", 'ImageAlignment'>
    readonly lockedLandingImage: FieldRef<"Settings", 'String'>
    readonly cleanOnSync: FieldRef<"Settings", 'Boolean'>
    readonly firstSync: FieldRef<"Settings", 'DateTime'>
    readonly lastSync: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data?: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
  }


  /**
   * Model SettingsAppendix
   */

  export type AggregateSettingsAppendix = {
    _count: SettingsAppendixCountAggregateOutputType | null
    _min: SettingsAppendixMinAggregateOutputType | null
    _max: SettingsAppendixMaxAggregateOutputType | null
  }

  export type SettingsAppendixMinAggregateOutputType = {
    id: string | null
    data: Buffer | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingsAppendixMaxAggregateOutputType = {
    id: string | null
    data: Buffer | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingsAppendixCountAggregateOutputType = {
    id: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingsAppendixMinAggregateInputType = {
    id?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingsAppendixMaxAggregateInputType = {
    id?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingsAppendixCountAggregateInputType = {
    id?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAppendixAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingsAppendix to aggregate.
     */
    where?: SettingsAppendixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingsAppendices to fetch.
     */
    orderBy?: SettingsAppendixOrderByWithRelationInput | SettingsAppendixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsAppendixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingsAppendices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingsAppendices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingsAppendices
    **/
    _count?: true | SettingsAppendixCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsAppendixMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsAppendixMaxAggregateInputType
  }

  export type GetSettingsAppendixAggregateType<T extends SettingsAppendixAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingsAppendix]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingsAppendix[P]>
      : GetScalarType<T[P], AggregateSettingsAppendix[P]>
  }




  export type SettingsAppendixGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsAppendixWhereInput
    orderBy?: SettingsAppendixOrderByWithAggregationInput | SettingsAppendixOrderByWithAggregationInput[]
    by: SettingsAppendixScalarFieldEnum[] | SettingsAppendixScalarFieldEnum
    having?: SettingsAppendixScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsAppendixCountAggregateInputType | true
    _min?: SettingsAppendixMinAggregateInputType
    _max?: SettingsAppendixMaxAggregateInputType
  }

  export type SettingsAppendixGroupByOutputType = {
    id: string
    data: Buffer
    createdAt: Date
    updatedAt: Date
    _count: SettingsAppendixCountAggregateOutputType | null
    _min: SettingsAppendixMinAggregateOutputType | null
    _max: SettingsAppendixMaxAggregateOutputType | null
  }

  type GetSettingsAppendixGroupByPayload<T extends SettingsAppendixGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsAppendixGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsAppendixGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsAppendixGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsAppendixGroupByOutputType[P]>
        }
      >
    >


  export type SettingsAppendixSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settingsAppendix"]>

  export type SettingsAppendixSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settingsAppendix"]>

  export type SettingsAppendixSelectScalar = {
    id?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SettingsAppendixPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingsAppendix"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      data: Buffer
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["settingsAppendix"]>
    composites: {}
  }

  type SettingsAppendixGetPayload<S extends boolean | null | undefined | SettingsAppendixDefaultArgs> = $Result.GetResult<Prisma.$SettingsAppendixPayload, S>

  type SettingsAppendixCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingsAppendixFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingsAppendixCountAggregateInputType | true
    }

  export interface SettingsAppendixDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingsAppendix'], meta: { name: 'SettingsAppendix' } }
    /**
     * Find zero or one SettingsAppendix that matches the filter.
     * @param {SettingsAppendixFindUniqueArgs} args - Arguments to find a SettingsAppendix
     * @example
     * // Get one SettingsAppendix
     * const settingsAppendix = await prisma.settingsAppendix.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsAppendixFindUniqueArgs>(args: SelectSubset<T, SettingsAppendixFindUniqueArgs<ExtArgs>>): Prisma__SettingsAppendixClient<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SettingsAppendix that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingsAppendixFindUniqueOrThrowArgs} args - Arguments to find a SettingsAppendix
     * @example
     * // Get one SettingsAppendix
     * const settingsAppendix = await prisma.settingsAppendix.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsAppendixFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsAppendixFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsAppendixClient<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SettingsAppendix that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAppendixFindFirstArgs} args - Arguments to find a SettingsAppendix
     * @example
     * // Get one SettingsAppendix
     * const settingsAppendix = await prisma.settingsAppendix.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsAppendixFindFirstArgs>(args?: SelectSubset<T, SettingsAppendixFindFirstArgs<ExtArgs>>): Prisma__SettingsAppendixClient<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SettingsAppendix that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAppendixFindFirstOrThrowArgs} args - Arguments to find a SettingsAppendix
     * @example
     * // Get one SettingsAppendix
     * const settingsAppendix = await prisma.settingsAppendix.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsAppendixFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsAppendixFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsAppendixClient<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SettingsAppendices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAppendixFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingsAppendices
     * const settingsAppendices = await prisma.settingsAppendix.findMany()
     * 
     * // Get first 10 SettingsAppendices
     * const settingsAppendices = await prisma.settingsAppendix.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsAppendixWithIdOnly = await prisma.settingsAppendix.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsAppendixFindManyArgs>(args?: SelectSubset<T, SettingsAppendixFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SettingsAppendix.
     * @param {SettingsAppendixCreateArgs} args - Arguments to create a SettingsAppendix.
     * @example
     * // Create one SettingsAppendix
     * const SettingsAppendix = await prisma.settingsAppendix.create({
     *   data: {
     *     // ... data to create a SettingsAppendix
     *   }
     * })
     * 
     */
    create<T extends SettingsAppendixCreateArgs>(args: SelectSubset<T, SettingsAppendixCreateArgs<ExtArgs>>): Prisma__SettingsAppendixClient<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SettingsAppendices.
     * @param {SettingsAppendixCreateManyArgs} args - Arguments to create many SettingsAppendices.
     * @example
     * // Create many SettingsAppendices
     * const settingsAppendix = await prisma.settingsAppendix.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsAppendixCreateManyArgs>(args?: SelectSubset<T, SettingsAppendixCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SettingsAppendices and returns the data saved in the database.
     * @param {SettingsAppendixCreateManyAndReturnArgs} args - Arguments to create many SettingsAppendices.
     * @example
     * // Create many SettingsAppendices
     * const settingsAppendix = await prisma.settingsAppendix.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SettingsAppendices and only return the `id`
     * const settingsAppendixWithIdOnly = await prisma.settingsAppendix.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsAppendixCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsAppendixCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SettingsAppendix.
     * @param {SettingsAppendixDeleteArgs} args - Arguments to delete one SettingsAppendix.
     * @example
     * // Delete one SettingsAppendix
     * const SettingsAppendix = await prisma.settingsAppendix.delete({
     *   where: {
     *     // ... filter to delete one SettingsAppendix
     *   }
     * })
     * 
     */
    delete<T extends SettingsAppendixDeleteArgs>(args: SelectSubset<T, SettingsAppendixDeleteArgs<ExtArgs>>): Prisma__SettingsAppendixClient<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SettingsAppendix.
     * @param {SettingsAppendixUpdateArgs} args - Arguments to update one SettingsAppendix.
     * @example
     * // Update one SettingsAppendix
     * const settingsAppendix = await prisma.settingsAppendix.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsAppendixUpdateArgs>(args: SelectSubset<T, SettingsAppendixUpdateArgs<ExtArgs>>): Prisma__SettingsAppendixClient<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SettingsAppendices.
     * @param {SettingsAppendixDeleteManyArgs} args - Arguments to filter SettingsAppendices to delete.
     * @example
     * // Delete a few SettingsAppendices
     * const { count } = await prisma.settingsAppendix.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsAppendixDeleteManyArgs>(args?: SelectSubset<T, SettingsAppendixDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingsAppendices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAppendixUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingsAppendices
     * const settingsAppendix = await prisma.settingsAppendix.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsAppendixUpdateManyArgs>(args: SelectSubset<T, SettingsAppendixUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettingsAppendix.
     * @param {SettingsAppendixUpsertArgs} args - Arguments to update or create a SettingsAppendix.
     * @example
     * // Update or create a SettingsAppendix
     * const settingsAppendix = await prisma.settingsAppendix.upsert({
     *   create: {
     *     // ... data to create a SettingsAppendix
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingsAppendix we want to update
     *   }
     * })
     */
    upsert<T extends SettingsAppendixUpsertArgs>(args: SelectSubset<T, SettingsAppendixUpsertArgs<ExtArgs>>): Prisma__SettingsAppendixClient<$Result.GetResult<Prisma.$SettingsAppendixPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SettingsAppendices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAppendixCountArgs} args - Arguments to filter SettingsAppendices to count.
     * @example
     * // Count the number of SettingsAppendices
     * const count = await prisma.settingsAppendix.count({
     *   where: {
     *     // ... the filter for the SettingsAppendices we want to count
     *   }
     * })
    **/
    count<T extends SettingsAppendixCountArgs>(
      args?: Subset<T, SettingsAppendixCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsAppendixCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingsAppendix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAppendixAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAppendixAggregateArgs>(args: Subset<T, SettingsAppendixAggregateArgs>): Prisma.PrismaPromise<GetSettingsAppendixAggregateType<T>>

    /**
     * Group by SettingsAppendix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAppendixGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsAppendixGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsAppendixGroupByArgs['orderBy'] }
        : { orderBy?: SettingsAppendixGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsAppendixGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsAppendixGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingsAppendix model
   */
  readonly fields: SettingsAppendixFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingsAppendix.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsAppendixClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingsAppendix model
   */ 
  interface SettingsAppendixFieldRefs {
    readonly id: FieldRef<"SettingsAppendix", 'String'>
    readonly data: FieldRef<"SettingsAppendix", 'Bytes'>
    readonly createdAt: FieldRef<"SettingsAppendix", 'DateTime'>
    readonly updatedAt: FieldRef<"SettingsAppendix", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SettingsAppendix findUnique
   */
  export type SettingsAppendixFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * Filter, which SettingsAppendix to fetch.
     */
    where: SettingsAppendixWhereUniqueInput
  }

  /**
   * SettingsAppendix findUniqueOrThrow
   */
  export type SettingsAppendixFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * Filter, which SettingsAppendix to fetch.
     */
    where: SettingsAppendixWhereUniqueInput
  }

  /**
   * SettingsAppendix findFirst
   */
  export type SettingsAppendixFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * Filter, which SettingsAppendix to fetch.
     */
    where?: SettingsAppendixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingsAppendices to fetch.
     */
    orderBy?: SettingsAppendixOrderByWithRelationInput | SettingsAppendixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingsAppendices.
     */
    cursor?: SettingsAppendixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingsAppendices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingsAppendices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingsAppendices.
     */
    distinct?: SettingsAppendixScalarFieldEnum | SettingsAppendixScalarFieldEnum[]
  }

  /**
   * SettingsAppendix findFirstOrThrow
   */
  export type SettingsAppendixFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * Filter, which SettingsAppendix to fetch.
     */
    where?: SettingsAppendixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingsAppendices to fetch.
     */
    orderBy?: SettingsAppendixOrderByWithRelationInput | SettingsAppendixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingsAppendices.
     */
    cursor?: SettingsAppendixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingsAppendices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingsAppendices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingsAppendices.
     */
    distinct?: SettingsAppendixScalarFieldEnum | SettingsAppendixScalarFieldEnum[]
  }

  /**
   * SettingsAppendix findMany
   */
  export type SettingsAppendixFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * Filter, which SettingsAppendices to fetch.
     */
    where?: SettingsAppendixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingsAppendices to fetch.
     */
    orderBy?: SettingsAppendixOrderByWithRelationInput | SettingsAppendixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingsAppendices.
     */
    cursor?: SettingsAppendixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingsAppendices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingsAppendices.
     */
    skip?: number
    distinct?: SettingsAppendixScalarFieldEnum | SettingsAppendixScalarFieldEnum[]
  }

  /**
   * SettingsAppendix create
   */
  export type SettingsAppendixCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * The data needed to create a SettingsAppendix.
     */
    data: XOR<SettingsAppendixCreateInput, SettingsAppendixUncheckedCreateInput>
  }

  /**
   * SettingsAppendix createMany
   */
  export type SettingsAppendixCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingsAppendices.
     */
    data: SettingsAppendixCreateManyInput | SettingsAppendixCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingsAppendix createManyAndReturn
   */
  export type SettingsAppendixCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SettingsAppendices.
     */
    data: SettingsAppendixCreateManyInput | SettingsAppendixCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingsAppendix update
   */
  export type SettingsAppendixUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * The data needed to update a SettingsAppendix.
     */
    data: XOR<SettingsAppendixUpdateInput, SettingsAppendixUncheckedUpdateInput>
    /**
     * Choose, which SettingsAppendix to update.
     */
    where: SettingsAppendixWhereUniqueInput
  }

  /**
   * SettingsAppendix updateMany
   */
  export type SettingsAppendixUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingsAppendices.
     */
    data: XOR<SettingsAppendixUpdateManyMutationInput, SettingsAppendixUncheckedUpdateManyInput>
    /**
     * Filter which SettingsAppendices to update
     */
    where?: SettingsAppendixWhereInput
  }

  /**
   * SettingsAppendix upsert
   */
  export type SettingsAppendixUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * The filter to search for the SettingsAppendix to update in case it exists.
     */
    where: SettingsAppendixWhereUniqueInput
    /**
     * In case the SettingsAppendix found by the `where` argument doesn't exist, create a new SettingsAppendix with this data.
     */
    create: XOR<SettingsAppendixCreateInput, SettingsAppendixUncheckedCreateInput>
    /**
     * In case the SettingsAppendix was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsAppendixUpdateInput, SettingsAppendixUncheckedUpdateInput>
  }

  /**
   * SettingsAppendix delete
   */
  export type SettingsAppendixDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
    /**
     * Filter which SettingsAppendix to delete.
     */
    where: SettingsAppendixWhereUniqueInput
  }

  /**
   * SettingsAppendix deleteMany
   */
  export type SettingsAppendixDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingsAppendices to delete
     */
    where?: SettingsAppendixWhereInput
  }

  /**
   * SettingsAppendix without action
   */
  export type SettingsAppendixDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsAppendix
     */
    select?: SettingsAppendixSelect<ExtArgs> | null
  }


  /**
   * Model RandomImage
   */

  export type AggregateRandomImage = {
    _count: RandomImageCountAggregateOutputType | null
    _min: RandomImageMinAggregateOutputType | null
    _max: RandomImageMaxAggregateOutputType | null
  }

  export type RandomImageMinAggregateOutputType = {
    path: string | null
    createdAt: Date | null
  }

  export type RandomImageMaxAggregateOutputType = {
    path: string | null
    createdAt: Date | null
  }

  export type RandomImageCountAggregateOutputType = {
    path: number
    createdAt: number
    _all: number
  }


  export type RandomImageMinAggregateInputType = {
    path?: true
    createdAt?: true
  }

  export type RandomImageMaxAggregateInputType = {
    path?: true
    createdAt?: true
  }

  export type RandomImageCountAggregateInputType = {
    path?: true
    createdAt?: true
    _all?: true
  }

  export type RandomImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RandomImage to aggregate.
     */
    where?: RandomImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RandomImages to fetch.
     */
    orderBy?: RandomImageOrderByWithRelationInput | RandomImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RandomImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RandomImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RandomImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RandomImages
    **/
    _count?: true | RandomImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RandomImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RandomImageMaxAggregateInputType
  }

  export type GetRandomImageAggregateType<T extends RandomImageAggregateArgs> = {
        [P in keyof T & keyof AggregateRandomImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRandomImage[P]>
      : GetScalarType<T[P], AggregateRandomImage[P]>
  }




  export type RandomImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RandomImageWhereInput
    orderBy?: RandomImageOrderByWithAggregationInput | RandomImageOrderByWithAggregationInput[]
    by: RandomImageScalarFieldEnum[] | RandomImageScalarFieldEnum
    having?: RandomImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RandomImageCountAggregateInputType | true
    _min?: RandomImageMinAggregateInputType
    _max?: RandomImageMaxAggregateInputType
  }

  export type RandomImageGroupByOutputType = {
    path: string
    createdAt: Date
    _count: RandomImageCountAggregateOutputType | null
    _min: RandomImageMinAggregateOutputType | null
    _max: RandomImageMaxAggregateOutputType | null
  }

  type GetRandomImageGroupByPayload<T extends RandomImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RandomImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RandomImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RandomImageGroupByOutputType[P]>
            : GetScalarType<T[P], RandomImageGroupByOutputType[P]>
        }
      >
    >


  export type RandomImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    path?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["randomImage"]>

  export type RandomImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    path?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["randomImage"]>

  export type RandomImageSelectScalar = {
    path?: boolean
    createdAt?: boolean
  }


  export type $RandomImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RandomImage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      path: string
      createdAt: Date
    }, ExtArgs["result"]["randomImage"]>
    composites: {}
  }

  type RandomImageGetPayload<S extends boolean | null | undefined | RandomImageDefaultArgs> = $Result.GetResult<Prisma.$RandomImagePayload, S>

  type RandomImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RandomImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RandomImageCountAggregateInputType | true
    }

  export interface RandomImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RandomImage'], meta: { name: 'RandomImage' } }
    /**
     * Find zero or one RandomImage that matches the filter.
     * @param {RandomImageFindUniqueArgs} args - Arguments to find a RandomImage
     * @example
     * // Get one RandomImage
     * const randomImage = await prisma.randomImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RandomImageFindUniqueArgs>(args: SelectSubset<T, RandomImageFindUniqueArgs<ExtArgs>>): Prisma__RandomImageClient<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RandomImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RandomImageFindUniqueOrThrowArgs} args - Arguments to find a RandomImage
     * @example
     * // Get one RandomImage
     * const randomImage = await prisma.randomImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RandomImageFindUniqueOrThrowArgs>(args: SelectSubset<T, RandomImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RandomImageClient<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RandomImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomImageFindFirstArgs} args - Arguments to find a RandomImage
     * @example
     * // Get one RandomImage
     * const randomImage = await prisma.randomImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RandomImageFindFirstArgs>(args?: SelectSubset<T, RandomImageFindFirstArgs<ExtArgs>>): Prisma__RandomImageClient<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RandomImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomImageFindFirstOrThrowArgs} args - Arguments to find a RandomImage
     * @example
     * // Get one RandomImage
     * const randomImage = await prisma.randomImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RandomImageFindFirstOrThrowArgs>(args?: SelectSubset<T, RandomImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__RandomImageClient<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RandomImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RandomImages
     * const randomImages = await prisma.randomImage.findMany()
     * 
     * // Get first 10 RandomImages
     * const randomImages = await prisma.randomImage.findMany({ take: 10 })
     * 
     * // Only select the `path`
     * const randomImageWithPathOnly = await prisma.randomImage.findMany({ select: { path: true } })
     * 
     */
    findMany<T extends RandomImageFindManyArgs>(args?: SelectSubset<T, RandomImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RandomImage.
     * @param {RandomImageCreateArgs} args - Arguments to create a RandomImage.
     * @example
     * // Create one RandomImage
     * const RandomImage = await prisma.randomImage.create({
     *   data: {
     *     // ... data to create a RandomImage
     *   }
     * })
     * 
     */
    create<T extends RandomImageCreateArgs>(args: SelectSubset<T, RandomImageCreateArgs<ExtArgs>>): Prisma__RandomImageClient<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RandomImages.
     * @param {RandomImageCreateManyArgs} args - Arguments to create many RandomImages.
     * @example
     * // Create many RandomImages
     * const randomImage = await prisma.randomImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RandomImageCreateManyArgs>(args?: SelectSubset<T, RandomImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RandomImages and returns the data saved in the database.
     * @param {RandomImageCreateManyAndReturnArgs} args - Arguments to create many RandomImages.
     * @example
     * // Create many RandomImages
     * const randomImage = await prisma.randomImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RandomImages and only return the `path`
     * const randomImageWithPathOnly = await prisma.randomImage.createManyAndReturn({ 
     *   select: { path: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RandomImageCreateManyAndReturnArgs>(args?: SelectSubset<T, RandomImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RandomImage.
     * @param {RandomImageDeleteArgs} args - Arguments to delete one RandomImage.
     * @example
     * // Delete one RandomImage
     * const RandomImage = await prisma.randomImage.delete({
     *   where: {
     *     // ... filter to delete one RandomImage
     *   }
     * })
     * 
     */
    delete<T extends RandomImageDeleteArgs>(args: SelectSubset<T, RandomImageDeleteArgs<ExtArgs>>): Prisma__RandomImageClient<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RandomImage.
     * @param {RandomImageUpdateArgs} args - Arguments to update one RandomImage.
     * @example
     * // Update one RandomImage
     * const randomImage = await prisma.randomImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RandomImageUpdateArgs>(args: SelectSubset<T, RandomImageUpdateArgs<ExtArgs>>): Prisma__RandomImageClient<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RandomImages.
     * @param {RandomImageDeleteManyArgs} args - Arguments to filter RandomImages to delete.
     * @example
     * // Delete a few RandomImages
     * const { count } = await prisma.randomImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RandomImageDeleteManyArgs>(args?: SelectSubset<T, RandomImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RandomImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RandomImages
     * const randomImage = await prisma.randomImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RandomImageUpdateManyArgs>(args: SelectSubset<T, RandomImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RandomImage.
     * @param {RandomImageUpsertArgs} args - Arguments to update or create a RandomImage.
     * @example
     * // Update or create a RandomImage
     * const randomImage = await prisma.randomImage.upsert({
     *   create: {
     *     // ... data to create a RandomImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RandomImage we want to update
     *   }
     * })
     */
    upsert<T extends RandomImageUpsertArgs>(args: SelectSubset<T, RandomImageUpsertArgs<ExtArgs>>): Prisma__RandomImageClient<$Result.GetResult<Prisma.$RandomImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RandomImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomImageCountArgs} args - Arguments to filter RandomImages to count.
     * @example
     * // Count the number of RandomImages
     * const count = await prisma.randomImage.count({
     *   where: {
     *     // ... the filter for the RandomImages we want to count
     *   }
     * })
    **/
    count<T extends RandomImageCountArgs>(
      args?: Subset<T, RandomImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RandomImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RandomImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RandomImageAggregateArgs>(args: Subset<T, RandomImageAggregateArgs>): Prisma.PrismaPromise<GetRandomImageAggregateType<T>>

    /**
     * Group by RandomImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RandomImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RandomImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RandomImageGroupByArgs['orderBy'] }
        : { orderBy?: RandomImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RandomImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRandomImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RandomImage model
   */
  readonly fields: RandomImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RandomImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RandomImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RandomImage model
   */ 
  interface RandomImageFieldRefs {
    readonly path: FieldRef<"RandomImage", 'String'>
    readonly createdAt: FieldRef<"RandomImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RandomImage findUnique
   */
  export type RandomImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * Filter, which RandomImage to fetch.
     */
    where: RandomImageWhereUniqueInput
  }

  /**
   * RandomImage findUniqueOrThrow
   */
  export type RandomImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * Filter, which RandomImage to fetch.
     */
    where: RandomImageWhereUniqueInput
  }

  /**
   * RandomImage findFirst
   */
  export type RandomImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * Filter, which RandomImage to fetch.
     */
    where?: RandomImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RandomImages to fetch.
     */
    orderBy?: RandomImageOrderByWithRelationInput | RandomImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RandomImages.
     */
    cursor?: RandomImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RandomImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RandomImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RandomImages.
     */
    distinct?: RandomImageScalarFieldEnum | RandomImageScalarFieldEnum[]
  }

  /**
   * RandomImage findFirstOrThrow
   */
  export type RandomImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * Filter, which RandomImage to fetch.
     */
    where?: RandomImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RandomImages to fetch.
     */
    orderBy?: RandomImageOrderByWithRelationInput | RandomImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RandomImages.
     */
    cursor?: RandomImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RandomImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RandomImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RandomImages.
     */
    distinct?: RandomImageScalarFieldEnum | RandomImageScalarFieldEnum[]
  }

  /**
   * RandomImage findMany
   */
  export type RandomImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * Filter, which RandomImages to fetch.
     */
    where?: RandomImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RandomImages to fetch.
     */
    orderBy?: RandomImageOrderByWithRelationInput | RandomImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RandomImages.
     */
    cursor?: RandomImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RandomImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RandomImages.
     */
    skip?: number
    distinct?: RandomImageScalarFieldEnum | RandomImageScalarFieldEnum[]
  }

  /**
   * RandomImage create
   */
  export type RandomImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * The data needed to create a RandomImage.
     */
    data: XOR<RandomImageCreateInput, RandomImageUncheckedCreateInput>
  }

  /**
   * RandomImage createMany
   */
  export type RandomImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RandomImages.
     */
    data: RandomImageCreateManyInput | RandomImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RandomImage createManyAndReturn
   */
  export type RandomImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RandomImages.
     */
    data: RandomImageCreateManyInput | RandomImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RandomImage update
   */
  export type RandomImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * The data needed to update a RandomImage.
     */
    data: XOR<RandomImageUpdateInput, RandomImageUncheckedUpdateInput>
    /**
     * Choose, which RandomImage to update.
     */
    where: RandomImageWhereUniqueInput
  }

  /**
   * RandomImage updateMany
   */
  export type RandomImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RandomImages.
     */
    data: XOR<RandomImageUpdateManyMutationInput, RandomImageUncheckedUpdateManyInput>
    /**
     * Filter which RandomImages to update
     */
    where?: RandomImageWhereInput
  }

  /**
   * RandomImage upsert
   */
  export type RandomImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * The filter to search for the RandomImage to update in case it exists.
     */
    where: RandomImageWhereUniqueInput
    /**
     * In case the RandomImage found by the `where` argument doesn't exist, create a new RandomImage with this data.
     */
    create: XOR<RandomImageCreateInput, RandomImageUncheckedCreateInput>
    /**
     * In case the RandomImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RandomImageUpdateInput, RandomImageUncheckedUpdateInput>
  }

  /**
   * RandomImage delete
   */
  export type RandomImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
    /**
     * Filter which RandomImage to delete.
     */
    where: RandomImageWhereUniqueInput
  }

  /**
   * RandomImage deleteMany
   */
  export type RandomImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RandomImages to delete
     */
    where?: RandomImageWhereInput
  }

  /**
   * RandomImage without action
   */
  export type RandomImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RandomImage
     */
    select?: RandomImageSelect<ExtArgs> | null
  }


  /**
   * Model NoteType
   */

  export type AggregateNoteType = {
    _count: NoteTypeCountAggregateOutputType | null
    _min: NoteTypeMinAggregateOutputType | null
    _max: NoteTypeMaxAggregateOutputType | null
  }

  export type NoteTypeMinAggregateOutputType = {
    name: string | null
  }

  export type NoteTypeMaxAggregateOutputType = {
    name: string | null
  }

  export type NoteTypeCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type NoteTypeMinAggregateInputType = {
    name?: true
  }

  export type NoteTypeMaxAggregateInputType = {
    name?: true
  }

  export type NoteTypeCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type NoteTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteType to aggregate.
     */
    where?: NoteTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTypes to fetch.
     */
    orderBy?: NoteTypeOrderByWithRelationInput | NoteTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoteTypes
    **/
    _count?: true | NoteTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteTypeMaxAggregateInputType
  }

  export type GetNoteTypeAggregateType<T extends NoteTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteType[P]>
      : GetScalarType<T[P], AggregateNoteType[P]>
  }




  export type NoteTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteTypeWhereInput
    orderBy?: NoteTypeOrderByWithAggregationInput | NoteTypeOrderByWithAggregationInput[]
    by: NoteTypeScalarFieldEnum[] | NoteTypeScalarFieldEnum
    having?: NoteTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteTypeCountAggregateInputType | true
    _min?: NoteTypeMinAggregateInputType
    _max?: NoteTypeMaxAggregateInputType
  }

  export type NoteTypeGroupByOutputType = {
    name: string
    _count: NoteTypeCountAggregateOutputType | null
    _min: NoteTypeMinAggregateOutputType | null
    _max: NoteTypeMaxAggregateOutputType | null
  }

  type GetNoteTypeGroupByPayload<T extends NoteTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteTypeGroupByOutputType[P]>
            : GetScalarType<T[P], NoteTypeGroupByOutputType[P]>
        }
      >
    >


  export type NoteTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
  }, ExtArgs["result"]["noteType"]>

  export type NoteTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
  }, ExtArgs["result"]["noteType"]>

  export type NoteTypeSelectScalar = {
    name?: boolean
  }


  export type $NoteTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoteType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
    }, ExtArgs["result"]["noteType"]>
    composites: {}
  }

  type NoteTypeGetPayload<S extends boolean | null | undefined | NoteTypeDefaultArgs> = $Result.GetResult<Prisma.$NoteTypePayload, S>

  type NoteTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteTypeCountAggregateInputType | true
    }

  export interface NoteTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoteType'], meta: { name: 'NoteType' } }
    /**
     * Find zero or one NoteType that matches the filter.
     * @param {NoteTypeFindUniqueArgs} args - Arguments to find a NoteType
     * @example
     * // Get one NoteType
     * const noteType = await prisma.noteType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteTypeFindUniqueArgs>(args: SelectSubset<T, NoteTypeFindUniqueArgs<ExtArgs>>): Prisma__NoteTypeClient<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NoteType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteTypeFindUniqueOrThrowArgs} args - Arguments to find a NoteType
     * @example
     * // Get one NoteType
     * const noteType = await prisma.noteType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteTypeClient<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NoteType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTypeFindFirstArgs} args - Arguments to find a NoteType
     * @example
     * // Get one NoteType
     * const noteType = await prisma.noteType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteTypeFindFirstArgs>(args?: SelectSubset<T, NoteTypeFindFirstArgs<ExtArgs>>): Prisma__NoteTypeClient<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NoteType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTypeFindFirstOrThrowArgs} args - Arguments to find a NoteType
     * @example
     * // Get one NoteType
     * const noteType = await prisma.noteType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteTypeClient<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NoteTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteTypes
     * const noteTypes = await prisma.noteType.findMany()
     * 
     * // Get first 10 NoteTypes
     * const noteTypes = await prisma.noteType.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const noteTypeWithNameOnly = await prisma.noteType.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends NoteTypeFindManyArgs>(args?: SelectSubset<T, NoteTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NoteType.
     * @param {NoteTypeCreateArgs} args - Arguments to create a NoteType.
     * @example
     * // Create one NoteType
     * const NoteType = await prisma.noteType.create({
     *   data: {
     *     // ... data to create a NoteType
     *   }
     * })
     * 
     */
    create<T extends NoteTypeCreateArgs>(args: SelectSubset<T, NoteTypeCreateArgs<ExtArgs>>): Prisma__NoteTypeClient<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NoteTypes.
     * @param {NoteTypeCreateManyArgs} args - Arguments to create many NoteTypes.
     * @example
     * // Create many NoteTypes
     * const noteType = await prisma.noteType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteTypeCreateManyArgs>(args?: SelectSubset<T, NoteTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteTypes and returns the data saved in the database.
     * @param {NoteTypeCreateManyAndReturnArgs} args - Arguments to create many NoteTypes.
     * @example
     * // Create many NoteTypes
     * const noteType = await prisma.noteType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteTypes and only return the `name`
     * const noteTypeWithNameOnly = await prisma.noteType.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NoteType.
     * @param {NoteTypeDeleteArgs} args - Arguments to delete one NoteType.
     * @example
     * // Delete one NoteType
     * const NoteType = await prisma.noteType.delete({
     *   where: {
     *     // ... filter to delete one NoteType
     *   }
     * })
     * 
     */
    delete<T extends NoteTypeDeleteArgs>(args: SelectSubset<T, NoteTypeDeleteArgs<ExtArgs>>): Prisma__NoteTypeClient<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NoteType.
     * @param {NoteTypeUpdateArgs} args - Arguments to update one NoteType.
     * @example
     * // Update one NoteType
     * const noteType = await prisma.noteType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteTypeUpdateArgs>(args: SelectSubset<T, NoteTypeUpdateArgs<ExtArgs>>): Prisma__NoteTypeClient<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NoteTypes.
     * @param {NoteTypeDeleteManyArgs} args - Arguments to filter NoteTypes to delete.
     * @example
     * // Delete a few NoteTypes
     * const { count } = await prisma.noteType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteTypeDeleteManyArgs>(args?: SelectSubset<T, NoteTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteTypes
     * const noteType = await prisma.noteType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteTypeUpdateManyArgs>(args: SelectSubset<T, NoteTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoteType.
     * @param {NoteTypeUpsertArgs} args - Arguments to update or create a NoteType.
     * @example
     * // Update or create a NoteType
     * const noteType = await prisma.noteType.upsert({
     *   create: {
     *     // ... data to create a NoteType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteType we want to update
     *   }
     * })
     */
    upsert<T extends NoteTypeUpsertArgs>(args: SelectSubset<T, NoteTypeUpsertArgs<ExtArgs>>): Prisma__NoteTypeClient<$Result.GetResult<Prisma.$NoteTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NoteTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTypeCountArgs} args - Arguments to filter NoteTypes to count.
     * @example
     * // Count the number of NoteTypes
     * const count = await prisma.noteType.count({
     *   where: {
     *     // ... the filter for the NoteTypes we want to count
     *   }
     * })
    **/
    count<T extends NoteTypeCountArgs>(
      args?: Subset<T, NoteTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteTypeAggregateArgs>(args: Subset<T, NoteTypeAggregateArgs>): Prisma.PrismaPromise<GetNoteTypeAggregateType<T>>

    /**
     * Group by NoteType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteTypeGroupByArgs['orderBy'] }
        : { orderBy?: NoteTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoteType model
   */
  readonly fields: NoteTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoteType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoteType model
   */ 
  interface NoteTypeFieldRefs {
    readonly name: FieldRef<"NoteType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NoteType findUnique
   */
  export type NoteTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * Filter, which NoteType to fetch.
     */
    where: NoteTypeWhereUniqueInput
  }

  /**
   * NoteType findUniqueOrThrow
   */
  export type NoteTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * Filter, which NoteType to fetch.
     */
    where: NoteTypeWhereUniqueInput
  }

  /**
   * NoteType findFirst
   */
  export type NoteTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * Filter, which NoteType to fetch.
     */
    where?: NoteTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTypes to fetch.
     */
    orderBy?: NoteTypeOrderByWithRelationInput | NoteTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteTypes.
     */
    cursor?: NoteTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteTypes.
     */
    distinct?: NoteTypeScalarFieldEnum | NoteTypeScalarFieldEnum[]
  }

  /**
   * NoteType findFirstOrThrow
   */
  export type NoteTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * Filter, which NoteType to fetch.
     */
    where?: NoteTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTypes to fetch.
     */
    orderBy?: NoteTypeOrderByWithRelationInput | NoteTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteTypes.
     */
    cursor?: NoteTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteTypes.
     */
    distinct?: NoteTypeScalarFieldEnum | NoteTypeScalarFieldEnum[]
  }

  /**
   * NoteType findMany
   */
  export type NoteTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * Filter, which NoteTypes to fetch.
     */
    where?: NoteTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTypes to fetch.
     */
    orderBy?: NoteTypeOrderByWithRelationInput | NoteTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoteTypes.
     */
    cursor?: NoteTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTypes.
     */
    skip?: number
    distinct?: NoteTypeScalarFieldEnum | NoteTypeScalarFieldEnum[]
  }

  /**
   * NoteType create
   */
  export type NoteTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a NoteType.
     */
    data: XOR<NoteTypeCreateInput, NoteTypeUncheckedCreateInput>
  }

  /**
   * NoteType createMany
   */
  export type NoteTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoteTypes.
     */
    data: NoteTypeCreateManyInput | NoteTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NoteType createManyAndReturn
   */
  export type NoteTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NoteTypes.
     */
    data: NoteTypeCreateManyInput | NoteTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NoteType update
   */
  export type NoteTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a NoteType.
     */
    data: XOR<NoteTypeUpdateInput, NoteTypeUncheckedUpdateInput>
    /**
     * Choose, which NoteType to update.
     */
    where: NoteTypeWhereUniqueInput
  }

  /**
   * NoteType updateMany
   */
  export type NoteTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoteTypes.
     */
    data: XOR<NoteTypeUpdateManyMutationInput, NoteTypeUncheckedUpdateManyInput>
    /**
     * Filter which NoteTypes to update
     */
    where?: NoteTypeWhereInput
  }

  /**
   * NoteType upsert
   */
  export type NoteTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the NoteType to update in case it exists.
     */
    where: NoteTypeWhereUniqueInput
    /**
     * In case the NoteType found by the `where` argument doesn't exist, create a new NoteType with this data.
     */
    create: XOR<NoteTypeCreateInput, NoteTypeUncheckedCreateInput>
    /**
     * In case the NoteType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteTypeUpdateInput, NoteTypeUncheckedUpdateInput>
  }

  /**
   * NoteType delete
   */
  export type NoteTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
    /**
     * Filter which NoteType to delete.
     */
    where: NoteTypeWhereUniqueInput
  }

  /**
   * NoteType deleteMany
   */
  export type NoteTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteTypes to delete
     */
    where?: NoteTypeWhereInput
  }

  /**
   * NoteType without action
   */
  export type NoteTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteType
     */
    select?: NoteTypeSelect<ExtArgs> | null
  }


  /**
   * Model QAPair
   */

  export type AggregateQAPair = {
    _count: QAPairCountAggregateOutputType | null
    _avg: QAPairAvgAggregateOutputType | null
    _sum: QAPairSumAggregateOutputType | null
    _min: QAPairMinAggregateOutputType | null
    _max: QAPairMaxAggregateOutputType | null
  }

  export type QAPairAvgAggregateOutputType = {
    correctCount: number | null
    inCorrectCount: number | null
  }

  export type QAPairSumAggregateOutputType = {
    correctCount: number | null
    inCorrectCount: number | null
  }

  export type QAPairMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    description: string | null
    secondaryLabel: string | null
    correctCount: number | null
    inCorrectCount: number | null
  }

  export type QAPairMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    description: string | null
    secondaryLabel: string | null
    correctCount: number | null
    inCorrectCount: number | null
  }

  export type QAPairCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    description: number
    secondaryLabel: number
    correctCount: number
    inCorrectCount: number
    _all: number
  }


  export type QAPairAvgAggregateInputType = {
    correctCount?: true
    inCorrectCount?: true
  }

  export type QAPairSumAggregateInputType = {
    correctCount?: true
    inCorrectCount?: true
  }

  export type QAPairMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    description?: true
    secondaryLabel?: true
    correctCount?: true
    inCorrectCount?: true
  }

  export type QAPairMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    description?: true
    secondaryLabel?: true
    correctCount?: true
    inCorrectCount?: true
  }

  export type QAPairCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    description?: true
    secondaryLabel?: true
    correctCount?: true
    inCorrectCount?: true
    _all?: true
  }

  export type QAPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QAPair to aggregate.
     */
    where?: QAPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAPairs to fetch.
     */
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QAPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QAPairs
    **/
    _count?: true | QAPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QAPairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QAPairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QAPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QAPairMaxAggregateInputType
  }

  export type GetQAPairAggregateType<T extends QAPairAggregateArgs> = {
        [P in keyof T & keyof AggregateQAPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQAPair[P]>
      : GetScalarType<T[P], AggregateQAPair[P]>
  }




  export type QAPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAPairWhereInput
    orderBy?: QAPairOrderByWithAggregationInput | QAPairOrderByWithAggregationInput[]
    by: QAPairScalarFieldEnum[] | QAPairScalarFieldEnum
    having?: QAPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QAPairCountAggregateInputType | true
    _avg?: QAPairAvgAggregateInputType
    _sum?: QAPairSumAggregateInputType
    _min?: QAPairMinAggregateInputType
    _max?: QAPairMaxAggregateInputType
  }

  export type QAPairGroupByOutputType = {
    id: string
    question: string
    answer: string
    description: string | null
    secondaryLabel: string | null
    correctCount: number
    inCorrectCount: number
    _count: QAPairCountAggregateOutputType | null
    _avg: QAPairAvgAggregateOutputType | null
    _sum: QAPairSumAggregateOutputType | null
    _min: QAPairMinAggregateOutputType | null
    _max: QAPairMaxAggregateOutputType | null
  }

  type GetQAPairGroupByPayload<T extends QAPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QAPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QAPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QAPairGroupByOutputType[P]>
            : GetScalarType<T[P], QAPairGroupByOutputType[P]>
        }
      >
    >


  export type QAPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    description?: boolean
    secondaryLabel?: boolean
    correctCount?: boolean
    inCorrectCount?: boolean
    tags?: boolean | QAPair$tagsArgs<ExtArgs>
    topics?: boolean | QAPair$topicsArgs<ExtArgs>
    subjects?: boolean | QAPair$subjectsArgs<ExtArgs>
    practiceExam?: boolean | QAPair$practiceExamArgs<ExtArgs>
    _count?: boolean | QAPairCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qAPair"]>

  export type QAPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    description?: boolean
    secondaryLabel?: boolean
    correctCount?: boolean
    inCorrectCount?: boolean
  }, ExtArgs["result"]["qAPair"]>

  export type QAPairSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    description?: boolean
    secondaryLabel?: boolean
    correctCount?: boolean
    inCorrectCount?: boolean
  }

  export type QAPairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | QAPair$tagsArgs<ExtArgs>
    topics?: boolean | QAPair$topicsArgs<ExtArgs>
    subjects?: boolean | QAPair$subjectsArgs<ExtArgs>
    practiceExam?: boolean | QAPair$practiceExamArgs<ExtArgs>
    _count?: boolean | QAPairCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QAPairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QAPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QAPair"
    objects: {
      tags: Prisma.$TagPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      practiceExam: Prisma.$PracticeExamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      description: string | null
      secondaryLabel: string | null
      correctCount: number
      inCorrectCount: number
    }, ExtArgs["result"]["qAPair"]>
    composites: {}
  }

  type QAPairGetPayload<S extends boolean | null | undefined | QAPairDefaultArgs> = $Result.GetResult<Prisma.$QAPairPayload, S>

  type QAPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QAPairFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QAPairCountAggregateInputType | true
    }

  export interface QAPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QAPair'], meta: { name: 'QAPair' } }
    /**
     * Find zero or one QAPair that matches the filter.
     * @param {QAPairFindUniqueArgs} args - Arguments to find a QAPair
     * @example
     * // Get one QAPair
     * const qAPair = await prisma.qAPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QAPairFindUniqueArgs>(args: SelectSubset<T, QAPairFindUniqueArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QAPair that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QAPairFindUniqueOrThrowArgs} args - Arguments to find a QAPair
     * @example
     * // Get one QAPair
     * const qAPair = await prisma.qAPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QAPairFindUniqueOrThrowArgs>(args: SelectSubset<T, QAPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QAPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairFindFirstArgs} args - Arguments to find a QAPair
     * @example
     * // Get one QAPair
     * const qAPair = await prisma.qAPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QAPairFindFirstArgs>(args?: SelectSubset<T, QAPairFindFirstArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QAPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairFindFirstOrThrowArgs} args - Arguments to find a QAPair
     * @example
     * // Get one QAPair
     * const qAPair = await prisma.qAPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QAPairFindFirstOrThrowArgs>(args?: SelectSubset<T, QAPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QAPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QAPairs
     * const qAPairs = await prisma.qAPair.findMany()
     * 
     * // Get first 10 QAPairs
     * const qAPairs = await prisma.qAPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qAPairWithIdOnly = await prisma.qAPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QAPairFindManyArgs>(args?: SelectSubset<T, QAPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QAPair.
     * @param {QAPairCreateArgs} args - Arguments to create a QAPair.
     * @example
     * // Create one QAPair
     * const QAPair = await prisma.qAPair.create({
     *   data: {
     *     // ... data to create a QAPair
     *   }
     * })
     * 
     */
    create<T extends QAPairCreateArgs>(args: SelectSubset<T, QAPairCreateArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QAPairs.
     * @param {QAPairCreateManyArgs} args - Arguments to create many QAPairs.
     * @example
     * // Create many QAPairs
     * const qAPair = await prisma.qAPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QAPairCreateManyArgs>(args?: SelectSubset<T, QAPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QAPairs and returns the data saved in the database.
     * @param {QAPairCreateManyAndReturnArgs} args - Arguments to create many QAPairs.
     * @example
     * // Create many QAPairs
     * const qAPair = await prisma.qAPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QAPairs and only return the `id`
     * const qAPairWithIdOnly = await prisma.qAPair.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QAPairCreateManyAndReturnArgs>(args?: SelectSubset<T, QAPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QAPair.
     * @param {QAPairDeleteArgs} args - Arguments to delete one QAPair.
     * @example
     * // Delete one QAPair
     * const QAPair = await prisma.qAPair.delete({
     *   where: {
     *     // ... filter to delete one QAPair
     *   }
     * })
     * 
     */
    delete<T extends QAPairDeleteArgs>(args: SelectSubset<T, QAPairDeleteArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QAPair.
     * @param {QAPairUpdateArgs} args - Arguments to update one QAPair.
     * @example
     * // Update one QAPair
     * const qAPair = await prisma.qAPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QAPairUpdateArgs>(args: SelectSubset<T, QAPairUpdateArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QAPairs.
     * @param {QAPairDeleteManyArgs} args - Arguments to filter QAPairs to delete.
     * @example
     * // Delete a few QAPairs
     * const { count } = await prisma.qAPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QAPairDeleteManyArgs>(args?: SelectSubset<T, QAPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QAPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QAPairs
     * const qAPair = await prisma.qAPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QAPairUpdateManyArgs>(args: SelectSubset<T, QAPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QAPair.
     * @param {QAPairUpsertArgs} args - Arguments to update or create a QAPair.
     * @example
     * // Update or create a QAPair
     * const qAPair = await prisma.qAPair.upsert({
     *   create: {
     *     // ... data to create a QAPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QAPair we want to update
     *   }
     * })
     */
    upsert<T extends QAPairUpsertArgs>(args: SelectSubset<T, QAPairUpsertArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QAPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairCountArgs} args - Arguments to filter QAPairs to count.
     * @example
     * // Count the number of QAPairs
     * const count = await prisma.qAPair.count({
     *   where: {
     *     // ... the filter for the QAPairs we want to count
     *   }
     * })
    **/
    count<T extends QAPairCountArgs>(
      args?: Subset<T, QAPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QAPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QAPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QAPairAggregateArgs>(args: Subset<T, QAPairAggregateArgs>): Prisma.PrismaPromise<GetQAPairAggregateType<T>>

    /**
     * Group by QAPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QAPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QAPairGroupByArgs['orderBy'] }
        : { orderBy?: QAPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QAPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQAPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QAPair model
   */
  readonly fields: QAPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QAPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QAPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tags<T extends QAPair$tagsArgs<ExtArgs> = {}>(args?: Subset<T, QAPair$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    topics<T extends QAPair$topicsArgs<ExtArgs> = {}>(args?: Subset<T, QAPair$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends QAPair$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, QAPair$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    practiceExam<T extends QAPair$practiceExamArgs<ExtArgs> = {}>(args?: Subset<T, QAPair$practiceExamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QAPair model
   */ 
  interface QAPairFieldRefs {
    readonly id: FieldRef<"QAPair", 'String'>
    readonly question: FieldRef<"QAPair", 'String'>
    readonly answer: FieldRef<"QAPair", 'String'>
    readonly description: FieldRef<"QAPair", 'String'>
    readonly secondaryLabel: FieldRef<"QAPair", 'String'>
    readonly correctCount: FieldRef<"QAPair", 'Int'>
    readonly inCorrectCount: FieldRef<"QAPair", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QAPair findUnique
   */
  export type QAPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPair to fetch.
     */
    where: QAPairWhereUniqueInput
  }

  /**
   * QAPair findUniqueOrThrow
   */
  export type QAPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPair to fetch.
     */
    where: QAPairWhereUniqueInput
  }

  /**
   * QAPair findFirst
   */
  export type QAPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPair to fetch.
     */
    where?: QAPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAPairs to fetch.
     */
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QAPairs.
     */
    cursor?: QAPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QAPairs.
     */
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * QAPair findFirstOrThrow
   */
  export type QAPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPair to fetch.
     */
    where?: QAPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAPairs to fetch.
     */
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QAPairs.
     */
    cursor?: QAPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QAPairs.
     */
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * QAPair findMany
   */
  export type QAPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPairs to fetch.
     */
    where?: QAPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAPairs to fetch.
     */
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QAPairs.
     */
    cursor?: QAPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAPairs.
     */
    skip?: number
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * QAPair create
   */
  export type QAPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * The data needed to create a QAPair.
     */
    data: XOR<QAPairCreateInput, QAPairUncheckedCreateInput>
  }

  /**
   * QAPair createMany
   */
  export type QAPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QAPairs.
     */
    data: QAPairCreateManyInput | QAPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QAPair createManyAndReturn
   */
  export type QAPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QAPairs.
     */
    data: QAPairCreateManyInput | QAPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QAPair update
   */
  export type QAPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * The data needed to update a QAPair.
     */
    data: XOR<QAPairUpdateInput, QAPairUncheckedUpdateInput>
    /**
     * Choose, which QAPair to update.
     */
    where: QAPairWhereUniqueInput
  }

  /**
   * QAPair updateMany
   */
  export type QAPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QAPairs.
     */
    data: XOR<QAPairUpdateManyMutationInput, QAPairUncheckedUpdateManyInput>
    /**
     * Filter which QAPairs to update
     */
    where?: QAPairWhereInput
  }

  /**
   * QAPair upsert
   */
  export type QAPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * The filter to search for the QAPair to update in case it exists.
     */
    where: QAPairWhereUniqueInput
    /**
     * In case the QAPair found by the `where` argument doesn't exist, create a new QAPair with this data.
     */
    create: XOR<QAPairCreateInput, QAPairUncheckedCreateInput>
    /**
     * In case the QAPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QAPairUpdateInput, QAPairUncheckedUpdateInput>
  }

  /**
   * QAPair delete
   */
  export type QAPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter which QAPair to delete.
     */
    where: QAPairWhereUniqueInput
  }

  /**
   * QAPair deleteMany
   */
  export type QAPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QAPairs to delete
     */
    where?: QAPairWhereInput
  }

  /**
   * QAPair.tags
   */
  export type QAPair$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * QAPair.topics
   */
  export type QAPair$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * QAPair.subjects
   */
  export type QAPair$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * QAPair.practiceExam
   */
  export type QAPair$practiceExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    where?: PracticeExamWhereInput
    orderBy?: PracticeExamOrderByWithRelationInput | PracticeExamOrderByWithRelationInput[]
    cursor?: PracticeExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PracticeExamScalarFieldEnum | PracticeExamScalarFieldEnum[]
  }

  /**
   * QAPair without action
   */
  export type QAPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
  }


  /**
   * Model PracticeExam
   */

  export type AggregatePracticeExam = {
    _count: PracticeExamCountAggregateOutputType | null
    _avg: PracticeExamAvgAggregateOutputType | null
    _sum: PracticeExamSumAggregateOutputType | null
    _min: PracticeExamMinAggregateOutputType | null
    _max: PracticeExamMaxAggregateOutputType | null
  }

  export type PracticeExamAvgAggregateOutputType = {
    id: number | null
    correctCount: number | null
    inCorrectCount: number | null
    timeLimitInSeconds: number | null
    timeCompletedInSeconds: number | null
  }

  export type PracticeExamSumAggregateOutputType = {
    id: number | null
    correctCount: number | null
    inCorrectCount: number | null
    timeLimitInSeconds: number | null
    timeCompletedInSeconds: number | null
  }

  export type PracticeExamMinAggregateOutputType = {
    id: number | null
    correctCount: number | null
    inCorrectCount: number | null
    timeLimitInSeconds: number | null
    timeCompletedInSeconds: number | null
    date: Date | null
  }

  export type PracticeExamMaxAggregateOutputType = {
    id: number | null
    correctCount: number | null
    inCorrectCount: number | null
    timeLimitInSeconds: number | null
    timeCompletedInSeconds: number | null
    date: Date | null
  }

  export type PracticeExamCountAggregateOutputType = {
    id: number
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date: number
    _all: number
  }


  export type PracticeExamAvgAggregateInputType = {
    id?: true
    correctCount?: true
    inCorrectCount?: true
    timeLimitInSeconds?: true
    timeCompletedInSeconds?: true
  }

  export type PracticeExamSumAggregateInputType = {
    id?: true
    correctCount?: true
    inCorrectCount?: true
    timeLimitInSeconds?: true
    timeCompletedInSeconds?: true
  }

  export type PracticeExamMinAggregateInputType = {
    id?: true
    correctCount?: true
    inCorrectCount?: true
    timeLimitInSeconds?: true
    timeCompletedInSeconds?: true
    date?: true
  }

  export type PracticeExamMaxAggregateInputType = {
    id?: true
    correctCount?: true
    inCorrectCount?: true
    timeLimitInSeconds?: true
    timeCompletedInSeconds?: true
    date?: true
  }

  export type PracticeExamCountAggregateInputType = {
    id?: true
    correctCount?: true
    inCorrectCount?: true
    timeLimitInSeconds?: true
    timeCompletedInSeconds?: true
    date?: true
    _all?: true
  }

  export type PracticeExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticeExam to aggregate.
     */
    where?: PracticeExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeExams to fetch.
     */
    orderBy?: PracticeExamOrderByWithRelationInput | PracticeExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PracticeExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PracticeExams
    **/
    _count?: true | PracticeExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PracticeExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PracticeExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PracticeExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PracticeExamMaxAggregateInputType
  }

  export type GetPracticeExamAggregateType<T extends PracticeExamAggregateArgs> = {
        [P in keyof T & keyof AggregatePracticeExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePracticeExam[P]>
      : GetScalarType<T[P], AggregatePracticeExam[P]>
  }




  export type PracticeExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeExamWhereInput
    orderBy?: PracticeExamOrderByWithAggregationInput | PracticeExamOrderByWithAggregationInput[]
    by: PracticeExamScalarFieldEnum[] | PracticeExamScalarFieldEnum
    having?: PracticeExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PracticeExamCountAggregateInputType | true
    _avg?: PracticeExamAvgAggregateInputType
    _sum?: PracticeExamSumAggregateInputType
    _min?: PracticeExamMinAggregateInputType
    _max?: PracticeExamMaxAggregateInputType
  }

  export type PracticeExamGroupByOutputType = {
    id: number
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date: Date
    _count: PracticeExamCountAggregateOutputType | null
    _avg: PracticeExamAvgAggregateOutputType | null
    _sum: PracticeExamSumAggregateOutputType | null
    _min: PracticeExamMinAggregateOutputType | null
    _max: PracticeExamMaxAggregateOutputType | null
  }

  type GetPracticeExamGroupByPayload<T extends PracticeExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PracticeExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PracticeExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PracticeExamGroupByOutputType[P]>
            : GetScalarType<T[P], PracticeExamGroupByOutputType[P]>
        }
      >
    >


  export type PracticeExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correctCount?: boolean
    inCorrectCount?: boolean
    timeLimitInSeconds?: boolean
    timeCompletedInSeconds?: boolean
    date?: boolean
    topics?: boolean | PracticeExam$topicsArgs<ExtArgs>
    tags?: boolean | PracticeExam$tagsArgs<ExtArgs>
    subjects?: boolean | PracticeExam$subjectsArgs<ExtArgs>
    questions?: boolean | PracticeExam$questionsArgs<ExtArgs>
    _count?: boolean | PracticeExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practiceExam"]>

  export type PracticeExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correctCount?: boolean
    inCorrectCount?: boolean
    timeLimitInSeconds?: boolean
    timeCompletedInSeconds?: boolean
    date?: boolean
  }, ExtArgs["result"]["practiceExam"]>

  export type PracticeExamSelectScalar = {
    id?: boolean
    correctCount?: boolean
    inCorrectCount?: boolean
    timeLimitInSeconds?: boolean
    timeCompletedInSeconds?: boolean
    date?: boolean
  }

  export type PracticeExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | PracticeExam$topicsArgs<ExtArgs>
    tags?: boolean | PracticeExam$tagsArgs<ExtArgs>
    subjects?: boolean | PracticeExam$subjectsArgs<ExtArgs>
    questions?: boolean | PracticeExam$questionsArgs<ExtArgs>
    _count?: boolean | PracticeExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PracticeExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PracticeExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PracticeExam"
    objects: {
      topics: Prisma.$TopicPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      questions: Prisma.$QAPairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      correctCount: number
      inCorrectCount: number
      timeLimitInSeconds: number
      timeCompletedInSeconds: number
      date: Date
    }, ExtArgs["result"]["practiceExam"]>
    composites: {}
  }

  type PracticeExamGetPayload<S extends boolean | null | undefined | PracticeExamDefaultArgs> = $Result.GetResult<Prisma.$PracticeExamPayload, S>

  type PracticeExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PracticeExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PracticeExamCountAggregateInputType | true
    }

  export interface PracticeExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PracticeExam'], meta: { name: 'PracticeExam' } }
    /**
     * Find zero or one PracticeExam that matches the filter.
     * @param {PracticeExamFindUniqueArgs} args - Arguments to find a PracticeExam
     * @example
     * // Get one PracticeExam
     * const practiceExam = await prisma.practiceExam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PracticeExamFindUniqueArgs>(args: SelectSubset<T, PracticeExamFindUniqueArgs<ExtArgs>>): Prisma__PracticeExamClient<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PracticeExam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PracticeExamFindUniqueOrThrowArgs} args - Arguments to find a PracticeExam
     * @example
     * // Get one PracticeExam
     * const practiceExam = await prisma.practiceExam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PracticeExamFindUniqueOrThrowArgs>(args: SelectSubset<T, PracticeExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PracticeExamClient<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PracticeExam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeExamFindFirstArgs} args - Arguments to find a PracticeExam
     * @example
     * // Get one PracticeExam
     * const practiceExam = await prisma.practiceExam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PracticeExamFindFirstArgs>(args?: SelectSubset<T, PracticeExamFindFirstArgs<ExtArgs>>): Prisma__PracticeExamClient<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PracticeExam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeExamFindFirstOrThrowArgs} args - Arguments to find a PracticeExam
     * @example
     * // Get one PracticeExam
     * const practiceExam = await prisma.practiceExam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PracticeExamFindFirstOrThrowArgs>(args?: SelectSubset<T, PracticeExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__PracticeExamClient<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PracticeExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PracticeExams
     * const practiceExams = await prisma.practiceExam.findMany()
     * 
     * // Get first 10 PracticeExams
     * const practiceExams = await prisma.practiceExam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practiceExamWithIdOnly = await prisma.practiceExam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PracticeExamFindManyArgs>(args?: SelectSubset<T, PracticeExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PracticeExam.
     * @param {PracticeExamCreateArgs} args - Arguments to create a PracticeExam.
     * @example
     * // Create one PracticeExam
     * const PracticeExam = await prisma.practiceExam.create({
     *   data: {
     *     // ... data to create a PracticeExam
     *   }
     * })
     * 
     */
    create<T extends PracticeExamCreateArgs>(args: SelectSubset<T, PracticeExamCreateArgs<ExtArgs>>): Prisma__PracticeExamClient<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PracticeExams.
     * @param {PracticeExamCreateManyArgs} args - Arguments to create many PracticeExams.
     * @example
     * // Create many PracticeExams
     * const practiceExam = await prisma.practiceExam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PracticeExamCreateManyArgs>(args?: SelectSubset<T, PracticeExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PracticeExams and returns the data saved in the database.
     * @param {PracticeExamCreateManyAndReturnArgs} args - Arguments to create many PracticeExams.
     * @example
     * // Create many PracticeExams
     * const practiceExam = await prisma.practiceExam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PracticeExams and only return the `id`
     * const practiceExamWithIdOnly = await prisma.practiceExam.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PracticeExamCreateManyAndReturnArgs>(args?: SelectSubset<T, PracticeExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PracticeExam.
     * @param {PracticeExamDeleteArgs} args - Arguments to delete one PracticeExam.
     * @example
     * // Delete one PracticeExam
     * const PracticeExam = await prisma.practiceExam.delete({
     *   where: {
     *     // ... filter to delete one PracticeExam
     *   }
     * })
     * 
     */
    delete<T extends PracticeExamDeleteArgs>(args: SelectSubset<T, PracticeExamDeleteArgs<ExtArgs>>): Prisma__PracticeExamClient<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PracticeExam.
     * @param {PracticeExamUpdateArgs} args - Arguments to update one PracticeExam.
     * @example
     * // Update one PracticeExam
     * const practiceExam = await prisma.practiceExam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PracticeExamUpdateArgs>(args: SelectSubset<T, PracticeExamUpdateArgs<ExtArgs>>): Prisma__PracticeExamClient<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PracticeExams.
     * @param {PracticeExamDeleteManyArgs} args - Arguments to filter PracticeExams to delete.
     * @example
     * // Delete a few PracticeExams
     * const { count } = await prisma.practiceExam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PracticeExamDeleteManyArgs>(args?: SelectSubset<T, PracticeExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticeExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PracticeExams
     * const practiceExam = await prisma.practiceExam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PracticeExamUpdateManyArgs>(args: SelectSubset<T, PracticeExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PracticeExam.
     * @param {PracticeExamUpsertArgs} args - Arguments to update or create a PracticeExam.
     * @example
     * // Update or create a PracticeExam
     * const practiceExam = await prisma.practiceExam.upsert({
     *   create: {
     *     // ... data to create a PracticeExam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PracticeExam we want to update
     *   }
     * })
     */
    upsert<T extends PracticeExamUpsertArgs>(args: SelectSubset<T, PracticeExamUpsertArgs<ExtArgs>>): Prisma__PracticeExamClient<$Result.GetResult<Prisma.$PracticeExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PracticeExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeExamCountArgs} args - Arguments to filter PracticeExams to count.
     * @example
     * // Count the number of PracticeExams
     * const count = await prisma.practiceExam.count({
     *   where: {
     *     // ... the filter for the PracticeExams we want to count
     *   }
     * })
    **/
    count<T extends PracticeExamCountArgs>(
      args?: Subset<T, PracticeExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PracticeExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PracticeExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PracticeExamAggregateArgs>(args: Subset<T, PracticeExamAggregateArgs>): Prisma.PrismaPromise<GetPracticeExamAggregateType<T>>

    /**
     * Group by PracticeExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PracticeExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PracticeExamGroupByArgs['orderBy'] }
        : { orderBy?: PracticeExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PracticeExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPracticeExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PracticeExam model
   */
  readonly fields: PracticeExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PracticeExam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PracticeExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topics<T extends PracticeExam$topicsArgs<ExtArgs> = {}>(args?: Subset<T, PracticeExam$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends PracticeExam$tagsArgs<ExtArgs> = {}>(args?: Subset<T, PracticeExam$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends PracticeExam$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, PracticeExam$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    questions<T extends PracticeExam$questionsArgs<ExtArgs> = {}>(args?: Subset<T, PracticeExam$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PracticeExam model
   */ 
  interface PracticeExamFieldRefs {
    readonly id: FieldRef<"PracticeExam", 'Int'>
    readonly correctCount: FieldRef<"PracticeExam", 'Int'>
    readonly inCorrectCount: FieldRef<"PracticeExam", 'Int'>
    readonly timeLimitInSeconds: FieldRef<"PracticeExam", 'Int'>
    readonly timeCompletedInSeconds: FieldRef<"PracticeExam", 'Int'>
    readonly date: FieldRef<"PracticeExam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PracticeExam findUnique
   */
  export type PracticeExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * Filter, which PracticeExam to fetch.
     */
    where: PracticeExamWhereUniqueInput
  }

  /**
   * PracticeExam findUniqueOrThrow
   */
  export type PracticeExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * Filter, which PracticeExam to fetch.
     */
    where: PracticeExamWhereUniqueInput
  }

  /**
   * PracticeExam findFirst
   */
  export type PracticeExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * Filter, which PracticeExam to fetch.
     */
    where?: PracticeExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeExams to fetch.
     */
    orderBy?: PracticeExamOrderByWithRelationInput | PracticeExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticeExams.
     */
    cursor?: PracticeExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticeExams.
     */
    distinct?: PracticeExamScalarFieldEnum | PracticeExamScalarFieldEnum[]
  }

  /**
   * PracticeExam findFirstOrThrow
   */
  export type PracticeExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * Filter, which PracticeExam to fetch.
     */
    where?: PracticeExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeExams to fetch.
     */
    orderBy?: PracticeExamOrderByWithRelationInput | PracticeExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticeExams.
     */
    cursor?: PracticeExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticeExams.
     */
    distinct?: PracticeExamScalarFieldEnum | PracticeExamScalarFieldEnum[]
  }

  /**
   * PracticeExam findMany
   */
  export type PracticeExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * Filter, which PracticeExams to fetch.
     */
    where?: PracticeExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeExams to fetch.
     */
    orderBy?: PracticeExamOrderByWithRelationInput | PracticeExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PracticeExams.
     */
    cursor?: PracticeExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeExams.
     */
    skip?: number
    distinct?: PracticeExamScalarFieldEnum | PracticeExamScalarFieldEnum[]
  }

  /**
   * PracticeExam create
   */
  export type PracticeExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * The data needed to create a PracticeExam.
     */
    data: XOR<PracticeExamCreateInput, PracticeExamUncheckedCreateInput>
  }

  /**
   * PracticeExam createMany
   */
  export type PracticeExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PracticeExams.
     */
    data: PracticeExamCreateManyInput | PracticeExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PracticeExam createManyAndReturn
   */
  export type PracticeExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PracticeExams.
     */
    data: PracticeExamCreateManyInput | PracticeExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PracticeExam update
   */
  export type PracticeExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * The data needed to update a PracticeExam.
     */
    data: XOR<PracticeExamUpdateInput, PracticeExamUncheckedUpdateInput>
    /**
     * Choose, which PracticeExam to update.
     */
    where: PracticeExamWhereUniqueInput
  }

  /**
   * PracticeExam updateMany
   */
  export type PracticeExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PracticeExams.
     */
    data: XOR<PracticeExamUpdateManyMutationInput, PracticeExamUncheckedUpdateManyInput>
    /**
     * Filter which PracticeExams to update
     */
    where?: PracticeExamWhereInput
  }

  /**
   * PracticeExam upsert
   */
  export type PracticeExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * The filter to search for the PracticeExam to update in case it exists.
     */
    where: PracticeExamWhereUniqueInput
    /**
     * In case the PracticeExam found by the `where` argument doesn't exist, create a new PracticeExam with this data.
     */
    create: XOR<PracticeExamCreateInput, PracticeExamUncheckedCreateInput>
    /**
     * In case the PracticeExam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PracticeExamUpdateInput, PracticeExamUncheckedUpdateInput>
  }

  /**
   * PracticeExam delete
   */
  export type PracticeExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
    /**
     * Filter which PracticeExam to delete.
     */
    where: PracticeExamWhereUniqueInput
  }

  /**
   * PracticeExam deleteMany
   */
  export type PracticeExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticeExams to delete
     */
    where?: PracticeExamWhereInput
  }

  /**
   * PracticeExam.topics
   */
  export type PracticeExam$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * PracticeExam.tags
   */
  export type PracticeExam$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * PracticeExam.subjects
   */
  export type PracticeExam$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * PracticeExam.questions
   */
  export type PracticeExam$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    where?: QAPairWhereInput
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    cursor?: QAPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * PracticeExam without action
   */
  export type PracticeExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeExam
     */
    select?: PracticeExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeExamInclude<ExtArgs> | null
  }


  /**
   * Model SequentialNoteList
   */

  export type AggregateSequentialNoteList = {
    _count: SequentialNoteListCountAggregateOutputType | null
    _min: SequentialNoteListMinAggregateOutputType | null
    _max: SequentialNoteListMaxAggregateOutputType | null
  }

  export type SequentialNoteListMinAggregateOutputType = {
    sequentialKey: string | null
  }

  export type SequentialNoteListMaxAggregateOutputType = {
    sequentialKey: string | null
  }

  export type SequentialNoteListCountAggregateOutputType = {
    sequentialKey: number
    _all: number
  }


  export type SequentialNoteListMinAggregateInputType = {
    sequentialKey?: true
  }

  export type SequentialNoteListMaxAggregateInputType = {
    sequentialKey?: true
  }

  export type SequentialNoteListCountAggregateInputType = {
    sequentialKey?: true
    _all?: true
  }

  export type SequentialNoteListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SequentialNoteList to aggregate.
     */
    where?: SequentialNoteListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequentialNoteLists to fetch.
     */
    orderBy?: SequentialNoteListOrderByWithRelationInput | SequentialNoteListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SequentialNoteListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequentialNoteLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequentialNoteLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SequentialNoteLists
    **/
    _count?: true | SequentialNoteListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SequentialNoteListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SequentialNoteListMaxAggregateInputType
  }

  export type GetSequentialNoteListAggregateType<T extends SequentialNoteListAggregateArgs> = {
        [P in keyof T & keyof AggregateSequentialNoteList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSequentialNoteList[P]>
      : GetScalarType<T[P], AggregateSequentialNoteList[P]>
  }




  export type SequentialNoteListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SequentialNoteListWhereInput
    orderBy?: SequentialNoteListOrderByWithAggregationInput | SequentialNoteListOrderByWithAggregationInput[]
    by: SequentialNoteListScalarFieldEnum[] | SequentialNoteListScalarFieldEnum
    having?: SequentialNoteListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SequentialNoteListCountAggregateInputType | true
    _min?: SequentialNoteListMinAggregateInputType
    _max?: SequentialNoteListMaxAggregateInputType
  }

  export type SequentialNoteListGroupByOutputType = {
    sequentialKey: string
    _count: SequentialNoteListCountAggregateOutputType | null
    _min: SequentialNoteListMinAggregateOutputType | null
    _max: SequentialNoteListMaxAggregateOutputType | null
  }

  type GetSequentialNoteListGroupByPayload<T extends SequentialNoteListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SequentialNoteListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SequentialNoteListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SequentialNoteListGroupByOutputType[P]>
            : GetScalarType<T[P], SequentialNoteListGroupByOutputType[P]>
        }
      >
    >


  export type SequentialNoteListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sequentialKey?: boolean
    MdxNote?: boolean | SequentialNoteList$MdxNoteArgs<ExtArgs>
    Ipynb?: boolean | SequentialNoteList$IpynbArgs<ExtArgs>
    _count?: boolean | SequentialNoteListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sequentialNoteList"]>

  export type SequentialNoteListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sequentialKey?: boolean
  }, ExtArgs["result"]["sequentialNoteList"]>

  export type SequentialNoteListSelectScalar = {
    sequentialKey?: boolean
  }

  export type SequentialNoteListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MdxNote?: boolean | SequentialNoteList$MdxNoteArgs<ExtArgs>
    Ipynb?: boolean | SequentialNoteList$IpynbArgs<ExtArgs>
    _count?: boolean | SequentialNoteListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SequentialNoteListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SequentialNoteListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SequentialNoteList"
    objects: {
      MdxNote: Prisma.$MdxNotePayload<ExtArgs>[]
      Ipynb: Prisma.$IpynbPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      sequentialKey: string
    }, ExtArgs["result"]["sequentialNoteList"]>
    composites: {}
  }

  type SequentialNoteListGetPayload<S extends boolean | null | undefined | SequentialNoteListDefaultArgs> = $Result.GetResult<Prisma.$SequentialNoteListPayload, S>

  type SequentialNoteListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SequentialNoteListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SequentialNoteListCountAggregateInputType | true
    }

  export interface SequentialNoteListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SequentialNoteList'], meta: { name: 'SequentialNoteList' } }
    /**
     * Find zero or one SequentialNoteList that matches the filter.
     * @param {SequentialNoteListFindUniqueArgs} args - Arguments to find a SequentialNoteList
     * @example
     * // Get one SequentialNoteList
     * const sequentialNoteList = await prisma.sequentialNoteList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SequentialNoteListFindUniqueArgs>(args: SelectSubset<T, SequentialNoteListFindUniqueArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SequentialNoteList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SequentialNoteListFindUniqueOrThrowArgs} args - Arguments to find a SequentialNoteList
     * @example
     * // Get one SequentialNoteList
     * const sequentialNoteList = await prisma.sequentialNoteList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SequentialNoteListFindUniqueOrThrowArgs>(args: SelectSubset<T, SequentialNoteListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SequentialNoteList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequentialNoteListFindFirstArgs} args - Arguments to find a SequentialNoteList
     * @example
     * // Get one SequentialNoteList
     * const sequentialNoteList = await prisma.sequentialNoteList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SequentialNoteListFindFirstArgs>(args?: SelectSubset<T, SequentialNoteListFindFirstArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SequentialNoteList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequentialNoteListFindFirstOrThrowArgs} args - Arguments to find a SequentialNoteList
     * @example
     * // Get one SequentialNoteList
     * const sequentialNoteList = await prisma.sequentialNoteList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SequentialNoteListFindFirstOrThrowArgs>(args?: SelectSubset<T, SequentialNoteListFindFirstOrThrowArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SequentialNoteLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequentialNoteListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SequentialNoteLists
     * const sequentialNoteLists = await prisma.sequentialNoteList.findMany()
     * 
     * // Get first 10 SequentialNoteLists
     * const sequentialNoteLists = await prisma.sequentialNoteList.findMany({ take: 10 })
     * 
     * // Only select the `sequentialKey`
     * const sequentialNoteListWithSequentialKeyOnly = await prisma.sequentialNoteList.findMany({ select: { sequentialKey: true } })
     * 
     */
    findMany<T extends SequentialNoteListFindManyArgs>(args?: SelectSubset<T, SequentialNoteListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SequentialNoteList.
     * @param {SequentialNoteListCreateArgs} args - Arguments to create a SequentialNoteList.
     * @example
     * // Create one SequentialNoteList
     * const SequentialNoteList = await prisma.sequentialNoteList.create({
     *   data: {
     *     // ... data to create a SequentialNoteList
     *   }
     * })
     * 
     */
    create<T extends SequentialNoteListCreateArgs>(args: SelectSubset<T, SequentialNoteListCreateArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SequentialNoteLists.
     * @param {SequentialNoteListCreateManyArgs} args - Arguments to create many SequentialNoteLists.
     * @example
     * // Create many SequentialNoteLists
     * const sequentialNoteList = await prisma.sequentialNoteList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SequentialNoteListCreateManyArgs>(args?: SelectSubset<T, SequentialNoteListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SequentialNoteLists and returns the data saved in the database.
     * @param {SequentialNoteListCreateManyAndReturnArgs} args - Arguments to create many SequentialNoteLists.
     * @example
     * // Create many SequentialNoteLists
     * const sequentialNoteList = await prisma.sequentialNoteList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SequentialNoteLists and only return the `sequentialKey`
     * const sequentialNoteListWithSequentialKeyOnly = await prisma.sequentialNoteList.createManyAndReturn({ 
     *   select: { sequentialKey: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SequentialNoteListCreateManyAndReturnArgs>(args?: SelectSubset<T, SequentialNoteListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SequentialNoteList.
     * @param {SequentialNoteListDeleteArgs} args - Arguments to delete one SequentialNoteList.
     * @example
     * // Delete one SequentialNoteList
     * const SequentialNoteList = await prisma.sequentialNoteList.delete({
     *   where: {
     *     // ... filter to delete one SequentialNoteList
     *   }
     * })
     * 
     */
    delete<T extends SequentialNoteListDeleteArgs>(args: SelectSubset<T, SequentialNoteListDeleteArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SequentialNoteList.
     * @param {SequentialNoteListUpdateArgs} args - Arguments to update one SequentialNoteList.
     * @example
     * // Update one SequentialNoteList
     * const sequentialNoteList = await prisma.sequentialNoteList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SequentialNoteListUpdateArgs>(args: SelectSubset<T, SequentialNoteListUpdateArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SequentialNoteLists.
     * @param {SequentialNoteListDeleteManyArgs} args - Arguments to filter SequentialNoteLists to delete.
     * @example
     * // Delete a few SequentialNoteLists
     * const { count } = await prisma.sequentialNoteList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SequentialNoteListDeleteManyArgs>(args?: SelectSubset<T, SequentialNoteListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SequentialNoteLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequentialNoteListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SequentialNoteLists
     * const sequentialNoteList = await prisma.sequentialNoteList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SequentialNoteListUpdateManyArgs>(args: SelectSubset<T, SequentialNoteListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SequentialNoteList.
     * @param {SequentialNoteListUpsertArgs} args - Arguments to update or create a SequentialNoteList.
     * @example
     * // Update or create a SequentialNoteList
     * const sequentialNoteList = await prisma.sequentialNoteList.upsert({
     *   create: {
     *     // ... data to create a SequentialNoteList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SequentialNoteList we want to update
     *   }
     * })
     */
    upsert<T extends SequentialNoteListUpsertArgs>(args: SelectSubset<T, SequentialNoteListUpsertArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SequentialNoteLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequentialNoteListCountArgs} args - Arguments to filter SequentialNoteLists to count.
     * @example
     * // Count the number of SequentialNoteLists
     * const count = await prisma.sequentialNoteList.count({
     *   where: {
     *     // ... the filter for the SequentialNoteLists we want to count
     *   }
     * })
    **/
    count<T extends SequentialNoteListCountArgs>(
      args?: Subset<T, SequentialNoteListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SequentialNoteListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SequentialNoteList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequentialNoteListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SequentialNoteListAggregateArgs>(args: Subset<T, SequentialNoteListAggregateArgs>): Prisma.PrismaPromise<GetSequentialNoteListAggregateType<T>>

    /**
     * Group by SequentialNoteList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequentialNoteListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SequentialNoteListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SequentialNoteListGroupByArgs['orderBy'] }
        : { orderBy?: SequentialNoteListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SequentialNoteListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSequentialNoteListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SequentialNoteList model
   */
  readonly fields: SequentialNoteListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SequentialNoteList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SequentialNoteListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MdxNote<T extends SequentialNoteList$MdxNoteArgs<ExtArgs> = {}>(args?: Subset<T, SequentialNoteList$MdxNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany"> | Null>
    Ipynb<T extends SequentialNoteList$IpynbArgs<ExtArgs> = {}>(args?: Subset<T, SequentialNoteList$IpynbArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SequentialNoteList model
   */ 
  interface SequentialNoteListFieldRefs {
    readonly sequentialKey: FieldRef<"SequentialNoteList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SequentialNoteList findUnique
   */
  export type SequentialNoteListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * Filter, which SequentialNoteList to fetch.
     */
    where: SequentialNoteListWhereUniqueInput
  }

  /**
   * SequentialNoteList findUniqueOrThrow
   */
  export type SequentialNoteListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * Filter, which SequentialNoteList to fetch.
     */
    where: SequentialNoteListWhereUniqueInput
  }

  /**
   * SequentialNoteList findFirst
   */
  export type SequentialNoteListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * Filter, which SequentialNoteList to fetch.
     */
    where?: SequentialNoteListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequentialNoteLists to fetch.
     */
    orderBy?: SequentialNoteListOrderByWithRelationInput | SequentialNoteListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequentialNoteLists.
     */
    cursor?: SequentialNoteListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequentialNoteLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequentialNoteLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequentialNoteLists.
     */
    distinct?: SequentialNoteListScalarFieldEnum | SequentialNoteListScalarFieldEnum[]
  }

  /**
   * SequentialNoteList findFirstOrThrow
   */
  export type SequentialNoteListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * Filter, which SequentialNoteList to fetch.
     */
    where?: SequentialNoteListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequentialNoteLists to fetch.
     */
    orderBy?: SequentialNoteListOrderByWithRelationInput | SequentialNoteListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequentialNoteLists.
     */
    cursor?: SequentialNoteListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequentialNoteLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequentialNoteLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequentialNoteLists.
     */
    distinct?: SequentialNoteListScalarFieldEnum | SequentialNoteListScalarFieldEnum[]
  }

  /**
   * SequentialNoteList findMany
   */
  export type SequentialNoteListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * Filter, which SequentialNoteLists to fetch.
     */
    where?: SequentialNoteListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequentialNoteLists to fetch.
     */
    orderBy?: SequentialNoteListOrderByWithRelationInput | SequentialNoteListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SequentialNoteLists.
     */
    cursor?: SequentialNoteListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequentialNoteLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequentialNoteLists.
     */
    skip?: number
    distinct?: SequentialNoteListScalarFieldEnum | SequentialNoteListScalarFieldEnum[]
  }

  /**
   * SequentialNoteList create
   */
  export type SequentialNoteListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * The data needed to create a SequentialNoteList.
     */
    data: XOR<SequentialNoteListCreateInput, SequentialNoteListUncheckedCreateInput>
  }

  /**
   * SequentialNoteList createMany
   */
  export type SequentialNoteListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SequentialNoteLists.
     */
    data: SequentialNoteListCreateManyInput | SequentialNoteListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SequentialNoteList createManyAndReturn
   */
  export type SequentialNoteListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SequentialNoteLists.
     */
    data: SequentialNoteListCreateManyInput | SequentialNoteListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SequentialNoteList update
   */
  export type SequentialNoteListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * The data needed to update a SequentialNoteList.
     */
    data: XOR<SequentialNoteListUpdateInput, SequentialNoteListUncheckedUpdateInput>
    /**
     * Choose, which SequentialNoteList to update.
     */
    where: SequentialNoteListWhereUniqueInput
  }

  /**
   * SequentialNoteList updateMany
   */
  export type SequentialNoteListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SequentialNoteLists.
     */
    data: XOR<SequentialNoteListUpdateManyMutationInput, SequentialNoteListUncheckedUpdateManyInput>
    /**
     * Filter which SequentialNoteLists to update
     */
    where?: SequentialNoteListWhereInput
  }

  /**
   * SequentialNoteList upsert
   */
  export type SequentialNoteListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * The filter to search for the SequentialNoteList to update in case it exists.
     */
    where: SequentialNoteListWhereUniqueInput
    /**
     * In case the SequentialNoteList found by the `where` argument doesn't exist, create a new SequentialNoteList with this data.
     */
    create: XOR<SequentialNoteListCreateInput, SequentialNoteListUncheckedCreateInput>
    /**
     * In case the SequentialNoteList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SequentialNoteListUpdateInput, SequentialNoteListUncheckedUpdateInput>
  }

  /**
   * SequentialNoteList delete
   */
  export type SequentialNoteListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    /**
     * Filter which SequentialNoteList to delete.
     */
    where: SequentialNoteListWhereUniqueInput
  }

  /**
   * SequentialNoteList deleteMany
   */
  export type SequentialNoteListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SequentialNoteLists to delete
     */
    where?: SequentialNoteListWhereInput
  }

  /**
   * SequentialNoteList.MdxNote
   */
  export type SequentialNoteList$MdxNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    cursor?: MdxNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * SequentialNoteList.Ipynb
   */
  export type SequentialNoteList$IpynbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    where?: IpynbWhereInput
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    cursor?: IpynbWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * SequentialNoteList without action
   */
  export type SequentialNoteListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
  }


  /**
   * Model MdxNote
   */

  export type AggregateMdxNote = {
    _count: MdxNoteCountAggregateOutputType | null
    _avg: MdxNoteAvgAggregateOutputType | null
    _sum: MdxNoteSumAggregateOutputType | null
    _min: MdxNoteMinAggregateOutputType | null
    _max: MdxNoteMaxAggregateOutputType | null
  }

  export type MdxNoteAvgAggregateOutputType = {
    id: number | null
    importantValues: number | null
    sequentialIndex: number | null
  }

  export type MdxNoteSumAggregateOutputType = {
    id: number | null
    importantValues: number[]
    sequentialIndex: number | null
  }

  export type MdxNoteMinAggregateOutputType = {
    id: number | null
    isProtected: boolean | null
    dietSummaryKey: string | null
    title: string | null
    latexTitle: string | null
    rootRelativePath: string | null
    noteType: string | null
    content: string | null
    formatted: string | null
    summary: string | null
    imageSrc: string | null
    href: string | null
    sequentialKey: string | null
    sequentialIndex: number | null
    floatImages: boolean | null
    remoteUrl: string | null
    trackRemote: boolean | null
    quickLink: string | null
    bookmarked: boolean | null
    firstSync: Date | null
    lastSync: Date | null
  }

  export type MdxNoteMaxAggregateOutputType = {
    id: number | null
    isProtected: boolean | null
    dietSummaryKey: string | null
    title: string | null
    latexTitle: string | null
    rootRelativePath: string | null
    noteType: string | null
    content: string | null
    formatted: string | null
    summary: string | null
    imageSrc: string | null
    href: string | null
    sequentialKey: string | null
    sequentialIndex: number | null
    floatImages: boolean | null
    remoteUrl: string | null
    trackRemote: boolean | null
    quickLink: string | null
    bookmarked: boolean | null
    firstSync: Date | null
    lastSync: Date | null
  }

  export type MdxNoteCountAggregateOutputType = {
    id: number
    isProtected: number
    dietSummaryKey: number
    title: number
    latexTitle: number
    rootRelativePath: number
    noteType: number
    content: number
    formatted: number
    summary: number
    citationsListOrder: number
    importantValues: number
    imageSrc: number
    href: number
    sequentialKey: number
    sequentialIndex: number
    floatImages: number
    remoteUrl: number
    trackRemote: number
    outgoingQuickLinks: number
    quickLink: number
    bookmarked: number
    firstSync: number
    lastSync: number
    _all: number
  }


  export type MdxNoteAvgAggregateInputType = {
    id?: true
    importantValues?: true
    sequentialIndex?: true
  }

  export type MdxNoteSumAggregateInputType = {
    id?: true
    importantValues?: true
    sequentialIndex?: true
  }

  export type MdxNoteMinAggregateInputType = {
    id?: true
    isProtected?: true
    dietSummaryKey?: true
    title?: true
    latexTitle?: true
    rootRelativePath?: true
    noteType?: true
    content?: true
    formatted?: true
    summary?: true
    imageSrc?: true
    href?: true
    sequentialKey?: true
    sequentialIndex?: true
    floatImages?: true
    remoteUrl?: true
    trackRemote?: true
    quickLink?: true
    bookmarked?: true
    firstSync?: true
    lastSync?: true
  }

  export type MdxNoteMaxAggregateInputType = {
    id?: true
    isProtected?: true
    dietSummaryKey?: true
    title?: true
    latexTitle?: true
    rootRelativePath?: true
    noteType?: true
    content?: true
    formatted?: true
    summary?: true
    imageSrc?: true
    href?: true
    sequentialKey?: true
    sequentialIndex?: true
    floatImages?: true
    remoteUrl?: true
    trackRemote?: true
    quickLink?: true
    bookmarked?: true
    firstSync?: true
    lastSync?: true
  }

  export type MdxNoteCountAggregateInputType = {
    id?: true
    isProtected?: true
    dietSummaryKey?: true
    title?: true
    latexTitle?: true
    rootRelativePath?: true
    noteType?: true
    content?: true
    formatted?: true
    summary?: true
    citationsListOrder?: true
    importantValues?: true
    imageSrc?: true
    href?: true
    sequentialKey?: true
    sequentialIndex?: true
    floatImages?: true
    remoteUrl?: true
    trackRemote?: true
    outgoingQuickLinks?: true
    quickLink?: true
    bookmarked?: true
    firstSync?: true
    lastSync?: true
    _all?: true
  }

  export type MdxNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MdxNote to aggregate.
     */
    where?: MdxNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MdxNotes to fetch.
     */
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MdxNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MdxNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MdxNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MdxNotes
    **/
    _count?: true | MdxNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MdxNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MdxNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MdxNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MdxNoteMaxAggregateInputType
  }

  export type GetMdxNoteAggregateType<T extends MdxNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateMdxNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMdxNote[P]>
      : GetScalarType<T[P], AggregateMdxNote[P]>
  }




  export type MdxNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithAggregationInput | MdxNoteOrderByWithAggregationInput[]
    by: MdxNoteScalarFieldEnum[] | MdxNoteScalarFieldEnum
    having?: MdxNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MdxNoteCountAggregateInputType | true
    _avg?: MdxNoteAvgAggregateInputType
    _sum?: MdxNoteSumAggregateInputType
    _min?: MdxNoteMinAggregateInputType
    _max?: MdxNoteMaxAggregateInputType
  }

  export type MdxNoteGroupByOutputType = {
    id: number
    isProtected: boolean | null
    dietSummaryKey: string | null
    title: string
    latexTitle: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted: string | null
    summary: string | null
    citationsListOrder: string[]
    importantValues: number[]
    imageSrc: string | null
    href: string
    sequentialKey: string | null
    sequentialIndex: number | null
    floatImages: boolean
    remoteUrl: string | null
    trackRemote: boolean
    outgoingQuickLinks: string[]
    quickLink: string | null
    bookmarked: boolean
    firstSync: Date
    lastSync: Date
    _count: MdxNoteCountAggregateOutputType | null
    _avg: MdxNoteAvgAggregateOutputType | null
    _sum: MdxNoteSumAggregateOutputType | null
    _min: MdxNoteMinAggregateOutputType | null
    _max: MdxNoteMaxAggregateOutputType | null
  }

  type GetMdxNoteGroupByPayload<T extends MdxNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MdxNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MdxNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MdxNoteGroupByOutputType[P]>
            : GetScalarType<T[P], MdxNoteGroupByOutputType[P]>
        }
      >
    >


  export type MdxNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isProtected?: boolean
    dietSummaryKey?: boolean
    title?: boolean
    latexTitle?: boolean
    rootRelativePath?: boolean
    noteType?: boolean
    content?: boolean
    formatted?: boolean
    summary?: boolean
    citationsListOrder?: boolean
    importantValues?: boolean
    imageSrc?: boolean
    href?: boolean
    sequentialKey?: boolean
    sequentialIndex?: boolean
    floatImages?: boolean
    remoteUrl?: boolean
    trackRemote?: boolean
    outgoingQuickLinks?: boolean
    quickLink?: boolean
    bookmarked?: boolean
    firstSync?: boolean
    lastSync?: boolean
    topics?: boolean | MdxNote$topicsArgs<ExtArgs>
    subjects?: boolean | MdxNote$subjectsArgs<ExtArgs>
    tags?: boolean | MdxNote$tagsArgs<ExtArgs>
    citations?: boolean | MdxNote$citationsArgs<ExtArgs>
    sequentialList?: boolean | MdxNote$sequentialListArgs<ExtArgs>
    ReadingList?: boolean | MdxNote$ReadingListArgs<ExtArgs>
    equations?: boolean | MdxNote$equationsArgs<ExtArgs>
    definitions?: boolean | MdxNote$definitionsArgs<ExtArgs>
    toDo?: boolean | MdxNote$toDoArgs<ExtArgs>
    _count?: boolean | MdxNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mdxNote"]>

  export type MdxNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isProtected?: boolean
    dietSummaryKey?: boolean
    title?: boolean
    latexTitle?: boolean
    rootRelativePath?: boolean
    noteType?: boolean
    content?: boolean
    formatted?: boolean
    summary?: boolean
    citationsListOrder?: boolean
    importantValues?: boolean
    imageSrc?: boolean
    href?: boolean
    sequentialKey?: boolean
    sequentialIndex?: boolean
    floatImages?: boolean
    remoteUrl?: boolean
    trackRemote?: boolean
    outgoingQuickLinks?: boolean
    quickLink?: boolean
    bookmarked?: boolean
    firstSync?: boolean
    lastSync?: boolean
    sequentialList?: boolean | MdxNote$sequentialListArgs<ExtArgs>
  }, ExtArgs["result"]["mdxNote"]>

  export type MdxNoteSelectScalar = {
    id?: boolean
    isProtected?: boolean
    dietSummaryKey?: boolean
    title?: boolean
    latexTitle?: boolean
    rootRelativePath?: boolean
    noteType?: boolean
    content?: boolean
    formatted?: boolean
    summary?: boolean
    citationsListOrder?: boolean
    importantValues?: boolean
    imageSrc?: boolean
    href?: boolean
    sequentialKey?: boolean
    sequentialIndex?: boolean
    floatImages?: boolean
    remoteUrl?: boolean
    trackRemote?: boolean
    outgoingQuickLinks?: boolean
    quickLink?: boolean
    bookmarked?: boolean
    firstSync?: boolean
    lastSync?: boolean
  }

  export type MdxNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | MdxNote$topicsArgs<ExtArgs>
    subjects?: boolean | MdxNote$subjectsArgs<ExtArgs>
    tags?: boolean | MdxNote$tagsArgs<ExtArgs>
    citations?: boolean | MdxNote$citationsArgs<ExtArgs>
    sequentialList?: boolean | MdxNote$sequentialListArgs<ExtArgs>
    ReadingList?: boolean | MdxNote$ReadingListArgs<ExtArgs>
    equations?: boolean | MdxNote$equationsArgs<ExtArgs>
    definitions?: boolean | MdxNote$definitionsArgs<ExtArgs>
    toDo?: boolean | MdxNote$toDoArgs<ExtArgs>
    _count?: boolean | MdxNoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MdxNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sequentialList?: boolean | MdxNote$sequentialListArgs<ExtArgs>
  }

  export type $MdxNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MdxNote"
    objects: {
      topics: Prisma.$TopicPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      citations: Prisma.$BibEntryPayload<ExtArgs>[]
      sequentialList: Prisma.$SequentialNoteListPayload<ExtArgs> | null
      ReadingList: Prisma.$ReadingListPayload<ExtArgs>[]
      equations: Prisma.$EquationPayload<ExtArgs>[]
      definitions: Prisma.$DefinitionPayload<ExtArgs>[]
      toDo: Prisma.$ToDoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isProtected: boolean | null
      dietSummaryKey: string | null
      title: string
      latexTitle: string | null
      rootRelativePath: string
      noteType: string
      content: string
      formatted: string | null
      summary: string | null
      citationsListOrder: string[]
      importantValues: number[]
      imageSrc: string | null
      href: string
      sequentialKey: string | null
      sequentialIndex: number | null
      floatImages: boolean
      remoteUrl: string | null
      trackRemote: boolean
      outgoingQuickLinks: string[]
      quickLink: string | null
      bookmarked: boolean
      firstSync: Date
      lastSync: Date
    }, ExtArgs["result"]["mdxNote"]>
    composites: {}
  }

  type MdxNoteGetPayload<S extends boolean | null | undefined | MdxNoteDefaultArgs> = $Result.GetResult<Prisma.$MdxNotePayload, S>

  type MdxNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MdxNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MdxNoteCountAggregateInputType | true
    }

  export interface MdxNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MdxNote'], meta: { name: 'MdxNote' } }
    /**
     * Find zero or one MdxNote that matches the filter.
     * @param {MdxNoteFindUniqueArgs} args - Arguments to find a MdxNote
     * @example
     * // Get one MdxNote
     * const mdxNote = await prisma.mdxNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MdxNoteFindUniqueArgs>(args: SelectSubset<T, MdxNoteFindUniqueArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MdxNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MdxNoteFindUniqueOrThrowArgs} args - Arguments to find a MdxNote
     * @example
     * // Get one MdxNote
     * const mdxNote = await prisma.mdxNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MdxNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, MdxNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MdxNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MdxNoteFindFirstArgs} args - Arguments to find a MdxNote
     * @example
     * // Get one MdxNote
     * const mdxNote = await prisma.mdxNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MdxNoteFindFirstArgs>(args?: SelectSubset<T, MdxNoteFindFirstArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MdxNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MdxNoteFindFirstOrThrowArgs} args - Arguments to find a MdxNote
     * @example
     * // Get one MdxNote
     * const mdxNote = await prisma.mdxNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MdxNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, MdxNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MdxNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MdxNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MdxNotes
     * const mdxNotes = await prisma.mdxNote.findMany()
     * 
     * // Get first 10 MdxNotes
     * const mdxNotes = await prisma.mdxNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mdxNoteWithIdOnly = await prisma.mdxNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MdxNoteFindManyArgs>(args?: SelectSubset<T, MdxNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MdxNote.
     * @param {MdxNoteCreateArgs} args - Arguments to create a MdxNote.
     * @example
     * // Create one MdxNote
     * const MdxNote = await prisma.mdxNote.create({
     *   data: {
     *     // ... data to create a MdxNote
     *   }
     * })
     * 
     */
    create<T extends MdxNoteCreateArgs>(args: SelectSubset<T, MdxNoteCreateArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MdxNotes.
     * @param {MdxNoteCreateManyArgs} args - Arguments to create many MdxNotes.
     * @example
     * // Create many MdxNotes
     * const mdxNote = await prisma.mdxNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MdxNoteCreateManyArgs>(args?: SelectSubset<T, MdxNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MdxNotes and returns the data saved in the database.
     * @param {MdxNoteCreateManyAndReturnArgs} args - Arguments to create many MdxNotes.
     * @example
     * // Create many MdxNotes
     * const mdxNote = await prisma.mdxNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MdxNotes and only return the `id`
     * const mdxNoteWithIdOnly = await prisma.mdxNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MdxNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, MdxNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MdxNote.
     * @param {MdxNoteDeleteArgs} args - Arguments to delete one MdxNote.
     * @example
     * // Delete one MdxNote
     * const MdxNote = await prisma.mdxNote.delete({
     *   where: {
     *     // ... filter to delete one MdxNote
     *   }
     * })
     * 
     */
    delete<T extends MdxNoteDeleteArgs>(args: SelectSubset<T, MdxNoteDeleteArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MdxNote.
     * @param {MdxNoteUpdateArgs} args - Arguments to update one MdxNote.
     * @example
     * // Update one MdxNote
     * const mdxNote = await prisma.mdxNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MdxNoteUpdateArgs>(args: SelectSubset<T, MdxNoteUpdateArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MdxNotes.
     * @param {MdxNoteDeleteManyArgs} args - Arguments to filter MdxNotes to delete.
     * @example
     * // Delete a few MdxNotes
     * const { count } = await prisma.mdxNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MdxNoteDeleteManyArgs>(args?: SelectSubset<T, MdxNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MdxNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MdxNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MdxNotes
     * const mdxNote = await prisma.mdxNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MdxNoteUpdateManyArgs>(args: SelectSubset<T, MdxNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MdxNote.
     * @param {MdxNoteUpsertArgs} args - Arguments to update or create a MdxNote.
     * @example
     * // Update or create a MdxNote
     * const mdxNote = await prisma.mdxNote.upsert({
     *   create: {
     *     // ... data to create a MdxNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MdxNote we want to update
     *   }
     * })
     */
    upsert<T extends MdxNoteUpsertArgs>(args: SelectSubset<T, MdxNoteUpsertArgs<ExtArgs>>): Prisma__MdxNoteClient<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MdxNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MdxNoteCountArgs} args - Arguments to filter MdxNotes to count.
     * @example
     * // Count the number of MdxNotes
     * const count = await prisma.mdxNote.count({
     *   where: {
     *     // ... the filter for the MdxNotes we want to count
     *   }
     * })
    **/
    count<T extends MdxNoteCountArgs>(
      args?: Subset<T, MdxNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MdxNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MdxNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MdxNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MdxNoteAggregateArgs>(args: Subset<T, MdxNoteAggregateArgs>): Prisma.PrismaPromise<GetMdxNoteAggregateType<T>>

    /**
     * Group by MdxNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MdxNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MdxNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MdxNoteGroupByArgs['orderBy'] }
        : { orderBy?: MdxNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MdxNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMdxNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MdxNote model
   */
  readonly fields: MdxNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MdxNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MdxNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topics<T extends MdxNote$topicsArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends MdxNote$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends MdxNote$tagsArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    citations<T extends MdxNote$citationsArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$citationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany"> | Null>
    sequentialList<T extends MdxNote$sequentialListArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$sequentialListArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ReadingList<T extends MdxNote$ReadingListArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$ReadingListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "findMany"> | Null>
    equations<T extends MdxNote$equationsArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$equationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquationPayload<ExtArgs>, T, "findMany"> | Null>
    definitions<T extends MdxNote$definitionsArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$definitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefinitionPayload<ExtArgs>, T, "findMany"> | Null>
    toDo<T extends MdxNote$toDoArgs<ExtArgs> = {}>(args?: Subset<T, MdxNote$toDoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MdxNote model
   */ 
  interface MdxNoteFieldRefs {
    readonly id: FieldRef<"MdxNote", 'Int'>
    readonly isProtected: FieldRef<"MdxNote", 'Boolean'>
    readonly dietSummaryKey: FieldRef<"MdxNote", 'String'>
    readonly title: FieldRef<"MdxNote", 'String'>
    readonly latexTitle: FieldRef<"MdxNote", 'String'>
    readonly rootRelativePath: FieldRef<"MdxNote", 'String'>
    readonly noteType: FieldRef<"MdxNote", 'String'>
    readonly content: FieldRef<"MdxNote", 'String'>
    readonly formatted: FieldRef<"MdxNote", 'String'>
    readonly summary: FieldRef<"MdxNote", 'String'>
    readonly citationsListOrder: FieldRef<"MdxNote", 'String[]'>
    readonly importantValues: FieldRef<"MdxNote", 'Float[]'>
    readonly imageSrc: FieldRef<"MdxNote", 'String'>
    readonly href: FieldRef<"MdxNote", 'String'>
    readonly sequentialKey: FieldRef<"MdxNote", 'String'>
    readonly sequentialIndex: FieldRef<"MdxNote", 'Float'>
    readonly floatImages: FieldRef<"MdxNote", 'Boolean'>
    readonly remoteUrl: FieldRef<"MdxNote", 'String'>
    readonly trackRemote: FieldRef<"MdxNote", 'Boolean'>
    readonly outgoingQuickLinks: FieldRef<"MdxNote", 'String[]'>
    readonly quickLink: FieldRef<"MdxNote", 'String'>
    readonly bookmarked: FieldRef<"MdxNote", 'Boolean'>
    readonly firstSync: FieldRef<"MdxNote", 'DateTime'>
    readonly lastSync: FieldRef<"MdxNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MdxNote findUnique
   */
  export type MdxNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * Filter, which MdxNote to fetch.
     */
    where: MdxNoteWhereUniqueInput
  }

  /**
   * MdxNote findUniqueOrThrow
   */
  export type MdxNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * Filter, which MdxNote to fetch.
     */
    where: MdxNoteWhereUniqueInput
  }

  /**
   * MdxNote findFirst
   */
  export type MdxNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * Filter, which MdxNote to fetch.
     */
    where?: MdxNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MdxNotes to fetch.
     */
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MdxNotes.
     */
    cursor?: MdxNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MdxNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MdxNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MdxNotes.
     */
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * MdxNote findFirstOrThrow
   */
  export type MdxNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * Filter, which MdxNote to fetch.
     */
    where?: MdxNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MdxNotes to fetch.
     */
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MdxNotes.
     */
    cursor?: MdxNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MdxNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MdxNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MdxNotes.
     */
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * MdxNote findMany
   */
  export type MdxNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * Filter, which MdxNotes to fetch.
     */
    where?: MdxNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MdxNotes to fetch.
     */
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MdxNotes.
     */
    cursor?: MdxNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MdxNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MdxNotes.
     */
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * MdxNote create
   */
  export type MdxNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a MdxNote.
     */
    data: XOR<MdxNoteCreateInput, MdxNoteUncheckedCreateInput>
  }

  /**
   * MdxNote createMany
   */
  export type MdxNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MdxNotes.
     */
    data: MdxNoteCreateManyInput | MdxNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MdxNote createManyAndReturn
   */
  export type MdxNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MdxNotes.
     */
    data: MdxNoteCreateManyInput | MdxNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MdxNote update
   */
  export type MdxNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a MdxNote.
     */
    data: XOR<MdxNoteUpdateInput, MdxNoteUncheckedUpdateInput>
    /**
     * Choose, which MdxNote to update.
     */
    where: MdxNoteWhereUniqueInput
  }

  /**
   * MdxNote updateMany
   */
  export type MdxNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MdxNotes.
     */
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyInput>
    /**
     * Filter which MdxNotes to update
     */
    where?: MdxNoteWhereInput
  }

  /**
   * MdxNote upsert
   */
  export type MdxNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the MdxNote to update in case it exists.
     */
    where: MdxNoteWhereUniqueInput
    /**
     * In case the MdxNote found by the `where` argument doesn't exist, create a new MdxNote with this data.
     */
    create: XOR<MdxNoteCreateInput, MdxNoteUncheckedCreateInput>
    /**
     * In case the MdxNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MdxNoteUpdateInput, MdxNoteUncheckedUpdateInput>
  }

  /**
   * MdxNote delete
   */
  export type MdxNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    /**
     * Filter which MdxNote to delete.
     */
    where: MdxNoteWhereUniqueInput
  }

  /**
   * MdxNote deleteMany
   */
  export type MdxNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MdxNotes to delete
     */
    where?: MdxNoteWhereInput
  }

  /**
   * MdxNote.topics
   */
  export type MdxNote$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * MdxNote.subjects
   */
  export type MdxNote$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * MdxNote.tags
   */
  export type MdxNote$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * MdxNote.citations
   */
  export type MdxNote$citationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    cursor?: BibEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * MdxNote.sequentialList
   */
  export type MdxNote$sequentialListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    where?: SequentialNoteListWhereInput
  }

  /**
   * MdxNote.ReadingList
   */
  export type MdxNote$ReadingListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    where?: ReadingListWhereInput
    orderBy?: ReadingListOrderByWithRelationInput | ReadingListOrderByWithRelationInput[]
    cursor?: ReadingListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadingListScalarFieldEnum | ReadingListScalarFieldEnum[]
  }

  /**
   * MdxNote.equations
   */
  export type MdxNote$equationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equation
     */
    select?: EquationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquationInclude<ExtArgs> | null
    where?: EquationWhereInput
    orderBy?: EquationOrderByWithRelationInput | EquationOrderByWithRelationInput[]
    cursor?: EquationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquationScalarFieldEnum | EquationScalarFieldEnum[]
  }

  /**
   * MdxNote.definitions
   */
  export type MdxNote$definitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Definition
     */
    select?: DefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefinitionInclude<ExtArgs> | null
    where?: DefinitionWhereInput
    orderBy?: DefinitionOrderByWithRelationInput | DefinitionOrderByWithRelationInput[]
    cursor?: DefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefinitionScalarFieldEnum | DefinitionScalarFieldEnum[]
  }

  /**
   * MdxNote.toDo
   */
  export type MdxNote$toDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    where?: ToDoWhereInput
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    cursor?: ToDoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * MdxNote without action
   */
  export type MdxNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
  }


  /**
   * Model Ipynb
   */

  export type AggregateIpynb = {
    _count: IpynbCountAggregateOutputType | null
    _avg: IpynbAvgAggregateOutputType | null
    _sum: IpynbSumAggregateOutputType | null
    _min: IpynbMinAggregateOutputType | null
    _max: IpynbMaxAggregateOutputType | null
  }

  export type IpynbAvgAggregateOutputType = {
    id: number | null
    importantValues: number | null
    sequentialIndex: number | null
  }

  export type IpynbSumAggregateOutputType = {
    id: number | null
    importantValues: number[]
    sequentialIndex: number | null
  }

  export type IpynbMinAggregateOutputType = {
    id: number | null
    rootRelativePath: string | null
    isProtected: boolean | null
    title: string | null
    latexTitle: string | null
    href: string | null
    raw: Buffer | null
    sequentialKey: string | null
    sequentialIndex: number | null
    bookmarked: boolean | null
    firstSync: Date | null
    lastSync: Date | null
  }

  export type IpynbMaxAggregateOutputType = {
    id: number | null
    rootRelativePath: string | null
    isProtected: boolean | null
    title: string | null
    latexTitle: string | null
    href: string | null
    raw: Buffer | null
    sequentialKey: string | null
    sequentialIndex: number | null
    bookmarked: boolean | null
    firstSync: Date | null
    lastSync: Date | null
  }

  export type IpynbCountAggregateOutputType = {
    id: number
    rootRelativePath: number
    isProtected: number
    title: number
    latexTitle: number
    citationsListOrder: number
    importantValues: number
    href: number
    outgoingQuickLinks: number
    raw: number
    sequentialKey: number
    sequentialIndex: number
    bookmarked: number
    firstSync: number
    lastSync: number
    _all: number
  }


  export type IpynbAvgAggregateInputType = {
    id?: true
    importantValues?: true
    sequentialIndex?: true
  }

  export type IpynbSumAggregateInputType = {
    id?: true
    importantValues?: true
    sequentialIndex?: true
  }

  export type IpynbMinAggregateInputType = {
    id?: true
    rootRelativePath?: true
    isProtected?: true
    title?: true
    latexTitle?: true
    href?: true
    raw?: true
    sequentialKey?: true
    sequentialIndex?: true
    bookmarked?: true
    firstSync?: true
    lastSync?: true
  }

  export type IpynbMaxAggregateInputType = {
    id?: true
    rootRelativePath?: true
    isProtected?: true
    title?: true
    latexTitle?: true
    href?: true
    raw?: true
    sequentialKey?: true
    sequentialIndex?: true
    bookmarked?: true
    firstSync?: true
    lastSync?: true
  }

  export type IpynbCountAggregateInputType = {
    id?: true
    rootRelativePath?: true
    isProtected?: true
    title?: true
    latexTitle?: true
    citationsListOrder?: true
    importantValues?: true
    href?: true
    outgoingQuickLinks?: true
    raw?: true
    sequentialKey?: true
    sequentialIndex?: true
    bookmarked?: true
    firstSync?: true
    lastSync?: true
    _all?: true
  }

  export type IpynbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ipynb to aggregate.
     */
    where?: IpynbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ipynbs to fetch.
     */
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IpynbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ipynbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ipynbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ipynbs
    **/
    _count?: true | IpynbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IpynbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IpynbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IpynbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IpynbMaxAggregateInputType
  }

  export type GetIpynbAggregateType<T extends IpynbAggregateArgs> = {
        [P in keyof T & keyof AggregateIpynb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIpynb[P]>
      : GetScalarType<T[P], AggregateIpynb[P]>
  }




  export type IpynbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpynbWhereInput
    orderBy?: IpynbOrderByWithAggregationInput | IpynbOrderByWithAggregationInput[]
    by: IpynbScalarFieldEnum[] | IpynbScalarFieldEnum
    having?: IpynbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IpynbCountAggregateInputType | true
    _avg?: IpynbAvgAggregateInputType
    _sum?: IpynbSumAggregateInputType
    _min?: IpynbMinAggregateInputType
    _max?: IpynbMaxAggregateInputType
  }

  export type IpynbGroupByOutputType = {
    id: number
    rootRelativePath: string
    isProtected: boolean | null
    title: string
    latexTitle: string | null
    citationsListOrder: string[]
    importantValues: number[]
    href: string
    outgoingQuickLinks: string[]
    raw: Buffer
    sequentialKey: string | null
    sequentialIndex: number | null
    bookmarked: boolean
    firstSync: Date
    lastSync: Date
    _count: IpynbCountAggregateOutputType | null
    _avg: IpynbAvgAggregateOutputType | null
    _sum: IpynbSumAggregateOutputType | null
    _min: IpynbMinAggregateOutputType | null
    _max: IpynbMaxAggregateOutputType | null
  }

  type GetIpynbGroupByPayload<T extends IpynbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IpynbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IpynbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IpynbGroupByOutputType[P]>
            : GetScalarType<T[P], IpynbGroupByOutputType[P]>
        }
      >
    >


  export type IpynbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rootRelativePath?: boolean
    isProtected?: boolean
    title?: boolean
    latexTitle?: boolean
    citationsListOrder?: boolean
    importantValues?: boolean
    href?: boolean
    outgoingQuickLinks?: boolean
    raw?: boolean
    sequentialKey?: boolean
    sequentialIndex?: boolean
    bookmarked?: boolean
    firstSync?: boolean
    lastSync?: boolean
    tags?: boolean | Ipynb$tagsArgs<ExtArgs>
    topics?: boolean | Ipynb$topicsArgs<ExtArgs>
    subjects?: boolean | Ipynb$subjectsArgs<ExtArgs>
    citations?: boolean | Ipynb$citationsArgs<ExtArgs>
    sequentialList?: boolean | Ipynb$sequentialListArgs<ExtArgs>
    readingList?: boolean | Ipynb$readingListArgs<ExtArgs>
    _count?: boolean | IpynbCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ipynb"]>

  export type IpynbSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rootRelativePath?: boolean
    isProtected?: boolean
    title?: boolean
    latexTitle?: boolean
    citationsListOrder?: boolean
    importantValues?: boolean
    href?: boolean
    outgoingQuickLinks?: boolean
    raw?: boolean
    sequentialKey?: boolean
    sequentialIndex?: boolean
    bookmarked?: boolean
    firstSync?: boolean
    lastSync?: boolean
    sequentialList?: boolean | Ipynb$sequentialListArgs<ExtArgs>
  }, ExtArgs["result"]["ipynb"]>

  export type IpynbSelectScalar = {
    id?: boolean
    rootRelativePath?: boolean
    isProtected?: boolean
    title?: boolean
    latexTitle?: boolean
    citationsListOrder?: boolean
    importantValues?: boolean
    href?: boolean
    outgoingQuickLinks?: boolean
    raw?: boolean
    sequentialKey?: boolean
    sequentialIndex?: boolean
    bookmarked?: boolean
    firstSync?: boolean
    lastSync?: boolean
  }

  export type IpynbInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | Ipynb$tagsArgs<ExtArgs>
    topics?: boolean | Ipynb$topicsArgs<ExtArgs>
    subjects?: boolean | Ipynb$subjectsArgs<ExtArgs>
    citations?: boolean | Ipynb$citationsArgs<ExtArgs>
    sequentialList?: boolean | Ipynb$sequentialListArgs<ExtArgs>
    readingList?: boolean | Ipynb$readingListArgs<ExtArgs>
    _count?: boolean | IpynbCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IpynbIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sequentialList?: boolean | Ipynb$sequentialListArgs<ExtArgs>
  }

  export type $IpynbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ipynb"
    objects: {
      tags: Prisma.$TagPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      citations: Prisma.$BibEntryPayload<ExtArgs>[]
      sequentialList: Prisma.$SequentialNoteListPayload<ExtArgs> | null
      readingList: Prisma.$ReadingListPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rootRelativePath: string
      isProtected: boolean | null
      title: string
      latexTitle: string | null
      citationsListOrder: string[]
      importantValues: number[]
      href: string
      outgoingQuickLinks: string[]
      raw: Buffer
      sequentialKey: string | null
      sequentialIndex: number | null
      bookmarked: boolean
      firstSync: Date
      lastSync: Date
    }, ExtArgs["result"]["ipynb"]>
    composites: {}
  }

  type IpynbGetPayload<S extends boolean | null | undefined | IpynbDefaultArgs> = $Result.GetResult<Prisma.$IpynbPayload, S>

  type IpynbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IpynbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IpynbCountAggregateInputType | true
    }

  export interface IpynbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ipynb'], meta: { name: 'Ipynb' } }
    /**
     * Find zero or one Ipynb that matches the filter.
     * @param {IpynbFindUniqueArgs} args - Arguments to find a Ipynb
     * @example
     * // Get one Ipynb
     * const ipynb = await prisma.ipynb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IpynbFindUniqueArgs>(args: SelectSubset<T, IpynbFindUniqueArgs<ExtArgs>>): Prisma__IpynbClient<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ipynb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IpynbFindUniqueOrThrowArgs} args - Arguments to find a Ipynb
     * @example
     * // Get one Ipynb
     * const ipynb = await prisma.ipynb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IpynbFindUniqueOrThrowArgs>(args: SelectSubset<T, IpynbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IpynbClient<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ipynb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpynbFindFirstArgs} args - Arguments to find a Ipynb
     * @example
     * // Get one Ipynb
     * const ipynb = await prisma.ipynb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IpynbFindFirstArgs>(args?: SelectSubset<T, IpynbFindFirstArgs<ExtArgs>>): Prisma__IpynbClient<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ipynb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpynbFindFirstOrThrowArgs} args - Arguments to find a Ipynb
     * @example
     * // Get one Ipynb
     * const ipynb = await prisma.ipynb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IpynbFindFirstOrThrowArgs>(args?: SelectSubset<T, IpynbFindFirstOrThrowArgs<ExtArgs>>): Prisma__IpynbClient<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ipynbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpynbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ipynbs
     * const ipynbs = await prisma.ipynb.findMany()
     * 
     * // Get first 10 Ipynbs
     * const ipynbs = await prisma.ipynb.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ipynbWithIdOnly = await prisma.ipynb.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IpynbFindManyArgs>(args?: SelectSubset<T, IpynbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ipynb.
     * @param {IpynbCreateArgs} args - Arguments to create a Ipynb.
     * @example
     * // Create one Ipynb
     * const Ipynb = await prisma.ipynb.create({
     *   data: {
     *     // ... data to create a Ipynb
     *   }
     * })
     * 
     */
    create<T extends IpynbCreateArgs>(args: SelectSubset<T, IpynbCreateArgs<ExtArgs>>): Prisma__IpynbClient<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ipynbs.
     * @param {IpynbCreateManyArgs} args - Arguments to create many Ipynbs.
     * @example
     * // Create many Ipynbs
     * const ipynb = await prisma.ipynb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IpynbCreateManyArgs>(args?: SelectSubset<T, IpynbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ipynbs and returns the data saved in the database.
     * @param {IpynbCreateManyAndReturnArgs} args - Arguments to create many Ipynbs.
     * @example
     * // Create many Ipynbs
     * const ipynb = await prisma.ipynb.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ipynbs and only return the `id`
     * const ipynbWithIdOnly = await prisma.ipynb.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IpynbCreateManyAndReturnArgs>(args?: SelectSubset<T, IpynbCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ipynb.
     * @param {IpynbDeleteArgs} args - Arguments to delete one Ipynb.
     * @example
     * // Delete one Ipynb
     * const Ipynb = await prisma.ipynb.delete({
     *   where: {
     *     // ... filter to delete one Ipynb
     *   }
     * })
     * 
     */
    delete<T extends IpynbDeleteArgs>(args: SelectSubset<T, IpynbDeleteArgs<ExtArgs>>): Prisma__IpynbClient<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ipynb.
     * @param {IpynbUpdateArgs} args - Arguments to update one Ipynb.
     * @example
     * // Update one Ipynb
     * const ipynb = await prisma.ipynb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IpynbUpdateArgs>(args: SelectSubset<T, IpynbUpdateArgs<ExtArgs>>): Prisma__IpynbClient<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ipynbs.
     * @param {IpynbDeleteManyArgs} args - Arguments to filter Ipynbs to delete.
     * @example
     * // Delete a few Ipynbs
     * const { count } = await prisma.ipynb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IpynbDeleteManyArgs>(args?: SelectSubset<T, IpynbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ipynbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpynbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ipynbs
     * const ipynb = await prisma.ipynb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IpynbUpdateManyArgs>(args: SelectSubset<T, IpynbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ipynb.
     * @param {IpynbUpsertArgs} args - Arguments to update or create a Ipynb.
     * @example
     * // Update or create a Ipynb
     * const ipynb = await prisma.ipynb.upsert({
     *   create: {
     *     // ... data to create a Ipynb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ipynb we want to update
     *   }
     * })
     */
    upsert<T extends IpynbUpsertArgs>(args: SelectSubset<T, IpynbUpsertArgs<ExtArgs>>): Prisma__IpynbClient<$Result.GetResult<Prisma.$IpynbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ipynbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpynbCountArgs} args - Arguments to filter Ipynbs to count.
     * @example
     * // Count the number of Ipynbs
     * const count = await prisma.ipynb.count({
     *   where: {
     *     // ... the filter for the Ipynbs we want to count
     *   }
     * })
    **/
    count<T extends IpynbCountArgs>(
      args?: Subset<T, IpynbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IpynbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ipynb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpynbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IpynbAggregateArgs>(args: Subset<T, IpynbAggregateArgs>): Prisma.PrismaPromise<GetIpynbAggregateType<T>>

    /**
     * Group by Ipynb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpynbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IpynbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IpynbGroupByArgs['orderBy'] }
        : { orderBy?: IpynbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IpynbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIpynbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ipynb model
   */
  readonly fields: IpynbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ipynb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IpynbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tags<T extends Ipynb$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Ipynb$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    topics<T extends Ipynb$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Ipynb$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends Ipynb$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Ipynb$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    citations<T extends Ipynb$citationsArgs<ExtArgs> = {}>(args?: Subset<T, Ipynb$citationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BibEntryPayload<ExtArgs>, T, "findMany"> | Null>
    sequentialList<T extends Ipynb$sequentialListArgs<ExtArgs> = {}>(args?: Subset<T, Ipynb$sequentialListArgs<ExtArgs>>): Prisma__SequentialNoteListClient<$Result.GetResult<Prisma.$SequentialNoteListPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    readingList<T extends Ipynb$readingListArgs<ExtArgs> = {}>(args?: Subset<T, Ipynb$readingListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingListPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ipynb model
   */ 
  interface IpynbFieldRefs {
    readonly id: FieldRef<"Ipynb", 'Int'>
    readonly rootRelativePath: FieldRef<"Ipynb", 'String'>
    readonly isProtected: FieldRef<"Ipynb", 'Boolean'>
    readonly title: FieldRef<"Ipynb", 'String'>
    readonly latexTitle: FieldRef<"Ipynb", 'String'>
    readonly citationsListOrder: FieldRef<"Ipynb", 'String[]'>
    readonly importantValues: FieldRef<"Ipynb", 'Float[]'>
    readonly href: FieldRef<"Ipynb", 'String'>
    readonly outgoingQuickLinks: FieldRef<"Ipynb", 'String[]'>
    readonly raw: FieldRef<"Ipynb", 'Bytes'>
    readonly sequentialKey: FieldRef<"Ipynb", 'String'>
    readonly sequentialIndex: FieldRef<"Ipynb", 'Int'>
    readonly bookmarked: FieldRef<"Ipynb", 'Boolean'>
    readonly firstSync: FieldRef<"Ipynb", 'DateTime'>
    readonly lastSync: FieldRef<"Ipynb", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ipynb findUnique
   */
  export type IpynbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * Filter, which Ipynb to fetch.
     */
    where: IpynbWhereUniqueInput
  }

  /**
   * Ipynb findUniqueOrThrow
   */
  export type IpynbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * Filter, which Ipynb to fetch.
     */
    where: IpynbWhereUniqueInput
  }

  /**
   * Ipynb findFirst
   */
  export type IpynbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * Filter, which Ipynb to fetch.
     */
    where?: IpynbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ipynbs to fetch.
     */
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ipynbs.
     */
    cursor?: IpynbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ipynbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ipynbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ipynbs.
     */
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * Ipynb findFirstOrThrow
   */
  export type IpynbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * Filter, which Ipynb to fetch.
     */
    where?: IpynbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ipynbs to fetch.
     */
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ipynbs.
     */
    cursor?: IpynbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ipynbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ipynbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ipynbs.
     */
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * Ipynb findMany
   */
  export type IpynbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * Filter, which Ipynbs to fetch.
     */
    where?: IpynbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ipynbs to fetch.
     */
    orderBy?: IpynbOrderByWithRelationInput | IpynbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ipynbs.
     */
    cursor?: IpynbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ipynbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ipynbs.
     */
    skip?: number
    distinct?: IpynbScalarFieldEnum | IpynbScalarFieldEnum[]
  }

  /**
   * Ipynb create
   */
  export type IpynbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * The data needed to create a Ipynb.
     */
    data: XOR<IpynbCreateInput, IpynbUncheckedCreateInput>
  }

  /**
   * Ipynb createMany
   */
  export type IpynbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ipynbs.
     */
    data: IpynbCreateManyInput | IpynbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ipynb createManyAndReturn
   */
  export type IpynbCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ipynbs.
     */
    data: IpynbCreateManyInput | IpynbCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ipynb update
   */
  export type IpynbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * The data needed to update a Ipynb.
     */
    data: XOR<IpynbUpdateInput, IpynbUncheckedUpdateInput>
    /**
     * Choose, which Ipynb to update.
     */
    where: IpynbWhereUniqueInput
  }

  /**
   * Ipynb updateMany
   */
  export type IpynbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ipynbs.
     */
    data: XOR<IpynbUpdateManyMutationInput, IpynbUncheckedUpdateManyInput>
    /**
     * Filter which Ipynbs to update
     */
    where?: IpynbWhereInput
  }

  /**
   * Ipynb upsert
   */
  export type IpynbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * The filter to search for the Ipynb to update in case it exists.
     */
    where: IpynbWhereUniqueInput
    /**
     * In case the Ipynb found by the `where` argument doesn't exist, create a new Ipynb with this data.
     */
    create: XOR<IpynbCreateInput, IpynbUncheckedCreateInput>
    /**
     * In case the Ipynb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IpynbUpdateInput, IpynbUncheckedUpdateInput>
  }

  /**
   * Ipynb delete
   */
  export type IpynbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
    /**
     * Filter which Ipynb to delete.
     */
    where: IpynbWhereUniqueInput
  }

  /**
   * Ipynb deleteMany
   */
  export type IpynbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ipynbs to delete
     */
    where?: IpynbWhereInput
  }

  /**
   * Ipynb.tags
   */
  export type Ipynb$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Ipynb.topics
   */
  export type Ipynb$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Ipynb.subjects
   */
  export type Ipynb$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Ipynb.citations
   */
  export type Ipynb$citationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BibEntry
     */
    select?: BibEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BibEntryInclude<ExtArgs> | null
    where?: BibEntryWhereInput
    orderBy?: BibEntryOrderByWithRelationInput | BibEntryOrderByWithRelationInput[]
    cursor?: BibEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BibEntryScalarFieldEnum | BibEntryScalarFieldEnum[]
  }

  /**
   * Ipynb.sequentialList
   */
  export type Ipynb$sequentialListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequentialNoteList
     */
    select?: SequentialNoteListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SequentialNoteListInclude<ExtArgs> | null
    where?: SequentialNoteListWhereInput
  }

  /**
   * Ipynb.readingList
   */
  export type Ipynb$readingListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingList
     */
    select?: ReadingListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingListInclude<ExtArgs> | null
    where?: ReadingListWhereInput
    orderBy?: ReadingListOrderByWithRelationInput | ReadingListOrderByWithRelationInput[]
    cursor?: ReadingListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadingListScalarFieldEnum | ReadingListScalarFieldEnum[]
  }

  /**
   * Ipynb without action
   */
  export type IpynbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ipynb
     */
    select?: IpynbSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpynbInclude<ExtArgs> | null
  }


  /**
   * Model ToDoList
   */

  export type AggregateToDoList = {
    _count: ToDoListCountAggregateOutputType | null
    _avg: ToDoListAvgAggregateOutputType | null
    _sum: ToDoListSumAggregateOutputType | null
    _min: ToDoListMinAggregateOutputType | null
    _max: ToDoListMaxAggregateOutputType | null
  }

  export type ToDoListAvgAggregateOutputType = {
    id: number | null
  }

  export type ToDoListSumAggregateOutputType = {
    id: number | null
  }

  export type ToDoListMinAggregateOutputType = {
    id: number | null
    label: string | null
    createdAt: Date | null
    lastUpdate: Date | null
  }

  export type ToDoListMaxAggregateOutputType = {
    id: number | null
    label: string | null
    createdAt: Date | null
    lastUpdate: Date | null
  }

  export type ToDoListCountAggregateOutputType = {
    id: number
    label: number
    createdAt: number
    lastUpdate: number
    _all: number
  }


  export type ToDoListAvgAggregateInputType = {
    id?: true
  }

  export type ToDoListSumAggregateInputType = {
    id?: true
  }

  export type ToDoListMinAggregateInputType = {
    id?: true
    label?: true
    createdAt?: true
    lastUpdate?: true
  }

  export type ToDoListMaxAggregateInputType = {
    id?: true
    label?: true
    createdAt?: true
    lastUpdate?: true
  }

  export type ToDoListCountAggregateInputType = {
    id?: true
    label?: true
    createdAt?: true
    lastUpdate?: true
    _all?: true
  }

  export type ToDoListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ToDoList to aggregate.
     */
    where?: ToDoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToDoLists to fetch.
     */
    orderBy?: ToDoListOrderByWithRelationInput | ToDoListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ToDoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToDoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToDoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ToDoLists
    **/
    _count?: true | ToDoListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ToDoListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ToDoListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ToDoListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ToDoListMaxAggregateInputType
  }

  export type GetToDoListAggregateType<T extends ToDoListAggregateArgs> = {
        [P in keyof T & keyof AggregateToDoList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToDoList[P]>
      : GetScalarType<T[P], AggregateToDoList[P]>
  }




  export type ToDoListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoListWhereInput
    orderBy?: ToDoListOrderByWithAggregationInput | ToDoListOrderByWithAggregationInput[]
    by: ToDoListScalarFieldEnum[] | ToDoListScalarFieldEnum
    having?: ToDoListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ToDoListCountAggregateInputType | true
    _avg?: ToDoListAvgAggregateInputType
    _sum?: ToDoListSumAggregateInputType
    _min?: ToDoListMinAggregateInputType
    _max?: ToDoListMaxAggregateInputType
  }

  export type ToDoListGroupByOutputType = {
    id: number
    label: string
    createdAt: Date
    lastUpdate: Date
    _count: ToDoListCountAggregateOutputType | null
    _avg: ToDoListAvgAggregateOutputType | null
    _sum: ToDoListSumAggregateOutputType | null
    _min: ToDoListMinAggregateOutputType | null
    _max: ToDoListMaxAggregateOutputType | null
  }

  type GetToDoListGroupByPayload<T extends ToDoListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ToDoListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ToDoListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ToDoListGroupByOutputType[P]>
            : GetScalarType<T[P], ToDoListGroupByOutputType[P]>
        }
      >
    >


  export type ToDoListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
    tasks?: boolean | ToDoList$tasksArgs<ExtArgs>
    tags?: boolean | ToDoList$tagsArgs<ExtArgs>
    topics?: boolean | ToDoList$topicsArgs<ExtArgs>
    subjects?: boolean | ToDoList$subjectsArgs<ExtArgs>
    _count?: boolean | ToDoListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toDoList"]>

  export type ToDoListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
  }, ExtArgs["result"]["toDoList"]>

  export type ToDoListSelectScalar = {
    id?: boolean
    label?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
  }

  export type ToDoListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ToDoList$tasksArgs<ExtArgs>
    tags?: boolean | ToDoList$tagsArgs<ExtArgs>
    topics?: boolean | ToDoList$topicsArgs<ExtArgs>
    subjects?: boolean | ToDoList$subjectsArgs<ExtArgs>
    _count?: boolean | ToDoListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ToDoListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ToDoListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ToDoList"
    objects: {
      tasks: Prisma.$ToDoPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      createdAt: Date
      lastUpdate: Date
    }, ExtArgs["result"]["toDoList"]>
    composites: {}
  }

  type ToDoListGetPayload<S extends boolean | null | undefined | ToDoListDefaultArgs> = $Result.GetResult<Prisma.$ToDoListPayload, S>

  type ToDoListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ToDoListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ToDoListCountAggregateInputType | true
    }

  export interface ToDoListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ToDoList'], meta: { name: 'ToDoList' } }
    /**
     * Find zero or one ToDoList that matches the filter.
     * @param {ToDoListFindUniqueArgs} args - Arguments to find a ToDoList
     * @example
     * // Get one ToDoList
     * const toDoList = await prisma.toDoList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ToDoListFindUniqueArgs>(args: SelectSubset<T, ToDoListFindUniqueArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ToDoList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ToDoListFindUniqueOrThrowArgs} args - Arguments to find a ToDoList
     * @example
     * // Get one ToDoList
     * const toDoList = await prisma.toDoList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ToDoListFindUniqueOrThrowArgs>(args: SelectSubset<T, ToDoListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ToDoList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoListFindFirstArgs} args - Arguments to find a ToDoList
     * @example
     * // Get one ToDoList
     * const toDoList = await prisma.toDoList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ToDoListFindFirstArgs>(args?: SelectSubset<T, ToDoListFindFirstArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ToDoList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoListFindFirstOrThrowArgs} args - Arguments to find a ToDoList
     * @example
     * // Get one ToDoList
     * const toDoList = await prisma.toDoList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ToDoListFindFirstOrThrowArgs>(args?: SelectSubset<T, ToDoListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ToDoLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ToDoLists
     * const toDoLists = await prisma.toDoList.findMany()
     * 
     * // Get first 10 ToDoLists
     * const toDoLists = await prisma.toDoList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const toDoListWithIdOnly = await prisma.toDoList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ToDoListFindManyArgs>(args?: SelectSubset<T, ToDoListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ToDoList.
     * @param {ToDoListCreateArgs} args - Arguments to create a ToDoList.
     * @example
     * // Create one ToDoList
     * const ToDoList = await prisma.toDoList.create({
     *   data: {
     *     // ... data to create a ToDoList
     *   }
     * })
     * 
     */
    create<T extends ToDoListCreateArgs>(args: SelectSubset<T, ToDoListCreateArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ToDoLists.
     * @param {ToDoListCreateManyArgs} args - Arguments to create many ToDoLists.
     * @example
     * // Create many ToDoLists
     * const toDoList = await prisma.toDoList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ToDoListCreateManyArgs>(args?: SelectSubset<T, ToDoListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ToDoLists and returns the data saved in the database.
     * @param {ToDoListCreateManyAndReturnArgs} args - Arguments to create many ToDoLists.
     * @example
     * // Create many ToDoLists
     * const toDoList = await prisma.toDoList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ToDoLists and only return the `id`
     * const toDoListWithIdOnly = await prisma.toDoList.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ToDoListCreateManyAndReturnArgs>(args?: SelectSubset<T, ToDoListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ToDoList.
     * @param {ToDoListDeleteArgs} args - Arguments to delete one ToDoList.
     * @example
     * // Delete one ToDoList
     * const ToDoList = await prisma.toDoList.delete({
     *   where: {
     *     // ... filter to delete one ToDoList
     *   }
     * })
     * 
     */
    delete<T extends ToDoListDeleteArgs>(args: SelectSubset<T, ToDoListDeleteArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ToDoList.
     * @param {ToDoListUpdateArgs} args - Arguments to update one ToDoList.
     * @example
     * // Update one ToDoList
     * const toDoList = await prisma.toDoList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ToDoListUpdateArgs>(args: SelectSubset<T, ToDoListUpdateArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ToDoLists.
     * @param {ToDoListDeleteManyArgs} args - Arguments to filter ToDoLists to delete.
     * @example
     * // Delete a few ToDoLists
     * const { count } = await prisma.toDoList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ToDoListDeleteManyArgs>(args?: SelectSubset<T, ToDoListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ToDoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ToDoLists
     * const toDoList = await prisma.toDoList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ToDoListUpdateManyArgs>(args: SelectSubset<T, ToDoListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ToDoList.
     * @param {ToDoListUpsertArgs} args - Arguments to update or create a ToDoList.
     * @example
     * // Update or create a ToDoList
     * const toDoList = await prisma.toDoList.upsert({
     *   create: {
     *     // ... data to create a ToDoList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ToDoList we want to update
     *   }
     * })
     */
    upsert<T extends ToDoListUpsertArgs>(args: SelectSubset<T, ToDoListUpsertArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ToDoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoListCountArgs} args - Arguments to filter ToDoLists to count.
     * @example
     * // Count the number of ToDoLists
     * const count = await prisma.toDoList.count({
     *   where: {
     *     // ... the filter for the ToDoLists we want to count
     *   }
     * })
    **/
    count<T extends ToDoListCountArgs>(
      args?: Subset<T, ToDoListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ToDoListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ToDoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ToDoListAggregateArgs>(args: Subset<T, ToDoListAggregateArgs>): Prisma.PrismaPromise<GetToDoListAggregateType<T>>

    /**
     * Group by ToDoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ToDoListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ToDoListGroupByArgs['orderBy'] }
        : { orderBy?: ToDoListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ToDoListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToDoListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ToDoList model
   */
  readonly fields: ToDoListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ToDoList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ToDoListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends ToDoList$tasksArgs<ExtArgs> = {}>(args?: Subset<T, ToDoList$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends ToDoList$tagsArgs<ExtArgs> = {}>(args?: Subset<T, ToDoList$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    topics<T extends ToDoList$topicsArgs<ExtArgs> = {}>(args?: Subset<T, ToDoList$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends ToDoList$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, ToDoList$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ToDoList model
   */ 
  interface ToDoListFieldRefs {
    readonly id: FieldRef<"ToDoList", 'Int'>
    readonly label: FieldRef<"ToDoList", 'String'>
    readonly createdAt: FieldRef<"ToDoList", 'DateTime'>
    readonly lastUpdate: FieldRef<"ToDoList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ToDoList findUnique
   */
  export type ToDoListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * Filter, which ToDoList to fetch.
     */
    where: ToDoListWhereUniqueInput
  }

  /**
   * ToDoList findUniqueOrThrow
   */
  export type ToDoListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * Filter, which ToDoList to fetch.
     */
    where: ToDoListWhereUniqueInput
  }

  /**
   * ToDoList findFirst
   */
  export type ToDoListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * Filter, which ToDoList to fetch.
     */
    where?: ToDoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToDoLists to fetch.
     */
    orderBy?: ToDoListOrderByWithRelationInput | ToDoListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ToDoLists.
     */
    cursor?: ToDoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToDoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToDoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ToDoLists.
     */
    distinct?: ToDoListScalarFieldEnum | ToDoListScalarFieldEnum[]
  }

  /**
   * ToDoList findFirstOrThrow
   */
  export type ToDoListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * Filter, which ToDoList to fetch.
     */
    where?: ToDoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToDoLists to fetch.
     */
    orderBy?: ToDoListOrderByWithRelationInput | ToDoListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ToDoLists.
     */
    cursor?: ToDoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToDoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToDoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ToDoLists.
     */
    distinct?: ToDoListScalarFieldEnum | ToDoListScalarFieldEnum[]
  }

  /**
   * ToDoList findMany
   */
  export type ToDoListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * Filter, which ToDoLists to fetch.
     */
    where?: ToDoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToDoLists to fetch.
     */
    orderBy?: ToDoListOrderByWithRelationInput | ToDoListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ToDoLists.
     */
    cursor?: ToDoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToDoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToDoLists.
     */
    skip?: number
    distinct?: ToDoListScalarFieldEnum | ToDoListScalarFieldEnum[]
  }

  /**
   * ToDoList create
   */
  export type ToDoListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * The data needed to create a ToDoList.
     */
    data: XOR<ToDoListCreateInput, ToDoListUncheckedCreateInput>
  }

  /**
   * ToDoList createMany
   */
  export type ToDoListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ToDoLists.
     */
    data: ToDoListCreateManyInput | ToDoListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ToDoList createManyAndReturn
   */
  export type ToDoListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ToDoLists.
     */
    data: ToDoListCreateManyInput | ToDoListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ToDoList update
   */
  export type ToDoListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * The data needed to update a ToDoList.
     */
    data: XOR<ToDoListUpdateInput, ToDoListUncheckedUpdateInput>
    /**
     * Choose, which ToDoList to update.
     */
    where: ToDoListWhereUniqueInput
  }

  /**
   * ToDoList updateMany
   */
  export type ToDoListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ToDoLists.
     */
    data: XOR<ToDoListUpdateManyMutationInput, ToDoListUncheckedUpdateManyInput>
    /**
     * Filter which ToDoLists to update
     */
    where?: ToDoListWhereInput
  }

  /**
   * ToDoList upsert
   */
  export type ToDoListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * The filter to search for the ToDoList to update in case it exists.
     */
    where: ToDoListWhereUniqueInput
    /**
     * In case the ToDoList found by the `where` argument doesn't exist, create a new ToDoList with this data.
     */
    create: XOR<ToDoListCreateInput, ToDoListUncheckedCreateInput>
    /**
     * In case the ToDoList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ToDoListUpdateInput, ToDoListUncheckedUpdateInput>
  }

  /**
   * ToDoList delete
   */
  export type ToDoListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    /**
     * Filter which ToDoList to delete.
     */
    where: ToDoListWhereUniqueInput
  }

  /**
   * ToDoList deleteMany
   */
  export type ToDoListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ToDoLists to delete
     */
    where?: ToDoListWhereInput
  }

  /**
   * ToDoList.tasks
   */
  export type ToDoList$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    where?: ToDoWhereInput
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    cursor?: ToDoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * ToDoList.tags
   */
  export type ToDoList$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * ToDoList.topics
   */
  export type ToDoList$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * ToDoList.subjects
   */
  export type ToDoList$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * ToDoList without action
   */
  export type ToDoListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
  }


  /**
   * Model ToDo
   */

  export type AggregateToDo = {
    _count: ToDoCountAggregateOutputType | null
    _avg: ToDoAvgAggregateOutputType | null
    _sum: ToDoSumAggregateOutputType | null
    _min: ToDoMinAggregateOutputType | null
    _max: ToDoMaxAggregateOutputType | null
  }

  export type ToDoAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    priority: number | null
    toDoListId: number | null
  }

  export type ToDoSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    priority: number | null
    toDoListId: number | null
  }

  export type ToDoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    task: string | null
    dueAt: Date | null
    details: string | null
    parentId: number | null
    category: $Enums.TaskCategory | null
    bookmarked: boolean | null
    status: $Enums.ToDoListStatus | null
    priority: number | null
    toDoListId: number | null
  }

  export type ToDoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    task: string | null
    dueAt: Date | null
    details: string | null
    parentId: number | null
    category: $Enums.TaskCategory | null
    bookmarked: boolean | null
    status: $Enums.ToDoListStatus | null
    priority: number | null
    toDoListId: number | null
  }

  export type ToDoCountAggregateOutputType = {
    id: number
    createdAt: number
    task: number
    dueAt: number
    details: number
    parentId: number
    category: number
    bookmarked: number
    status: number
    priority: number
    toDoListId: number
    _all: number
  }


  export type ToDoAvgAggregateInputType = {
    id?: true
    parentId?: true
    priority?: true
    toDoListId?: true
  }

  export type ToDoSumAggregateInputType = {
    id?: true
    parentId?: true
    priority?: true
    toDoListId?: true
  }

  export type ToDoMinAggregateInputType = {
    id?: true
    createdAt?: true
    task?: true
    dueAt?: true
    details?: true
    parentId?: true
    category?: true
    bookmarked?: true
    status?: true
    priority?: true
    toDoListId?: true
  }

  export type ToDoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    task?: true
    dueAt?: true
    details?: true
    parentId?: true
    category?: true
    bookmarked?: true
    status?: true
    priority?: true
    toDoListId?: true
  }

  export type ToDoCountAggregateInputType = {
    id?: true
    createdAt?: true
    task?: true
    dueAt?: true
    details?: true
    parentId?: true
    category?: true
    bookmarked?: true
    status?: true
    priority?: true
    toDoListId?: true
    _all?: true
  }

  export type ToDoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ToDo to aggregate.
     */
    where?: ToDoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToDos to fetch.
     */
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ToDoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToDos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToDos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ToDos
    **/
    _count?: true | ToDoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ToDoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ToDoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ToDoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ToDoMaxAggregateInputType
  }

  export type GetToDoAggregateType<T extends ToDoAggregateArgs> = {
        [P in keyof T & keyof AggregateToDo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToDo[P]>
      : GetScalarType<T[P], AggregateToDo[P]>
  }




  export type ToDoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToDoWhereInput
    orderBy?: ToDoOrderByWithAggregationInput | ToDoOrderByWithAggregationInput[]
    by: ToDoScalarFieldEnum[] | ToDoScalarFieldEnum
    having?: ToDoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ToDoCountAggregateInputType | true
    _avg?: ToDoAvgAggregateInputType
    _sum?: ToDoSumAggregateInputType
    _min?: ToDoMinAggregateInputType
    _max?: ToDoMaxAggregateInputType
  }

  export type ToDoGroupByOutputType = {
    id: number
    createdAt: Date
    task: string
    dueAt: Date | null
    details: string | null
    parentId: number | null
    category: $Enums.TaskCategory | null
    bookmarked: boolean
    status: $Enums.ToDoListStatus
    priority: number
    toDoListId: number | null
    _count: ToDoCountAggregateOutputType | null
    _avg: ToDoAvgAggregateOutputType | null
    _sum: ToDoSumAggregateOutputType | null
    _min: ToDoMinAggregateOutputType | null
    _max: ToDoMaxAggregateOutputType | null
  }

  type GetToDoGroupByPayload<T extends ToDoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ToDoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ToDoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ToDoGroupByOutputType[P]>
            : GetScalarType<T[P], ToDoGroupByOutputType[P]>
        }
      >
    >


  export type ToDoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    task?: boolean
    dueAt?: boolean
    details?: boolean
    parentId?: boolean
    category?: boolean
    bookmarked?: boolean
    status?: boolean
    priority?: boolean
    toDoListId?: boolean
    associatedNotes?: boolean | ToDo$associatedNotesArgs<ExtArgs>
    tags?: boolean | ToDo$tagsArgs<ExtArgs>
    topics?: boolean | ToDo$topicsArgs<ExtArgs>
    subjects?: boolean | ToDo$subjectsArgs<ExtArgs>
    parent?: boolean | ToDo$parentArgs<ExtArgs>
    child?: boolean | ToDo$childArgs<ExtArgs>
    ToDoList?: boolean | ToDo$ToDoListArgs<ExtArgs>
    _count?: boolean | ToDoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toDo"]>

  export type ToDoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    task?: boolean
    dueAt?: boolean
    details?: boolean
    parentId?: boolean
    category?: boolean
    bookmarked?: boolean
    status?: boolean
    priority?: boolean
    toDoListId?: boolean
    parent?: boolean | ToDo$parentArgs<ExtArgs>
    ToDoList?: boolean | ToDo$ToDoListArgs<ExtArgs>
  }, ExtArgs["result"]["toDo"]>

  export type ToDoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    task?: boolean
    dueAt?: boolean
    details?: boolean
    parentId?: boolean
    category?: boolean
    bookmarked?: boolean
    status?: boolean
    priority?: boolean
    toDoListId?: boolean
  }

  export type ToDoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    associatedNotes?: boolean | ToDo$associatedNotesArgs<ExtArgs>
    tags?: boolean | ToDo$tagsArgs<ExtArgs>
    topics?: boolean | ToDo$topicsArgs<ExtArgs>
    subjects?: boolean | ToDo$subjectsArgs<ExtArgs>
    parent?: boolean | ToDo$parentArgs<ExtArgs>
    child?: boolean | ToDo$childArgs<ExtArgs>
    ToDoList?: boolean | ToDo$ToDoListArgs<ExtArgs>
    _count?: boolean | ToDoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ToDoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ToDo$parentArgs<ExtArgs>
    ToDoList?: boolean | ToDo$ToDoListArgs<ExtArgs>
  }

  export type $ToDoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ToDo"
    objects: {
      associatedNotes: Prisma.$MdxNotePayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      parent: Prisma.$ToDoPayload<ExtArgs> | null
      child: Prisma.$ToDoPayload<ExtArgs>[]
      ToDoList: Prisma.$ToDoListPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      task: string
      dueAt: Date | null
      details: string | null
      parentId: number | null
      category: $Enums.TaskCategory | null
      bookmarked: boolean
      status: $Enums.ToDoListStatus
      priority: number
      toDoListId: number | null
    }, ExtArgs["result"]["toDo"]>
    composites: {}
  }

  type ToDoGetPayload<S extends boolean | null | undefined | ToDoDefaultArgs> = $Result.GetResult<Prisma.$ToDoPayload, S>

  type ToDoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ToDoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ToDoCountAggregateInputType | true
    }

  export interface ToDoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ToDo'], meta: { name: 'ToDo' } }
    /**
     * Find zero or one ToDo that matches the filter.
     * @param {ToDoFindUniqueArgs} args - Arguments to find a ToDo
     * @example
     * // Get one ToDo
     * const toDo = await prisma.toDo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ToDoFindUniqueArgs>(args: SelectSubset<T, ToDoFindUniqueArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ToDo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ToDoFindUniqueOrThrowArgs} args - Arguments to find a ToDo
     * @example
     * // Get one ToDo
     * const toDo = await prisma.toDo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ToDoFindUniqueOrThrowArgs>(args: SelectSubset<T, ToDoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ToDo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoFindFirstArgs} args - Arguments to find a ToDo
     * @example
     * // Get one ToDo
     * const toDo = await prisma.toDo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ToDoFindFirstArgs>(args?: SelectSubset<T, ToDoFindFirstArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ToDo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoFindFirstOrThrowArgs} args - Arguments to find a ToDo
     * @example
     * // Get one ToDo
     * const toDo = await prisma.toDo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ToDoFindFirstOrThrowArgs>(args?: SelectSubset<T, ToDoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ToDos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ToDos
     * const toDos = await prisma.toDo.findMany()
     * 
     * // Get first 10 ToDos
     * const toDos = await prisma.toDo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const toDoWithIdOnly = await prisma.toDo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ToDoFindManyArgs>(args?: SelectSubset<T, ToDoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ToDo.
     * @param {ToDoCreateArgs} args - Arguments to create a ToDo.
     * @example
     * // Create one ToDo
     * const ToDo = await prisma.toDo.create({
     *   data: {
     *     // ... data to create a ToDo
     *   }
     * })
     * 
     */
    create<T extends ToDoCreateArgs>(args: SelectSubset<T, ToDoCreateArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ToDos.
     * @param {ToDoCreateManyArgs} args - Arguments to create many ToDos.
     * @example
     * // Create many ToDos
     * const toDo = await prisma.toDo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ToDoCreateManyArgs>(args?: SelectSubset<T, ToDoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ToDos and returns the data saved in the database.
     * @param {ToDoCreateManyAndReturnArgs} args - Arguments to create many ToDos.
     * @example
     * // Create many ToDos
     * const toDo = await prisma.toDo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ToDos and only return the `id`
     * const toDoWithIdOnly = await prisma.toDo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ToDoCreateManyAndReturnArgs>(args?: SelectSubset<T, ToDoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ToDo.
     * @param {ToDoDeleteArgs} args - Arguments to delete one ToDo.
     * @example
     * // Delete one ToDo
     * const ToDo = await prisma.toDo.delete({
     *   where: {
     *     // ... filter to delete one ToDo
     *   }
     * })
     * 
     */
    delete<T extends ToDoDeleteArgs>(args: SelectSubset<T, ToDoDeleteArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ToDo.
     * @param {ToDoUpdateArgs} args - Arguments to update one ToDo.
     * @example
     * // Update one ToDo
     * const toDo = await prisma.toDo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ToDoUpdateArgs>(args: SelectSubset<T, ToDoUpdateArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ToDos.
     * @param {ToDoDeleteManyArgs} args - Arguments to filter ToDos to delete.
     * @example
     * // Delete a few ToDos
     * const { count } = await prisma.toDo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ToDoDeleteManyArgs>(args?: SelectSubset<T, ToDoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ToDos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ToDos
     * const toDo = await prisma.toDo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ToDoUpdateManyArgs>(args: SelectSubset<T, ToDoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ToDo.
     * @param {ToDoUpsertArgs} args - Arguments to update or create a ToDo.
     * @example
     * // Update or create a ToDo
     * const toDo = await prisma.toDo.upsert({
     *   create: {
     *     // ... data to create a ToDo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ToDo we want to update
     *   }
     * })
     */
    upsert<T extends ToDoUpsertArgs>(args: SelectSubset<T, ToDoUpsertArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ToDos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoCountArgs} args - Arguments to filter ToDos to count.
     * @example
     * // Count the number of ToDos
     * const count = await prisma.toDo.count({
     *   where: {
     *     // ... the filter for the ToDos we want to count
     *   }
     * })
    **/
    count<T extends ToDoCountArgs>(
      args?: Subset<T, ToDoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ToDoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ToDo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ToDoAggregateArgs>(args: Subset<T, ToDoAggregateArgs>): Prisma.PrismaPromise<GetToDoAggregateType<T>>

    /**
     * Group by ToDo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToDoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ToDoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ToDoGroupByArgs['orderBy'] }
        : { orderBy?: ToDoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ToDoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToDoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ToDo model
   */
  readonly fields: ToDoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ToDo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ToDoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    associatedNotes<T extends ToDo$associatedNotesArgs<ExtArgs> = {}>(args?: Subset<T, ToDo$associatedNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MdxNotePayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends ToDo$tagsArgs<ExtArgs> = {}>(args?: Subset<T, ToDo$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    topics<T extends ToDo$topicsArgs<ExtArgs> = {}>(args?: Subset<T, ToDo$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends ToDo$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, ToDo$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    parent<T extends ToDo$parentArgs<ExtArgs> = {}>(args?: Subset<T, ToDo$parentArgs<ExtArgs>>): Prisma__ToDoClient<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    child<T extends ToDo$childArgs<ExtArgs> = {}>(args?: Subset<T, ToDo$childArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToDoPayload<ExtArgs>, T, "findMany"> | Null>
    ToDoList<T extends ToDo$ToDoListArgs<ExtArgs> = {}>(args?: Subset<T, ToDo$ToDoListArgs<ExtArgs>>): Prisma__ToDoListClient<$Result.GetResult<Prisma.$ToDoListPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ToDo model
   */ 
  interface ToDoFieldRefs {
    readonly id: FieldRef<"ToDo", 'Int'>
    readonly createdAt: FieldRef<"ToDo", 'DateTime'>
    readonly task: FieldRef<"ToDo", 'String'>
    readonly dueAt: FieldRef<"ToDo", 'DateTime'>
    readonly details: FieldRef<"ToDo", 'String'>
    readonly parentId: FieldRef<"ToDo", 'Int'>
    readonly category: FieldRef<"ToDo", 'TaskCategory'>
    readonly bookmarked: FieldRef<"ToDo", 'Boolean'>
    readonly status: FieldRef<"ToDo", 'ToDoListStatus'>
    readonly priority: FieldRef<"ToDo", 'Int'>
    readonly toDoListId: FieldRef<"ToDo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ToDo findUnique
   */
  export type ToDoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * Filter, which ToDo to fetch.
     */
    where: ToDoWhereUniqueInput
  }

  /**
   * ToDo findUniqueOrThrow
   */
  export type ToDoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * Filter, which ToDo to fetch.
     */
    where: ToDoWhereUniqueInput
  }

  /**
   * ToDo findFirst
   */
  export type ToDoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * Filter, which ToDo to fetch.
     */
    where?: ToDoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToDos to fetch.
     */
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ToDos.
     */
    cursor?: ToDoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToDos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToDos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ToDos.
     */
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * ToDo findFirstOrThrow
   */
  export type ToDoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * Filter, which ToDo to fetch.
     */
    where?: ToDoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToDos to fetch.
     */
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ToDos.
     */
    cursor?: ToDoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToDos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToDos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ToDos.
     */
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * ToDo findMany
   */
  export type ToDoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * Filter, which ToDos to fetch.
     */
    where?: ToDoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToDos to fetch.
     */
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ToDos.
     */
    cursor?: ToDoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToDos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToDos.
     */
    skip?: number
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * ToDo create
   */
  export type ToDoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * The data needed to create a ToDo.
     */
    data: XOR<ToDoCreateInput, ToDoUncheckedCreateInput>
  }

  /**
   * ToDo createMany
   */
  export type ToDoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ToDos.
     */
    data: ToDoCreateManyInput | ToDoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ToDo createManyAndReturn
   */
  export type ToDoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ToDos.
     */
    data: ToDoCreateManyInput | ToDoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ToDo update
   */
  export type ToDoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * The data needed to update a ToDo.
     */
    data: XOR<ToDoUpdateInput, ToDoUncheckedUpdateInput>
    /**
     * Choose, which ToDo to update.
     */
    where: ToDoWhereUniqueInput
  }

  /**
   * ToDo updateMany
   */
  export type ToDoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ToDos.
     */
    data: XOR<ToDoUpdateManyMutationInput, ToDoUncheckedUpdateManyInput>
    /**
     * Filter which ToDos to update
     */
    where?: ToDoWhereInput
  }

  /**
   * ToDo upsert
   */
  export type ToDoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * The filter to search for the ToDo to update in case it exists.
     */
    where: ToDoWhereUniqueInput
    /**
     * In case the ToDo found by the `where` argument doesn't exist, create a new ToDo with this data.
     */
    create: XOR<ToDoCreateInput, ToDoUncheckedCreateInput>
    /**
     * In case the ToDo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ToDoUpdateInput, ToDoUncheckedUpdateInput>
  }

  /**
   * ToDo delete
   */
  export type ToDoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    /**
     * Filter which ToDo to delete.
     */
    where: ToDoWhereUniqueInput
  }

  /**
   * ToDo deleteMany
   */
  export type ToDoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ToDos to delete
     */
    where?: ToDoWhereInput
  }

  /**
   * ToDo.associatedNotes
   */
  export type ToDo$associatedNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MdxNote
     */
    select?: MdxNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MdxNoteInclude<ExtArgs> | null
    where?: MdxNoteWhereInput
    orderBy?: MdxNoteOrderByWithRelationInput | MdxNoteOrderByWithRelationInput[]
    cursor?: MdxNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MdxNoteScalarFieldEnum | MdxNoteScalarFieldEnum[]
  }

  /**
   * ToDo.tags
   */
  export type ToDo$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * ToDo.topics
   */
  export type ToDo$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * ToDo.subjects
   */
  export type ToDo$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * ToDo.parent
   */
  export type ToDo$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    where?: ToDoWhereInput
  }

  /**
   * ToDo.child
   */
  export type ToDo$childArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
    where?: ToDoWhereInput
    orderBy?: ToDoOrderByWithRelationInput | ToDoOrderByWithRelationInput[]
    cursor?: ToDoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToDoScalarFieldEnum | ToDoScalarFieldEnum[]
  }

  /**
   * ToDo.ToDoList
   */
  export type ToDo$ToDoListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDoList
     */
    select?: ToDoListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoListInclude<ExtArgs> | null
    where?: ToDoListWhereInput
  }

  /**
   * ToDo without action
   */
  export type ToDoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToDo
     */
    select?: ToDoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToDoInclude<ExtArgs> | null
  }


  /**
   * Model KanBanCard
   */

  export type AggregateKanBanCard = {
    _count: KanBanCardCountAggregateOutputType | null
    _avg: KanBanCardAvgAggregateOutputType | null
    _sum: KanBanCardSumAggregateOutputType | null
    _min: KanBanCardMinAggregateOutputType | null
    _max: KanBanCardMaxAggregateOutputType | null
  }

  export type KanBanCardAvgAggregateOutputType = {
    id: number | null
    listId: number | null
    indexWithinList: number | null
  }

  export type KanBanCardSumAggregateOutputType = {
    id: number | null
    listId: number | null
    indexWithinList: number | null
  }

  export type KanBanCardMinAggregateOutputType = {
    id: number | null
    listId: number | null
    indexWithinList: number | null
    label: string | null
    details: string | null
  }

  export type KanBanCardMaxAggregateOutputType = {
    id: number | null
    listId: number | null
    indexWithinList: number | null
    label: string | null
    details: string | null
  }

  export type KanBanCardCountAggregateOutputType = {
    id: number
    listId: number
    indexWithinList: number
    label: number
    details: number
    _all: number
  }


  export type KanBanCardAvgAggregateInputType = {
    id?: true
    listId?: true
    indexWithinList?: true
  }

  export type KanBanCardSumAggregateInputType = {
    id?: true
    listId?: true
    indexWithinList?: true
  }

  export type KanBanCardMinAggregateInputType = {
    id?: true
    listId?: true
    indexWithinList?: true
    label?: true
    details?: true
  }

  export type KanBanCardMaxAggregateInputType = {
    id?: true
    listId?: true
    indexWithinList?: true
    label?: true
    details?: true
  }

  export type KanBanCardCountAggregateInputType = {
    id?: true
    listId?: true
    indexWithinList?: true
    label?: true
    details?: true
    _all?: true
  }

  export type KanBanCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KanBanCard to aggregate.
     */
    where?: KanBanCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KanBanCards to fetch.
     */
    orderBy?: KanBanCardOrderByWithRelationInput | KanBanCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KanBanCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KanBanCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KanBanCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KanBanCards
    **/
    _count?: true | KanBanCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KanBanCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KanBanCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KanBanCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KanBanCardMaxAggregateInputType
  }

  export type GetKanBanCardAggregateType<T extends KanBanCardAggregateArgs> = {
        [P in keyof T & keyof AggregateKanBanCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKanBanCard[P]>
      : GetScalarType<T[P], AggregateKanBanCard[P]>
  }




  export type KanBanCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KanBanCardWhereInput
    orderBy?: KanBanCardOrderByWithAggregationInput | KanBanCardOrderByWithAggregationInput[]
    by: KanBanCardScalarFieldEnum[] | KanBanCardScalarFieldEnum
    having?: KanBanCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KanBanCardCountAggregateInputType | true
    _avg?: KanBanCardAvgAggregateInputType
    _sum?: KanBanCardSumAggregateInputType
    _min?: KanBanCardMinAggregateInputType
    _max?: KanBanCardMaxAggregateInputType
  }

  export type KanBanCardGroupByOutputType = {
    id: number
    listId: number | null
    indexWithinList: number
    label: string | null
    details: string | null
    _count: KanBanCardCountAggregateOutputType | null
    _avg: KanBanCardAvgAggregateOutputType | null
    _sum: KanBanCardSumAggregateOutputType | null
    _min: KanBanCardMinAggregateOutputType | null
    _max: KanBanCardMaxAggregateOutputType | null
  }

  type GetKanBanCardGroupByPayload<T extends KanBanCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KanBanCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KanBanCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KanBanCardGroupByOutputType[P]>
            : GetScalarType<T[P], KanBanCardGroupByOutputType[P]>
        }
      >
    >


  export type KanBanCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    indexWithinList?: boolean
    label?: boolean
    details?: boolean
    KanBanList?: boolean | KanBanCard$KanBanListArgs<ExtArgs>
  }, ExtArgs["result"]["kanBanCard"]>

  export type KanBanCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    indexWithinList?: boolean
    label?: boolean
    details?: boolean
    KanBanList?: boolean | KanBanCard$KanBanListArgs<ExtArgs>
  }, ExtArgs["result"]["kanBanCard"]>

  export type KanBanCardSelectScalar = {
    id?: boolean
    listId?: boolean
    indexWithinList?: boolean
    label?: boolean
    details?: boolean
  }

  export type KanBanCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KanBanList?: boolean | KanBanCard$KanBanListArgs<ExtArgs>
  }
  export type KanBanCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KanBanList?: boolean | KanBanCard$KanBanListArgs<ExtArgs>
  }

  export type $KanBanCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KanBanCard"
    objects: {
      KanBanList: Prisma.$KanBanListPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      listId: number | null
      indexWithinList: number
      label: string | null
      details: string | null
    }, ExtArgs["result"]["kanBanCard"]>
    composites: {}
  }

  type KanBanCardGetPayload<S extends boolean | null | undefined | KanBanCardDefaultArgs> = $Result.GetResult<Prisma.$KanBanCardPayload, S>

  type KanBanCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KanBanCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KanBanCardCountAggregateInputType | true
    }

  export interface KanBanCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KanBanCard'], meta: { name: 'KanBanCard' } }
    /**
     * Find zero or one KanBanCard that matches the filter.
     * @param {KanBanCardFindUniqueArgs} args - Arguments to find a KanBanCard
     * @example
     * // Get one KanBanCard
     * const kanBanCard = await prisma.kanBanCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KanBanCardFindUniqueArgs>(args: SelectSubset<T, KanBanCardFindUniqueArgs<ExtArgs>>): Prisma__KanBanCardClient<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KanBanCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KanBanCardFindUniqueOrThrowArgs} args - Arguments to find a KanBanCard
     * @example
     * // Get one KanBanCard
     * const kanBanCard = await prisma.kanBanCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KanBanCardFindUniqueOrThrowArgs>(args: SelectSubset<T, KanBanCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KanBanCardClient<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KanBanCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanCardFindFirstArgs} args - Arguments to find a KanBanCard
     * @example
     * // Get one KanBanCard
     * const kanBanCard = await prisma.kanBanCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KanBanCardFindFirstArgs>(args?: SelectSubset<T, KanBanCardFindFirstArgs<ExtArgs>>): Prisma__KanBanCardClient<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KanBanCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanCardFindFirstOrThrowArgs} args - Arguments to find a KanBanCard
     * @example
     * // Get one KanBanCard
     * const kanBanCard = await prisma.kanBanCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KanBanCardFindFirstOrThrowArgs>(args?: SelectSubset<T, KanBanCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__KanBanCardClient<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KanBanCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KanBanCards
     * const kanBanCards = await prisma.kanBanCard.findMany()
     * 
     * // Get first 10 KanBanCards
     * const kanBanCards = await prisma.kanBanCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kanBanCardWithIdOnly = await prisma.kanBanCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KanBanCardFindManyArgs>(args?: SelectSubset<T, KanBanCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KanBanCard.
     * @param {KanBanCardCreateArgs} args - Arguments to create a KanBanCard.
     * @example
     * // Create one KanBanCard
     * const KanBanCard = await prisma.kanBanCard.create({
     *   data: {
     *     // ... data to create a KanBanCard
     *   }
     * })
     * 
     */
    create<T extends KanBanCardCreateArgs>(args: SelectSubset<T, KanBanCardCreateArgs<ExtArgs>>): Prisma__KanBanCardClient<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KanBanCards.
     * @param {KanBanCardCreateManyArgs} args - Arguments to create many KanBanCards.
     * @example
     * // Create many KanBanCards
     * const kanBanCard = await prisma.kanBanCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KanBanCardCreateManyArgs>(args?: SelectSubset<T, KanBanCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KanBanCards and returns the data saved in the database.
     * @param {KanBanCardCreateManyAndReturnArgs} args - Arguments to create many KanBanCards.
     * @example
     * // Create many KanBanCards
     * const kanBanCard = await prisma.kanBanCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KanBanCards and only return the `id`
     * const kanBanCardWithIdOnly = await prisma.kanBanCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KanBanCardCreateManyAndReturnArgs>(args?: SelectSubset<T, KanBanCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KanBanCard.
     * @param {KanBanCardDeleteArgs} args - Arguments to delete one KanBanCard.
     * @example
     * // Delete one KanBanCard
     * const KanBanCard = await prisma.kanBanCard.delete({
     *   where: {
     *     // ... filter to delete one KanBanCard
     *   }
     * })
     * 
     */
    delete<T extends KanBanCardDeleteArgs>(args: SelectSubset<T, KanBanCardDeleteArgs<ExtArgs>>): Prisma__KanBanCardClient<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KanBanCard.
     * @param {KanBanCardUpdateArgs} args - Arguments to update one KanBanCard.
     * @example
     * // Update one KanBanCard
     * const kanBanCard = await prisma.kanBanCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KanBanCardUpdateArgs>(args: SelectSubset<T, KanBanCardUpdateArgs<ExtArgs>>): Prisma__KanBanCardClient<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KanBanCards.
     * @param {KanBanCardDeleteManyArgs} args - Arguments to filter KanBanCards to delete.
     * @example
     * // Delete a few KanBanCards
     * const { count } = await prisma.kanBanCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KanBanCardDeleteManyArgs>(args?: SelectSubset<T, KanBanCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KanBanCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KanBanCards
     * const kanBanCard = await prisma.kanBanCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KanBanCardUpdateManyArgs>(args: SelectSubset<T, KanBanCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KanBanCard.
     * @param {KanBanCardUpsertArgs} args - Arguments to update or create a KanBanCard.
     * @example
     * // Update or create a KanBanCard
     * const kanBanCard = await prisma.kanBanCard.upsert({
     *   create: {
     *     // ... data to create a KanBanCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KanBanCard we want to update
     *   }
     * })
     */
    upsert<T extends KanBanCardUpsertArgs>(args: SelectSubset<T, KanBanCardUpsertArgs<ExtArgs>>): Prisma__KanBanCardClient<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KanBanCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanCardCountArgs} args - Arguments to filter KanBanCards to count.
     * @example
     * // Count the number of KanBanCards
     * const count = await prisma.kanBanCard.count({
     *   where: {
     *     // ... the filter for the KanBanCards we want to count
     *   }
     * })
    **/
    count<T extends KanBanCardCountArgs>(
      args?: Subset<T, KanBanCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KanBanCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KanBanCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KanBanCardAggregateArgs>(args: Subset<T, KanBanCardAggregateArgs>): Prisma.PrismaPromise<GetKanBanCardAggregateType<T>>

    /**
     * Group by KanBanCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KanBanCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KanBanCardGroupByArgs['orderBy'] }
        : { orderBy?: KanBanCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KanBanCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKanBanCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KanBanCard model
   */
  readonly fields: KanBanCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KanBanCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KanBanCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KanBanList<T extends KanBanCard$KanBanListArgs<ExtArgs> = {}>(args?: Subset<T, KanBanCard$KanBanListArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KanBanCard model
   */ 
  interface KanBanCardFieldRefs {
    readonly id: FieldRef<"KanBanCard", 'Int'>
    readonly listId: FieldRef<"KanBanCard", 'Int'>
    readonly indexWithinList: FieldRef<"KanBanCard", 'Int'>
    readonly label: FieldRef<"KanBanCard", 'String'>
    readonly details: FieldRef<"KanBanCard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KanBanCard findUnique
   */
  export type KanBanCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * Filter, which KanBanCard to fetch.
     */
    where: KanBanCardWhereUniqueInput
  }

  /**
   * KanBanCard findUniqueOrThrow
   */
  export type KanBanCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * Filter, which KanBanCard to fetch.
     */
    where: KanBanCardWhereUniqueInput
  }

  /**
   * KanBanCard findFirst
   */
  export type KanBanCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * Filter, which KanBanCard to fetch.
     */
    where?: KanBanCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KanBanCards to fetch.
     */
    orderBy?: KanBanCardOrderByWithRelationInput | KanBanCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KanBanCards.
     */
    cursor?: KanBanCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KanBanCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KanBanCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KanBanCards.
     */
    distinct?: KanBanCardScalarFieldEnum | KanBanCardScalarFieldEnum[]
  }

  /**
   * KanBanCard findFirstOrThrow
   */
  export type KanBanCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * Filter, which KanBanCard to fetch.
     */
    where?: KanBanCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KanBanCards to fetch.
     */
    orderBy?: KanBanCardOrderByWithRelationInput | KanBanCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KanBanCards.
     */
    cursor?: KanBanCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KanBanCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KanBanCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KanBanCards.
     */
    distinct?: KanBanCardScalarFieldEnum | KanBanCardScalarFieldEnum[]
  }

  /**
   * KanBanCard findMany
   */
  export type KanBanCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * Filter, which KanBanCards to fetch.
     */
    where?: KanBanCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KanBanCards to fetch.
     */
    orderBy?: KanBanCardOrderByWithRelationInput | KanBanCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KanBanCards.
     */
    cursor?: KanBanCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KanBanCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KanBanCards.
     */
    skip?: number
    distinct?: KanBanCardScalarFieldEnum | KanBanCardScalarFieldEnum[]
  }

  /**
   * KanBanCard create
   */
  export type KanBanCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * The data needed to create a KanBanCard.
     */
    data: XOR<KanBanCardCreateInput, KanBanCardUncheckedCreateInput>
  }

  /**
   * KanBanCard createMany
   */
  export type KanBanCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KanBanCards.
     */
    data: KanBanCardCreateManyInput | KanBanCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KanBanCard createManyAndReturn
   */
  export type KanBanCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KanBanCards.
     */
    data: KanBanCardCreateManyInput | KanBanCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KanBanCard update
   */
  export type KanBanCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * The data needed to update a KanBanCard.
     */
    data: XOR<KanBanCardUpdateInput, KanBanCardUncheckedUpdateInput>
    /**
     * Choose, which KanBanCard to update.
     */
    where: KanBanCardWhereUniqueInput
  }

  /**
   * KanBanCard updateMany
   */
  export type KanBanCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KanBanCards.
     */
    data: XOR<KanBanCardUpdateManyMutationInput, KanBanCardUncheckedUpdateManyInput>
    /**
     * Filter which KanBanCards to update
     */
    where?: KanBanCardWhereInput
  }

  /**
   * KanBanCard upsert
   */
  export type KanBanCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * The filter to search for the KanBanCard to update in case it exists.
     */
    where: KanBanCardWhereUniqueInput
    /**
     * In case the KanBanCard found by the `where` argument doesn't exist, create a new KanBanCard with this data.
     */
    create: XOR<KanBanCardCreateInput, KanBanCardUncheckedCreateInput>
    /**
     * In case the KanBanCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KanBanCardUpdateInput, KanBanCardUncheckedUpdateInput>
  }

  /**
   * KanBanCard delete
   */
  export type KanBanCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    /**
     * Filter which KanBanCard to delete.
     */
    where: KanBanCardWhereUniqueInput
  }

  /**
   * KanBanCard deleteMany
   */
  export type KanBanCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KanBanCards to delete
     */
    where?: KanBanCardWhereInput
  }

  /**
   * KanBanCard.KanBanList
   */
  export type KanBanCard$KanBanListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    where?: KanBanListWhereInput
  }

  /**
   * KanBanCard without action
   */
  export type KanBanCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
  }


  /**
   * Model KanBanList
   */

  export type AggregateKanBanList = {
    _count: KanBanListCountAggregateOutputType | null
    _avg: KanBanListAvgAggregateOutputType | null
    _sum: KanBanListSumAggregateOutputType | null
    _min: KanBanListMinAggregateOutputType | null
    _max: KanBanListMaxAggregateOutputType | null
  }

  export type KanBanListAvgAggregateOutputType = {
    id: number | null
    indexWithinBoard: number | null
    boardId: number | null
  }

  export type KanBanListSumAggregateOutputType = {
    id: number | null
    indexWithinBoard: number | null
    boardId: number | null
  }

  export type KanBanListMinAggregateOutputType = {
    id: number | null
    indexWithinBoard: number | null
    title: string | null
    boardId: number | null
  }

  export type KanBanListMaxAggregateOutputType = {
    id: number | null
    indexWithinBoard: number | null
    title: string | null
    boardId: number | null
  }

  export type KanBanListCountAggregateOutputType = {
    id: number
    indexWithinBoard: number
    title: number
    boardId: number
    _all: number
  }


  export type KanBanListAvgAggregateInputType = {
    id?: true
    indexWithinBoard?: true
    boardId?: true
  }

  export type KanBanListSumAggregateInputType = {
    id?: true
    indexWithinBoard?: true
    boardId?: true
  }

  export type KanBanListMinAggregateInputType = {
    id?: true
    indexWithinBoard?: true
    title?: true
    boardId?: true
  }

  export type KanBanListMaxAggregateInputType = {
    id?: true
    indexWithinBoard?: true
    title?: true
    boardId?: true
  }

  export type KanBanListCountAggregateInputType = {
    id?: true
    indexWithinBoard?: true
    title?: true
    boardId?: true
    _all?: true
  }

  export type KanBanListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KanBanList to aggregate.
     */
    where?: KanBanListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KanBanLists to fetch.
     */
    orderBy?: KanBanListOrderByWithRelationInput | KanBanListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KanBanListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KanBanLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KanBanLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KanBanLists
    **/
    _count?: true | KanBanListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KanBanListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KanBanListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KanBanListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KanBanListMaxAggregateInputType
  }

  export type GetKanBanListAggregateType<T extends KanBanListAggregateArgs> = {
        [P in keyof T & keyof AggregateKanBanList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKanBanList[P]>
      : GetScalarType<T[P], AggregateKanBanList[P]>
  }




  export type KanBanListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KanBanListWhereInput
    orderBy?: KanBanListOrderByWithAggregationInput | KanBanListOrderByWithAggregationInput[]
    by: KanBanListScalarFieldEnum[] | KanBanListScalarFieldEnum
    having?: KanBanListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KanBanListCountAggregateInputType | true
    _avg?: KanBanListAvgAggregateInputType
    _sum?: KanBanListSumAggregateInputType
    _min?: KanBanListMinAggregateInputType
    _max?: KanBanListMaxAggregateInputType
  }

  export type KanBanListGroupByOutputType = {
    id: number
    indexWithinBoard: number
    title: string | null
    boardId: number | null
    _count: KanBanListCountAggregateOutputType | null
    _avg: KanBanListAvgAggregateOutputType | null
    _sum: KanBanListSumAggregateOutputType | null
    _min: KanBanListMinAggregateOutputType | null
    _max: KanBanListMaxAggregateOutputType | null
  }

  type GetKanBanListGroupByPayload<T extends KanBanListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KanBanListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KanBanListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KanBanListGroupByOutputType[P]>
            : GetScalarType<T[P], KanBanListGroupByOutputType[P]>
        }
      >
    >


  export type KanBanListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indexWithinBoard?: boolean
    title?: boolean
    boardId?: boolean
    cards?: boolean | KanBanList$cardsArgs<ExtArgs>
    Kanban?: boolean | KanBanList$KanbanArgs<ExtArgs>
    _count?: boolean | KanBanListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kanBanList"]>

  export type KanBanListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indexWithinBoard?: boolean
    title?: boolean
    boardId?: boolean
    Kanban?: boolean | KanBanList$KanbanArgs<ExtArgs>
  }, ExtArgs["result"]["kanBanList"]>

  export type KanBanListSelectScalar = {
    id?: boolean
    indexWithinBoard?: boolean
    title?: boolean
    boardId?: boolean
  }

  export type KanBanListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cards?: boolean | KanBanList$cardsArgs<ExtArgs>
    Kanban?: boolean | KanBanList$KanbanArgs<ExtArgs>
    _count?: boolean | KanBanListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KanBanListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Kanban?: boolean | KanBanList$KanbanArgs<ExtArgs>
  }

  export type $KanBanListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KanBanList"
    objects: {
      cards: Prisma.$KanBanCardPayload<ExtArgs>[]
      Kanban: Prisma.$KanbanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      indexWithinBoard: number
      title: string | null
      boardId: number | null
    }, ExtArgs["result"]["kanBanList"]>
    composites: {}
  }

  type KanBanListGetPayload<S extends boolean | null | undefined | KanBanListDefaultArgs> = $Result.GetResult<Prisma.$KanBanListPayload, S>

  type KanBanListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KanBanListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KanBanListCountAggregateInputType | true
    }

  export interface KanBanListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KanBanList'], meta: { name: 'KanBanList' } }
    /**
     * Find zero or one KanBanList that matches the filter.
     * @param {KanBanListFindUniqueArgs} args - Arguments to find a KanBanList
     * @example
     * // Get one KanBanList
     * const kanBanList = await prisma.kanBanList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KanBanListFindUniqueArgs>(args: SelectSubset<T, KanBanListFindUniqueArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KanBanList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KanBanListFindUniqueOrThrowArgs} args - Arguments to find a KanBanList
     * @example
     * // Get one KanBanList
     * const kanBanList = await prisma.kanBanList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KanBanListFindUniqueOrThrowArgs>(args: SelectSubset<T, KanBanListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KanBanList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanListFindFirstArgs} args - Arguments to find a KanBanList
     * @example
     * // Get one KanBanList
     * const kanBanList = await prisma.kanBanList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KanBanListFindFirstArgs>(args?: SelectSubset<T, KanBanListFindFirstArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KanBanList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanListFindFirstOrThrowArgs} args - Arguments to find a KanBanList
     * @example
     * // Get one KanBanList
     * const kanBanList = await prisma.kanBanList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KanBanListFindFirstOrThrowArgs>(args?: SelectSubset<T, KanBanListFindFirstOrThrowArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KanBanLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KanBanLists
     * const kanBanLists = await prisma.kanBanList.findMany()
     * 
     * // Get first 10 KanBanLists
     * const kanBanLists = await prisma.kanBanList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kanBanListWithIdOnly = await prisma.kanBanList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KanBanListFindManyArgs>(args?: SelectSubset<T, KanBanListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KanBanList.
     * @param {KanBanListCreateArgs} args - Arguments to create a KanBanList.
     * @example
     * // Create one KanBanList
     * const KanBanList = await prisma.kanBanList.create({
     *   data: {
     *     // ... data to create a KanBanList
     *   }
     * })
     * 
     */
    create<T extends KanBanListCreateArgs>(args: SelectSubset<T, KanBanListCreateArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KanBanLists.
     * @param {KanBanListCreateManyArgs} args - Arguments to create many KanBanLists.
     * @example
     * // Create many KanBanLists
     * const kanBanList = await prisma.kanBanList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KanBanListCreateManyArgs>(args?: SelectSubset<T, KanBanListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KanBanLists and returns the data saved in the database.
     * @param {KanBanListCreateManyAndReturnArgs} args - Arguments to create many KanBanLists.
     * @example
     * // Create many KanBanLists
     * const kanBanList = await prisma.kanBanList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KanBanLists and only return the `id`
     * const kanBanListWithIdOnly = await prisma.kanBanList.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KanBanListCreateManyAndReturnArgs>(args?: SelectSubset<T, KanBanListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KanBanList.
     * @param {KanBanListDeleteArgs} args - Arguments to delete one KanBanList.
     * @example
     * // Delete one KanBanList
     * const KanBanList = await prisma.kanBanList.delete({
     *   where: {
     *     // ... filter to delete one KanBanList
     *   }
     * })
     * 
     */
    delete<T extends KanBanListDeleteArgs>(args: SelectSubset<T, KanBanListDeleteArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KanBanList.
     * @param {KanBanListUpdateArgs} args - Arguments to update one KanBanList.
     * @example
     * // Update one KanBanList
     * const kanBanList = await prisma.kanBanList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KanBanListUpdateArgs>(args: SelectSubset<T, KanBanListUpdateArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KanBanLists.
     * @param {KanBanListDeleteManyArgs} args - Arguments to filter KanBanLists to delete.
     * @example
     * // Delete a few KanBanLists
     * const { count } = await prisma.kanBanList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KanBanListDeleteManyArgs>(args?: SelectSubset<T, KanBanListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KanBanLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KanBanLists
     * const kanBanList = await prisma.kanBanList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KanBanListUpdateManyArgs>(args: SelectSubset<T, KanBanListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KanBanList.
     * @param {KanBanListUpsertArgs} args - Arguments to update or create a KanBanList.
     * @example
     * // Update or create a KanBanList
     * const kanBanList = await prisma.kanBanList.upsert({
     *   create: {
     *     // ... data to create a KanBanList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KanBanList we want to update
     *   }
     * })
     */
    upsert<T extends KanBanListUpsertArgs>(args: SelectSubset<T, KanBanListUpsertArgs<ExtArgs>>): Prisma__KanBanListClient<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KanBanLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanListCountArgs} args - Arguments to filter KanBanLists to count.
     * @example
     * // Count the number of KanBanLists
     * const count = await prisma.kanBanList.count({
     *   where: {
     *     // ... the filter for the KanBanLists we want to count
     *   }
     * })
    **/
    count<T extends KanBanListCountArgs>(
      args?: Subset<T, KanBanListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KanBanListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KanBanList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KanBanListAggregateArgs>(args: Subset<T, KanBanListAggregateArgs>): Prisma.PrismaPromise<GetKanBanListAggregateType<T>>

    /**
     * Group by KanBanList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanBanListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KanBanListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KanBanListGroupByArgs['orderBy'] }
        : { orderBy?: KanBanListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KanBanListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKanBanListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KanBanList model
   */
  readonly fields: KanBanListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KanBanList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KanBanListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cards<T extends KanBanList$cardsArgs<ExtArgs> = {}>(args?: Subset<T, KanBanList$cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KanBanCardPayload<ExtArgs>, T, "findMany"> | Null>
    Kanban<T extends KanBanList$KanbanArgs<ExtArgs> = {}>(args?: Subset<T, KanBanList$KanbanArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KanBanList model
   */ 
  interface KanBanListFieldRefs {
    readonly id: FieldRef<"KanBanList", 'Int'>
    readonly indexWithinBoard: FieldRef<"KanBanList", 'Int'>
    readonly title: FieldRef<"KanBanList", 'String'>
    readonly boardId: FieldRef<"KanBanList", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * KanBanList findUnique
   */
  export type KanBanListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * Filter, which KanBanList to fetch.
     */
    where: KanBanListWhereUniqueInput
  }

  /**
   * KanBanList findUniqueOrThrow
   */
  export type KanBanListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * Filter, which KanBanList to fetch.
     */
    where: KanBanListWhereUniqueInput
  }

  /**
   * KanBanList findFirst
   */
  export type KanBanListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * Filter, which KanBanList to fetch.
     */
    where?: KanBanListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KanBanLists to fetch.
     */
    orderBy?: KanBanListOrderByWithRelationInput | KanBanListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KanBanLists.
     */
    cursor?: KanBanListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KanBanLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KanBanLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KanBanLists.
     */
    distinct?: KanBanListScalarFieldEnum | KanBanListScalarFieldEnum[]
  }

  /**
   * KanBanList findFirstOrThrow
   */
  export type KanBanListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * Filter, which KanBanList to fetch.
     */
    where?: KanBanListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KanBanLists to fetch.
     */
    orderBy?: KanBanListOrderByWithRelationInput | KanBanListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KanBanLists.
     */
    cursor?: KanBanListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KanBanLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KanBanLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KanBanLists.
     */
    distinct?: KanBanListScalarFieldEnum | KanBanListScalarFieldEnum[]
  }

  /**
   * KanBanList findMany
   */
  export type KanBanListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * Filter, which KanBanLists to fetch.
     */
    where?: KanBanListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KanBanLists to fetch.
     */
    orderBy?: KanBanListOrderByWithRelationInput | KanBanListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KanBanLists.
     */
    cursor?: KanBanListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KanBanLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KanBanLists.
     */
    skip?: number
    distinct?: KanBanListScalarFieldEnum | KanBanListScalarFieldEnum[]
  }

  /**
   * KanBanList create
   */
  export type KanBanListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * The data needed to create a KanBanList.
     */
    data: XOR<KanBanListCreateInput, KanBanListUncheckedCreateInput>
  }

  /**
   * KanBanList createMany
   */
  export type KanBanListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KanBanLists.
     */
    data: KanBanListCreateManyInput | KanBanListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KanBanList createManyAndReturn
   */
  export type KanBanListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KanBanLists.
     */
    data: KanBanListCreateManyInput | KanBanListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KanBanList update
   */
  export type KanBanListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * The data needed to update a KanBanList.
     */
    data: XOR<KanBanListUpdateInput, KanBanListUncheckedUpdateInput>
    /**
     * Choose, which KanBanList to update.
     */
    where: KanBanListWhereUniqueInput
  }

  /**
   * KanBanList updateMany
   */
  export type KanBanListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KanBanLists.
     */
    data: XOR<KanBanListUpdateManyMutationInput, KanBanListUncheckedUpdateManyInput>
    /**
     * Filter which KanBanLists to update
     */
    where?: KanBanListWhereInput
  }

  /**
   * KanBanList upsert
   */
  export type KanBanListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * The filter to search for the KanBanList to update in case it exists.
     */
    where: KanBanListWhereUniqueInput
    /**
     * In case the KanBanList found by the `where` argument doesn't exist, create a new KanBanList with this data.
     */
    create: XOR<KanBanListCreateInput, KanBanListUncheckedCreateInput>
    /**
     * In case the KanBanList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KanBanListUpdateInput, KanBanListUncheckedUpdateInput>
  }

  /**
   * KanBanList delete
   */
  export type KanBanListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    /**
     * Filter which KanBanList to delete.
     */
    where: KanBanListWhereUniqueInput
  }

  /**
   * KanBanList deleteMany
   */
  export type KanBanListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KanBanLists to delete
     */
    where?: KanBanListWhereInput
  }

  /**
   * KanBanList.cards
   */
  export type KanBanList$cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanCard
     */
    select?: KanBanCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanCardInclude<ExtArgs> | null
    where?: KanBanCardWhereInput
    orderBy?: KanBanCardOrderByWithRelationInput | KanBanCardOrderByWithRelationInput[]
    cursor?: KanBanCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KanBanCardScalarFieldEnum | KanBanCardScalarFieldEnum[]
  }

  /**
   * KanBanList.Kanban
   */
  export type KanBanList$KanbanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    where?: KanbanWhereInput
  }

  /**
   * KanBanList without action
   */
  export type KanBanListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
  }


  /**
   * Model Kanban
   */

  export type AggregateKanban = {
    _count: KanbanCountAggregateOutputType | null
    _avg: KanbanAvgAggregateOutputType | null
    _sum: KanbanSumAggregateOutputType | null
    _min: KanbanMinAggregateOutputType | null
    _max: KanbanMaxAggregateOutputType | null
  }

  export type KanbanAvgAggregateOutputType = {
    id: number | null
  }

  export type KanbanSumAggregateOutputType = {
    id: number | null
  }

  export type KanbanMinAggregateOutputType = {
    id: number | null
    title: string | null
    createdAt: Date | null
    lastUpdate: Date | null
  }

  export type KanbanMaxAggregateOutputType = {
    id: number | null
    title: string | null
    createdAt: Date | null
    lastUpdate: Date | null
  }

  export type KanbanCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    lastUpdate: number
    _all: number
  }


  export type KanbanAvgAggregateInputType = {
    id?: true
  }

  export type KanbanSumAggregateInputType = {
    id?: true
  }

  export type KanbanMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    lastUpdate?: true
  }

  export type KanbanMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    lastUpdate?: true
  }

  export type KanbanCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    lastUpdate?: true
    _all?: true
  }

  export type KanbanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kanban to aggregate.
     */
    where?: KanbanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kanbans to fetch.
     */
    orderBy?: KanbanOrderByWithRelationInput | KanbanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KanbanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kanbans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kanbans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kanbans
    **/
    _count?: true | KanbanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KanbanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KanbanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KanbanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KanbanMaxAggregateInputType
  }

  export type GetKanbanAggregateType<T extends KanbanAggregateArgs> = {
        [P in keyof T & keyof AggregateKanban]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKanban[P]>
      : GetScalarType<T[P], AggregateKanban[P]>
  }




  export type KanbanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KanbanWhereInput
    orderBy?: KanbanOrderByWithAggregationInput | KanbanOrderByWithAggregationInput[]
    by: KanbanScalarFieldEnum[] | KanbanScalarFieldEnum
    having?: KanbanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KanbanCountAggregateInputType | true
    _avg?: KanbanAvgAggregateInputType
    _sum?: KanbanSumAggregateInputType
    _min?: KanbanMinAggregateInputType
    _max?: KanbanMaxAggregateInputType
  }

  export type KanbanGroupByOutputType = {
    id: number
    title: string
    createdAt: Date
    lastUpdate: Date
    _count: KanbanCountAggregateOutputType | null
    _avg: KanbanAvgAggregateOutputType | null
    _sum: KanbanSumAggregateOutputType | null
    _min: KanbanMinAggregateOutputType | null
    _max: KanbanMaxAggregateOutputType | null
  }

  type GetKanbanGroupByPayload<T extends KanbanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KanbanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KanbanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KanbanGroupByOutputType[P]>
            : GetScalarType<T[P], KanbanGroupByOutputType[P]>
        }
      >
    >


  export type KanbanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
    lists?: boolean | Kanban$listsArgs<ExtArgs>
    tags?: boolean | Kanban$tagsArgs<ExtArgs>
    subjects?: boolean | Kanban$subjectsArgs<ExtArgs>
    topics?: boolean | Kanban$topicsArgs<ExtArgs>
    _count?: boolean | KanbanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kanban"]>

  export type KanbanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
  }, ExtArgs["result"]["kanban"]>

  export type KanbanSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    lastUpdate?: boolean
  }

  export type KanbanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lists?: boolean | Kanban$listsArgs<ExtArgs>
    tags?: boolean | Kanban$tagsArgs<ExtArgs>
    subjects?: boolean | Kanban$subjectsArgs<ExtArgs>
    topics?: boolean | Kanban$topicsArgs<ExtArgs>
    _count?: boolean | KanbanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KanbanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KanbanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kanban"
    objects: {
      lists: Prisma.$KanBanListPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      createdAt: Date
      lastUpdate: Date
    }, ExtArgs["result"]["kanban"]>
    composites: {}
  }

  type KanbanGetPayload<S extends boolean | null | undefined | KanbanDefaultArgs> = $Result.GetResult<Prisma.$KanbanPayload, S>

  type KanbanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KanbanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KanbanCountAggregateInputType | true
    }

  export interface KanbanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kanban'], meta: { name: 'Kanban' } }
    /**
     * Find zero or one Kanban that matches the filter.
     * @param {KanbanFindUniqueArgs} args - Arguments to find a Kanban
     * @example
     * // Get one Kanban
     * const kanban = await prisma.kanban.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KanbanFindUniqueArgs>(args: SelectSubset<T, KanbanFindUniqueArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kanban that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KanbanFindUniqueOrThrowArgs} args - Arguments to find a Kanban
     * @example
     * // Get one Kanban
     * const kanban = await prisma.kanban.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KanbanFindUniqueOrThrowArgs>(args: SelectSubset<T, KanbanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kanban that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanbanFindFirstArgs} args - Arguments to find a Kanban
     * @example
     * // Get one Kanban
     * const kanban = await prisma.kanban.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KanbanFindFirstArgs>(args?: SelectSubset<T, KanbanFindFirstArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kanban that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanbanFindFirstOrThrowArgs} args - Arguments to find a Kanban
     * @example
     * // Get one Kanban
     * const kanban = await prisma.kanban.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KanbanFindFirstOrThrowArgs>(args?: SelectSubset<T, KanbanFindFirstOrThrowArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kanbans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanbanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kanbans
     * const kanbans = await prisma.kanban.findMany()
     * 
     * // Get first 10 Kanbans
     * const kanbans = await prisma.kanban.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kanbanWithIdOnly = await prisma.kanban.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KanbanFindManyArgs>(args?: SelectSubset<T, KanbanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kanban.
     * @param {KanbanCreateArgs} args - Arguments to create a Kanban.
     * @example
     * // Create one Kanban
     * const Kanban = await prisma.kanban.create({
     *   data: {
     *     // ... data to create a Kanban
     *   }
     * })
     * 
     */
    create<T extends KanbanCreateArgs>(args: SelectSubset<T, KanbanCreateArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kanbans.
     * @param {KanbanCreateManyArgs} args - Arguments to create many Kanbans.
     * @example
     * // Create many Kanbans
     * const kanban = await prisma.kanban.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KanbanCreateManyArgs>(args?: SelectSubset<T, KanbanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kanbans and returns the data saved in the database.
     * @param {KanbanCreateManyAndReturnArgs} args - Arguments to create many Kanbans.
     * @example
     * // Create many Kanbans
     * const kanban = await prisma.kanban.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kanbans and only return the `id`
     * const kanbanWithIdOnly = await prisma.kanban.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KanbanCreateManyAndReturnArgs>(args?: SelectSubset<T, KanbanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Kanban.
     * @param {KanbanDeleteArgs} args - Arguments to delete one Kanban.
     * @example
     * // Delete one Kanban
     * const Kanban = await prisma.kanban.delete({
     *   where: {
     *     // ... filter to delete one Kanban
     *   }
     * })
     * 
     */
    delete<T extends KanbanDeleteArgs>(args: SelectSubset<T, KanbanDeleteArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kanban.
     * @param {KanbanUpdateArgs} args - Arguments to update one Kanban.
     * @example
     * // Update one Kanban
     * const kanban = await prisma.kanban.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KanbanUpdateArgs>(args: SelectSubset<T, KanbanUpdateArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kanbans.
     * @param {KanbanDeleteManyArgs} args - Arguments to filter Kanbans to delete.
     * @example
     * // Delete a few Kanbans
     * const { count } = await prisma.kanban.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KanbanDeleteManyArgs>(args?: SelectSubset<T, KanbanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kanbans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanbanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kanbans
     * const kanban = await prisma.kanban.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KanbanUpdateManyArgs>(args: SelectSubset<T, KanbanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kanban.
     * @param {KanbanUpsertArgs} args - Arguments to update or create a Kanban.
     * @example
     * // Update or create a Kanban
     * const kanban = await prisma.kanban.upsert({
     *   create: {
     *     // ... data to create a Kanban
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kanban we want to update
     *   }
     * })
     */
    upsert<T extends KanbanUpsertArgs>(args: SelectSubset<T, KanbanUpsertArgs<ExtArgs>>): Prisma__KanbanClient<$Result.GetResult<Prisma.$KanbanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kanbans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanbanCountArgs} args - Arguments to filter Kanbans to count.
     * @example
     * // Count the number of Kanbans
     * const count = await prisma.kanban.count({
     *   where: {
     *     // ... the filter for the Kanbans we want to count
     *   }
     * })
    **/
    count<T extends KanbanCountArgs>(
      args?: Subset<T, KanbanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KanbanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kanban.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanbanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KanbanAggregateArgs>(args: Subset<T, KanbanAggregateArgs>): Prisma.PrismaPromise<GetKanbanAggregateType<T>>

    /**
     * Group by Kanban.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KanbanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KanbanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KanbanGroupByArgs['orderBy'] }
        : { orderBy?: KanbanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KanbanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKanbanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kanban model
   */
  readonly fields: KanbanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kanban.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KanbanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lists<T extends Kanban$listsArgs<ExtArgs> = {}>(args?: Subset<T, Kanban$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KanBanListPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends Kanban$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Kanban$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends Kanban$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Kanban$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    topics<T extends Kanban$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Kanban$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kanban model
   */ 
  interface KanbanFieldRefs {
    readonly id: FieldRef<"Kanban", 'Int'>
    readonly title: FieldRef<"Kanban", 'String'>
    readonly createdAt: FieldRef<"Kanban", 'DateTime'>
    readonly lastUpdate: FieldRef<"Kanban", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kanban findUnique
   */
  export type KanbanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * Filter, which Kanban to fetch.
     */
    where: KanbanWhereUniqueInput
  }

  /**
   * Kanban findUniqueOrThrow
   */
  export type KanbanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * Filter, which Kanban to fetch.
     */
    where: KanbanWhereUniqueInput
  }

  /**
   * Kanban findFirst
   */
  export type KanbanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * Filter, which Kanban to fetch.
     */
    where?: KanbanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kanbans to fetch.
     */
    orderBy?: KanbanOrderByWithRelationInput | KanbanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kanbans.
     */
    cursor?: KanbanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kanbans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kanbans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kanbans.
     */
    distinct?: KanbanScalarFieldEnum | KanbanScalarFieldEnum[]
  }

  /**
   * Kanban findFirstOrThrow
   */
  export type KanbanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * Filter, which Kanban to fetch.
     */
    where?: KanbanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kanbans to fetch.
     */
    orderBy?: KanbanOrderByWithRelationInput | KanbanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kanbans.
     */
    cursor?: KanbanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kanbans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kanbans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kanbans.
     */
    distinct?: KanbanScalarFieldEnum | KanbanScalarFieldEnum[]
  }

  /**
   * Kanban findMany
   */
  export type KanbanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * Filter, which Kanbans to fetch.
     */
    where?: KanbanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kanbans to fetch.
     */
    orderBy?: KanbanOrderByWithRelationInput | KanbanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kanbans.
     */
    cursor?: KanbanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kanbans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kanbans.
     */
    skip?: number
    distinct?: KanbanScalarFieldEnum | KanbanScalarFieldEnum[]
  }

  /**
   * Kanban create
   */
  export type KanbanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * The data needed to create a Kanban.
     */
    data: XOR<KanbanCreateInput, KanbanUncheckedCreateInput>
  }

  /**
   * Kanban createMany
   */
  export type KanbanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kanbans.
     */
    data: KanbanCreateManyInput | KanbanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kanban createManyAndReturn
   */
  export type KanbanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Kanbans.
     */
    data: KanbanCreateManyInput | KanbanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kanban update
   */
  export type KanbanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * The data needed to update a Kanban.
     */
    data: XOR<KanbanUpdateInput, KanbanUncheckedUpdateInput>
    /**
     * Choose, which Kanban to update.
     */
    where: KanbanWhereUniqueInput
  }

  /**
   * Kanban updateMany
   */
  export type KanbanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kanbans.
     */
    data: XOR<KanbanUpdateManyMutationInput, KanbanUncheckedUpdateManyInput>
    /**
     * Filter which Kanbans to update
     */
    where?: KanbanWhereInput
  }

  /**
   * Kanban upsert
   */
  export type KanbanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * The filter to search for the Kanban to update in case it exists.
     */
    where: KanbanWhereUniqueInput
    /**
     * In case the Kanban found by the `where` argument doesn't exist, create a new Kanban with this data.
     */
    create: XOR<KanbanCreateInput, KanbanUncheckedCreateInput>
    /**
     * In case the Kanban was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KanbanUpdateInput, KanbanUncheckedUpdateInput>
  }

  /**
   * Kanban delete
   */
  export type KanbanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
    /**
     * Filter which Kanban to delete.
     */
    where: KanbanWhereUniqueInput
  }

  /**
   * Kanban deleteMany
   */
  export type KanbanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kanbans to delete
     */
    where?: KanbanWhereInput
  }

  /**
   * Kanban.lists
   */
  export type Kanban$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KanBanList
     */
    select?: KanBanListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanBanListInclude<ExtArgs> | null
    where?: KanBanListWhereInput
    orderBy?: KanBanListOrderByWithRelationInput | KanBanListOrderByWithRelationInput[]
    cursor?: KanBanListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KanBanListScalarFieldEnum | KanBanListScalarFieldEnum[]
  }

  /**
   * Kanban.tags
   */
  export type Kanban$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Kanban.subjects
   */
  export type Kanban$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Kanban.topics
   */
  export type Kanban$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Kanban without action
   */
  export type KanbanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kanban
     */
    select?: KanbanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KanbanInclude<ExtArgs> | null
  }


  /**
   * Model TimePeriod
   */

  export type AggregateTimePeriod = {
    _count: TimePeriodCountAggregateOutputType | null
    _avg: TimePeriodAvgAggregateOutputType | null
    _sum: TimePeriodSumAggregateOutputType | null
    _min: TimePeriodMinAggregateOutputType | null
    _max: TimePeriodMaxAggregateOutputType | null
  }

  export type TimePeriodAvgAggregateOutputType = {
    id: number | null
  }

  export type TimePeriodSumAggregateOutputType = {
    id: number | null
  }

  export type TimePeriodMinAggregateOutputType = {
    id: number | null
    start: Date | null
    end: Date | null
    dietId: string | null
  }

  export type TimePeriodMaxAggregateOutputType = {
    id: number | null
    start: Date | null
    end: Date | null
    dietId: string | null
  }

  export type TimePeriodCountAggregateOutputType = {
    id: number
    start: number
    end: number
    dietId: number
    _all: number
  }


  export type TimePeriodAvgAggregateInputType = {
    id?: true
  }

  export type TimePeriodSumAggregateInputType = {
    id?: true
  }

  export type TimePeriodMinAggregateInputType = {
    id?: true
    start?: true
    end?: true
    dietId?: true
  }

  export type TimePeriodMaxAggregateInputType = {
    id?: true
    start?: true
    end?: true
    dietId?: true
  }

  export type TimePeriodCountAggregateInputType = {
    id?: true
    start?: true
    end?: true
    dietId?: true
    _all?: true
  }

  export type TimePeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimePeriod to aggregate.
     */
    where?: TimePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimePeriods to fetch.
     */
    orderBy?: TimePeriodOrderByWithRelationInput | TimePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimePeriods
    **/
    _count?: true | TimePeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimePeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimePeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimePeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimePeriodMaxAggregateInputType
  }

  export type GetTimePeriodAggregateType<T extends TimePeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateTimePeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimePeriod[P]>
      : GetScalarType<T[P], AggregateTimePeriod[P]>
  }




  export type TimePeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimePeriodWhereInput
    orderBy?: TimePeriodOrderByWithAggregationInput | TimePeriodOrderByWithAggregationInput[]
    by: TimePeriodScalarFieldEnum[] | TimePeriodScalarFieldEnum
    having?: TimePeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimePeriodCountAggregateInputType | true
    _avg?: TimePeriodAvgAggregateInputType
    _sum?: TimePeriodSumAggregateInputType
    _min?: TimePeriodMinAggregateInputType
    _max?: TimePeriodMaxAggregateInputType
  }

  export type TimePeriodGroupByOutputType = {
    id: number
    start: Date
    end: Date | null
    dietId: string | null
    _count: TimePeriodCountAggregateOutputType | null
    _avg: TimePeriodAvgAggregateOutputType | null
    _sum: TimePeriodSumAggregateOutputType | null
    _min: TimePeriodMinAggregateOutputType | null
    _max: TimePeriodMaxAggregateOutputType | null
  }

  type GetTimePeriodGroupByPayload<T extends TimePeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimePeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimePeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimePeriodGroupByOutputType[P]>
            : GetScalarType<T[P], TimePeriodGroupByOutputType[P]>
        }
      >
    >


  export type TimePeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    dietId?: boolean
    Diet?: boolean | TimePeriod$DietArgs<ExtArgs>
  }, ExtArgs["result"]["timePeriod"]>

  export type TimePeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    dietId?: boolean
    Diet?: boolean | TimePeriod$DietArgs<ExtArgs>
  }, ExtArgs["result"]["timePeriod"]>

  export type TimePeriodSelectScalar = {
    id?: boolean
    start?: boolean
    end?: boolean
    dietId?: boolean
  }

  export type TimePeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diet?: boolean | TimePeriod$DietArgs<ExtArgs>
  }
  export type TimePeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diet?: boolean | TimePeriod$DietArgs<ExtArgs>
  }

  export type $TimePeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimePeriod"
    objects: {
      Diet: Prisma.$DietPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      start: Date
      end: Date | null
      dietId: string | null
    }, ExtArgs["result"]["timePeriod"]>
    composites: {}
  }

  type TimePeriodGetPayload<S extends boolean | null | undefined | TimePeriodDefaultArgs> = $Result.GetResult<Prisma.$TimePeriodPayload, S>

  type TimePeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimePeriodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimePeriodCountAggregateInputType | true
    }

  export interface TimePeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimePeriod'], meta: { name: 'TimePeriod' } }
    /**
     * Find zero or one TimePeriod that matches the filter.
     * @param {TimePeriodFindUniqueArgs} args - Arguments to find a TimePeriod
     * @example
     * // Get one TimePeriod
     * const timePeriod = await prisma.timePeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimePeriodFindUniqueArgs>(args: SelectSubset<T, TimePeriodFindUniqueArgs<ExtArgs>>): Prisma__TimePeriodClient<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimePeriod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimePeriodFindUniqueOrThrowArgs} args - Arguments to find a TimePeriod
     * @example
     * // Get one TimePeriod
     * const timePeriod = await prisma.timePeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimePeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, TimePeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimePeriodClient<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimePeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimePeriodFindFirstArgs} args - Arguments to find a TimePeriod
     * @example
     * // Get one TimePeriod
     * const timePeriod = await prisma.timePeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimePeriodFindFirstArgs>(args?: SelectSubset<T, TimePeriodFindFirstArgs<ExtArgs>>): Prisma__TimePeriodClient<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimePeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimePeriodFindFirstOrThrowArgs} args - Arguments to find a TimePeriod
     * @example
     * // Get one TimePeriod
     * const timePeriod = await prisma.timePeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimePeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, TimePeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimePeriodClient<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimePeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimePeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimePeriods
     * const timePeriods = await prisma.timePeriod.findMany()
     * 
     * // Get first 10 TimePeriods
     * const timePeriods = await prisma.timePeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timePeriodWithIdOnly = await prisma.timePeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimePeriodFindManyArgs>(args?: SelectSubset<T, TimePeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimePeriod.
     * @param {TimePeriodCreateArgs} args - Arguments to create a TimePeriod.
     * @example
     * // Create one TimePeriod
     * const TimePeriod = await prisma.timePeriod.create({
     *   data: {
     *     // ... data to create a TimePeriod
     *   }
     * })
     * 
     */
    create<T extends TimePeriodCreateArgs>(args: SelectSubset<T, TimePeriodCreateArgs<ExtArgs>>): Prisma__TimePeriodClient<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimePeriods.
     * @param {TimePeriodCreateManyArgs} args - Arguments to create many TimePeriods.
     * @example
     * // Create many TimePeriods
     * const timePeriod = await prisma.timePeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimePeriodCreateManyArgs>(args?: SelectSubset<T, TimePeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimePeriods and returns the data saved in the database.
     * @param {TimePeriodCreateManyAndReturnArgs} args - Arguments to create many TimePeriods.
     * @example
     * // Create many TimePeriods
     * const timePeriod = await prisma.timePeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimePeriods and only return the `id`
     * const timePeriodWithIdOnly = await prisma.timePeriod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimePeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, TimePeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimePeriod.
     * @param {TimePeriodDeleteArgs} args - Arguments to delete one TimePeriod.
     * @example
     * // Delete one TimePeriod
     * const TimePeriod = await prisma.timePeriod.delete({
     *   where: {
     *     // ... filter to delete one TimePeriod
     *   }
     * })
     * 
     */
    delete<T extends TimePeriodDeleteArgs>(args: SelectSubset<T, TimePeriodDeleteArgs<ExtArgs>>): Prisma__TimePeriodClient<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimePeriod.
     * @param {TimePeriodUpdateArgs} args - Arguments to update one TimePeriod.
     * @example
     * // Update one TimePeriod
     * const timePeriod = await prisma.timePeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimePeriodUpdateArgs>(args: SelectSubset<T, TimePeriodUpdateArgs<ExtArgs>>): Prisma__TimePeriodClient<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimePeriods.
     * @param {TimePeriodDeleteManyArgs} args - Arguments to filter TimePeriods to delete.
     * @example
     * // Delete a few TimePeriods
     * const { count } = await prisma.timePeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimePeriodDeleteManyArgs>(args?: SelectSubset<T, TimePeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimePeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimePeriods
     * const timePeriod = await prisma.timePeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimePeriodUpdateManyArgs>(args: SelectSubset<T, TimePeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimePeriod.
     * @param {TimePeriodUpsertArgs} args - Arguments to update or create a TimePeriod.
     * @example
     * // Update or create a TimePeriod
     * const timePeriod = await prisma.timePeriod.upsert({
     *   create: {
     *     // ... data to create a TimePeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimePeriod we want to update
     *   }
     * })
     */
    upsert<T extends TimePeriodUpsertArgs>(args: SelectSubset<T, TimePeriodUpsertArgs<ExtArgs>>): Prisma__TimePeriodClient<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimePeriodCountArgs} args - Arguments to filter TimePeriods to count.
     * @example
     * // Count the number of TimePeriods
     * const count = await prisma.timePeriod.count({
     *   where: {
     *     // ... the filter for the TimePeriods we want to count
     *   }
     * })
    **/
    count<T extends TimePeriodCountArgs>(
      args?: Subset<T, TimePeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimePeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimePeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimePeriodAggregateArgs>(args: Subset<T, TimePeriodAggregateArgs>): Prisma.PrismaPromise<GetTimePeriodAggregateType<T>>

    /**
     * Group by TimePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimePeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimePeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimePeriodGroupByArgs['orderBy'] }
        : { orderBy?: TimePeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimePeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimePeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimePeriod model
   */
  readonly fields: TimePeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimePeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimePeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Diet<T extends TimePeriod$DietArgs<ExtArgs> = {}>(args?: Subset<T, TimePeriod$DietArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimePeriod model
   */ 
  interface TimePeriodFieldRefs {
    readonly id: FieldRef<"TimePeriod", 'Int'>
    readonly start: FieldRef<"TimePeriod", 'DateTime'>
    readonly end: FieldRef<"TimePeriod", 'DateTime'>
    readonly dietId: FieldRef<"TimePeriod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimePeriod findUnique
   */
  export type TimePeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * Filter, which TimePeriod to fetch.
     */
    where: TimePeriodWhereUniqueInput
  }

  /**
   * TimePeriod findUniqueOrThrow
   */
  export type TimePeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * Filter, which TimePeriod to fetch.
     */
    where: TimePeriodWhereUniqueInput
  }

  /**
   * TimePeriod findFirst
   */
  export type TimePeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * Filter, which TimePeriod to fetch.
     */
    where?: TimePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimePeriods to fetch.
     */
    orderBy?: TimePeriodOrderByWithRelationInput | TimePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimePeriods.
     */
    cursor?: TimePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimePeriods.
     */
    distinct?: TimePeriodScalarFieldEnum | TimePeriodScalarFieldEnum[]
  }

  /**
   * TimePeriod findFirstOrThrow
   */
  export type TimePeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * Filter, which TimePeriod to fetch.
     */
    where?: TimePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimePeriods to fetch.
     */
    orderBy?: TimePeriodOrderByWithRelationInput | TimePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimePeriods.
     */
    cursor?: TimePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimePeriods.
     */
    distinct?: TimePeriodScalarFieldEnum | TimePeriodScalarFieldEnum[]
  }

  /**
   * TimePeriod findMany
   */
  export type TimePeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * Filter, which TimePeriods to fetch.
     */
    where?: TimePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimePeriods to fetch.
     */
    orderBy?: TimePeriodOrderByWithRelationInput | TimePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimePeriods.
     */
    cursor?: TimePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimePeriods.
     */
    skip?: number
    distinct?: TimePeriodScalarFieldEnum | TimePeriodScalarFieldEnum[]
  }

  /**
   * TimePeriod create
   */
  export type TimePeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a TimePeriod.
     */
    data?: XOR<TimePeriodCreateInput, TimePeriodUncheckedCreateInput>
  }

  /**
   * TimePeriod createMany
   */
  export type TimePeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimePeriods.
     */
    data: TimePeriodCreateManyInput | TimePeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimePeriod createManyAndReturn
   */
  export type TimePeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimePeriods.
     */
    data: TimePeriodCreateManyInput | TimePeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimePeriod update
   */
  export type TimePeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a TimePeriod.
     */
    data: XOR<TimePeriodUpdateInput, TimePeriodUncheckedUpdateInput>
    /**
     * Choose, which TimePeriod to update.
     */
    where: TimePeriodWhereUniqueInput
  }

  /**
   * TimePeriod updateMany
   */
  export type TimePeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimePeriods.
     */
    data: XOR<TimePeriodUpdateManyMutationInput, TimePeriodUncheckedUpdateManyInput>
    /**
     * Filter which TimePeriods to update
     */
    where?: TimePeriodWhereInput
  }

  /**
   * TimePeriod upsert
   */
  export type TimePeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the TimePeriod to update in case it exists.
     */
    where: TimePeriodWhereUniqueInput
    /**
     * In case the TimePeriod found by the `where` argument doesn't exist, create a new TimePeriod with this data.
     */
    create: XOR<TimePeriodCreateInput, TimePeriodUncheckedCreateInput>
    /**
     * In case the TimePeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimePeriodUpdateInput, TimePeriodUncheckedUpdateInput>
  }

  /**
   * TimePeriod delete
   */
  export type TimePeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    /**
     * Filter which TimePeriod to delete.
     */
    where: TimePeriodWhereUniqueInput
  }

  /**
   * TimePeriod deleteMany
   */
  export type TimePeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimePeriods to delete
     */
    where?: TimePeriodWhereInput
  }

  /**
   * TimePeriod.Diet
   */
  export type TimePeriod$DietArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    where?: DietWhereInput
  }

  /**
   * TimePeriod without action
   */
  export type TimePeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
  }


  /**
   * Model Diet
   */

  export type AggregateDiet = {
    _count: DietCountAggregateOutputType | null
    _avg: DietAvgAggregateOutputType | null
    _sum: DietSumAggregateOutputType | null
    _min: DietMinAggregateOutputType | null
    _max: DietMaxAggregateOutputType | null
  }

  export type DietAvgAggregateOutputType = {
    carb: number | null
    pro: number | null
    fat: number | null
  }

  export type DietSumAggregateOutputType = {
    carb: number | null
    pro: number | null
    fat: number | null
  }

  export type DietMinAggregateOutputType = {
    name: string | null
    summary: string | null
    activelyFollowing: boolean | null
    gf: $Enums.TERTIARY_TOGGLE | null
    vegan: boolean | null
    pescatarian: boolean | null
    vegetarian: boolean | null
    fasting: $Enums.TERTIARY_TOGGLE | null
    cardioTraining: $Enums.TERTIARY_TOGGLE | null
    weightTraining: $Enums.TERTIARY_TOGGLE | null
    carb: number | null
    pro: number | null
    fat: number | null
    created: Date | null
    lastUpdate: Date | null
  }

  export type DietMaxAggregateOutputType = {
    name: string | null
    summary: string | null
    activelyFollowing: boolean | null
    gf: $Enums.TERTIARY_TOGGLE | null
    vegan: boolean | null
    pescatarian: boolean | null
    vegetarian: boolean | null
    fasting: $Enums.TERTIARY_TOGGLE | null
    cardioTraining: $Enums.TERTIARY_TOGGLE | null
    weightTraining: $Enums.TERTIARY_TOGGLE | null
    carb: number | null
    pro: number | null
    fat: number | null
    created: Date | null
    lastUpdate: Date | null
  }

  export type DietCountAggregateOutputType = {
    name: number
    summary: number
    activelyFollowing: number
    gf: number
    vegan: number
    pescatarian: number
    vegetarian: number
    fasting: number
    cardioTraining: number
    weightTraining: number
    carb: number
    pro: number
    fat: number
    goals: number
    created: number
    lastUpdate: number
    _all: number
  }


  export type DietAvgAggregateInputType = {
    carb?: true
    pro?: true
    fat?: true
  }

  export type DietSumAggregateInputType = {
    carb?: true
    pro?: true
    fat?: true
  }

  export type DietMinAggregateInputType = {
    name?: true
    summary?: true
    activelyFollowing?: true
    gf?: true
    vegan?: true
    pescatarian?: true
    vegetarian?: true
    fasting?: true
    cardioTraining?: true
    weightTraining?: true
    carb?: true
    pro?: true
    fat?: true
    created?: true
    lastUpdate?: true
  }

  export type DietMaxAggregateInputType = {
    name?: true
    summary?: true
    activelyFollowing?: true
    gf?: true
    vegan?: true
    pescatarian?: true
    vegetarian?: true
    fasting?: true
    cardioTraining?: true
    weightTraining?: true
    carb?: true
    pro?: true
    fat?: true
    created?: true
    lastUpdate?: true
  }

  export type DietCountAggregateInputType = {
    name?: true
    summary?: true
    activelyFollowing?: true
    gf?: true
    vegan?: true
    pescatarian?: true
    vegetarian?: true
    fasting?: true
    cardioTraining?: true
    weightTraining?: true
    carb?: true
    pro?: true
    fat?: true
    goals?: true
    created?: true
    lastUpdate?: true
    _all?: true
  }

  export type DietAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diet to aggregate.
     */
    where?: DietWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diets to fetch.
     */
    orderBy?: DietOrderByWithRelationInput | DietOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DietWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diets
    **/
    _count?: true | DietCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DietAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DietSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DietMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DietMaxAggregateInputType
  }

  export type GetDietAggregateType<T extends DietAggregateArgs> = {
        [P in keyof T & keyof AggregateDiet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiet[P]>
      : GetScalarType<T[P], AggregateDiet[P]>
  }




  export type DietGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietWhereInput
    orderBy?: DietOrderByWithAggregationInput | DietOrderByWithAggregationInput[]
    by: DietScalarFieldEnum[] | DietScalarFieldEnum
    having?: DietScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DietCountAggregateInputType | true
    _avg?: DietAvgAggregateInputType
    _sum?: DietSumAggregateInputType
    _min?: DietMinAggregateInputType
    _max?: DietMaxAggregateInputType
  }

  export type DietGroupByOutputType = {
    name: string
    summary: string | null
    activelyFollowing: boolean
    gf: $Enums.TERTIARY_TOGGLE
    vegan: boolean
    pescatarian: boolean
    vegetarian: boolean
    fasting: $Enums.TERTIARY_TOGGLE
    cardioTraining: $Enums.TERTIARY_TOGGLE
    weightTraining: $Enums.TERTIARY_TOGGLE
    carb: number | null
    pro: number | null
    fat: number | null
    goals: $Enums.DIETARY_GOAL[]
    created: Date
    lastUpdate: Date
    _count: DietCountAggregateOutputType | null
    _avg: DietAvgAggregateOutputType | null
    _sum: DietSumAggregateOutputType | null
    _min: DietMinAggregateOutputType | null
    _max: DietMaxAggregateOutputType | null
  }

  type GetDietGroupByPayload<T extends DietGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DietGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DietGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DietGroupByOutputType[P]>
            : GetScalarType<T[P], DietGroupByOutputType[P]>
        }
      >
    >


  export type DietSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    summary?: boolean
    activelyFollowing?: boolean
    gf?: boolean
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: boolean
    cardioTraining?: boolean
    weightTraining?: boolean
    carb?: boolean
    pro?: boolean
    fat?: boolean
    goals?: boolean
    created?: boolean
    lastUpdate?: boolean
    items?: boolean | Diet$itemsArgs<ExtArgs>
    periodsFollowed?: boolean | Diet$periodsFollowedArgs<ExtArgs>
    HealthReport?: boolean | Diet$HealthReportArgs<ExtArgs>
    _count?: boolean | DietCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diet"]>

  export type DietSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    summary?: boolean
    activelyFollowing?: boolean
    gf?: boolean
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: boolean
    cardioTraining?: boolean
    weightTraining?: boolean
    carb?: boolean
    pro?: boolean
    fat?: boolean
    goals?: boolean
    created?: boolean
    lastUpdate?: boolean
  }, ExtArgs["result"]["diet"]>

  export type DietSelectScalar = {
    name?: boolean
    summary?: boolean
    activelyFollowing?: boolean
    gf?: boolean
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: boolean
    cardioTraining?: boolean
    weightTraining?: boolean
    carb?: boolean
    pro?: boolean
    fat?: boolean
    goals?: boolean
    created?: boolean
    lastUpdate?: boolean
  }

  export type DietInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Diet$itemsArgs<ExtArgs>
    periodsFollowed?: boolean | Diet$periodsFollowedArgs<ExtArgs>
    HealthReport?: boolean | Diet$HealthReportArgs<ExtArgs>
    _count?: boolean | DietCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DietIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DietPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diet"
    objects: {
      items: Prisma.$DietaryItemPayload<ExtArgs>[]
      periodsFollowed: Prisma.$TimePeriodPayload<ExtArgs>[]
      HealthReport: Prisma.$HealthReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      summary: string | null
      activelyFollowing: boolean
      gf: $Enums.TERTIARY_TOGGLE
      vegan: boolean
      pescatarian: boolean
      vegetarian: boolean
      fasting: $Enums.TERTIARY_TOGGLE
      cardioTraining: $Enums.TERTIARY_TOGGLE
      weightTraining: $Enums.TERTIARY_TOGGLE
      carb: number | null
      pro: number | null
      fat: number | null
      goals: $Enums.DIETARY_GOAL[]
      created: Date
      lastUpdate: Date
    }, ExtArgs["result"]["diet"]>
    composites: {}
  }

  type DietGetPayload<S extends boolean | null | undefined | DietDefaultArgs> = $Result.GetResult<Prisma.$DietPayload, S>

  type DietCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DietFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DietCountAggregateInputType | true
    }

  export interface DietDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diet'], meta: { name: 'Diet' } }
    /**
     * Find zero or one Diet that matches the filter.
     * @param {DietFindUniqueArgs} args - Arguments to find a Diet
     * @example
     * // Get one Diet
     * const diet = await prisma.diet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DietFindUniqueArgs>(args: SelectSubset<T, DietFindUniqueArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Diet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DietFindUniqueOrThrowArgs} args - Arguments to find a Diet
     * @example
     * // Get one Diet
     * const diet = await prisma.diet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DietFindUniqueOrThrowArgs>(args: SelectSubset<T, DietFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Diet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietFindFirstArgs} args - Arguments to find a Diet
     * @example
     * // Get one Diet
     * const diet = await prisma.diet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DietFindFirstArgs>(args?: SelectSubset<T, DietFindFirstArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Diet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietFindFirstOrThrowArgs} args - Arguments to find a Diet
     * @example
     * // Get one Diet
     * const diet = await prisma.diet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DietFindFirstOrThrowArgs>(args?: SelectSubset<T, DietFindFirstOrThrowArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Diets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diets
     * const diets = await prisma.diet.findMany()
     * 
     * // Get first 10 Diets
     * const diets = await prisma.diet.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const dietWithNameOnly = await prisma.diet.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends DietFindManyArgs>(args?: SelectSubset<T, DietFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Diet.
     * @param {DietCreateArgs} args - Arguments to create a Diet.
     * @example
     * // Create one Diet
     * const Diet = await prisma.diet.create({
     *   data: {
     *     // ... data to create a Diet
     *   }
     * })
     * 
     */
    create<T extends DietCreateArgs>(args: SelectSubset<T, DietCreateArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Diets.
     * @param {DietCreateManyArgs} args - Arguments to create many Diets.
     * @example
     * // Create many Diets
     * const diet = await prisma.diet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DietCreateManyArgs>(args?: SelectSubset<T, DietCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diets and returns the data saved in the database.
     * @param {DietCreateManyAndReturnArgs} args - Arguments to create many Diets.
     * @example
     * // Create many Diets
     * const diet = await prisma.diet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diets and only return the `name`
     * const dietWithNameOnly = await prisma.diet.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DietCreateManyAndReturnArgs>(args?: SelectSubset<T, DietCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Diet.
     * @param {DietDeleteArgs} args - Arguments to delete one Diet.
     * @example
     * // Delete one Diet
     * const Diet = await prisma.diet.delete({
     *   where: {
     *     // ... filter to delete one Diet
     *   }
     * })
     * 
     */
    delete<T extends DietDeleteArgs>(args: SelectSubset<T, DietDeleteArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Diet.
     * @param {DietUpdateArgs} args - Arguments to update one Diet.
     * @example
     * // Update one Diet
     * const diet = await prisma.diet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DietUpdateArgs>(args: SelectSubset<T, DietUpdateArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Diets.
     * @param {DietDeleteManyArgs} args - Arguments to filter Diets to delete.
     * @example
     * // Delete a few Diets
     * const { count } = await prisma.diet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DietDeleteManyArgs>(args?: SelectSubset<T, DietDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diets
     * const diet = await prisma.diet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DietUpdateManyArgs>(args: SelectSubset<T, DietUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diet.
     * @param {DietUpsertArgs} args - Arguments to update or create a Diet.
     * @example
     * // Update or create a Diet
     * const diet = await prisma.diet.upsert({
     *   create: {
     *     // ... data to create a Diet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diet we want to update
     *   }
     * })
     */
    upsert<T extends DietUpsertArgs>(args: SelectSubset<T, DietUpsertArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Diets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietCountArgs} args - Arguments to filter Diets to count.
     * @example
     * // Count the number of Diets
     * const count = await prisma.diet.count({
     *   where: {
     *     // ... the filter for the Diets we want to count
     *   }
     * })
    **/
    count<T extends DietCountArgs>(
      args?: Subset<T, DietCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DietCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DietAggregateArgs>(args: Subset<T, DietAggregateArgs>): Prisma.PrismaPromise<GetDietAggregateType<T>>

    /**
     * Group by Diet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DietGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DietGroupByArgs['orderBy'] }
        : { orderBy?: DietGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DietGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDietGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diet model
   */
  readonly fields: DietFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DietClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Diet$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Diet$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "findMany"> | Null>
    periodsFollowed<T extends Diet$periodsFollowedArgs<ExtArgs> = {}>(args?: Subset<T, Diet$periodsFollowedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimePeriodPayload<ExtArgs>, T, "findMany"> | Null>
    HealthReport<T extends Diet$HealthReportArgs<ExtArgs> = {}>(args?: Subset<T, Diet$HealthReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diet model
   */ 
  interface DietFieldRefs {
    readonly name: FieldRef<"Diet", 'String'>
    readonly summary: FieldRef<"Diet", 'String'>
    readonly activelyFollowing: FieldRef<"Diet", 'Boolean'>
    readonly gf: FieldRef<"Diet", 'TERTIARY_TOGGLE'>
    readonly vegan: FieldRef<"Diet", 'Boolean'>
    readonly pescatarian: FieldRef<"Diet", 'Boolean'>
    readonly vegetarian: FieldRef<"Diet", 'Boolean'>
    readonly fasting: FieldRef<"Diet", 'TERTIARY_TOGGLE'>
    readonly cardioTraining: FieldRef<"Diet", 'TERTIARY_TOGGLE'>
    readonly weightTraining: FieldRef<"Diet", 'TERTIARY_TOGGLE'>
    readonly carb: FieldRef<"Diet", 'Float'>
    readonly pro: FieldRef<"Diet", 'Float'>
    readonly fat: FieldRef<"Diet", 'Float'>
    readonly goals: FieldRef<"Diet", 'DIETARY_GOAL[]'>
    readonly created: FieldRef<"Diet", 'DateTime'>
    readonly lastUpdate: FieldRef<"Diet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diet findUnique
   */
  export type DietFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * Filter, which Diet to fetch.
     */
    where: DietWhereUniqueInput
  }

  /**
   * Diet findUniqueOrThrow
   */
  export type DietFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * Filter, which Diet to fetch.
     */
    where: DietWhereUniqueInput
  }

  /**
   * Diet findFirst
   */
  export type DietFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * Filter, which Diet to fetch.
     */
    where?: DietWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diets to fetch.
     */
    orderBy?: DietOrderByWithRelationInput | DietOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diets.
     */
    cursor?: DietWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diets.
     */
    distinct?: DietScalarFieldEnum | DietScalarFieldEnum[]
  }

  /**
   * Diet findFirstOrThrow
   */
  export type DietFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * Filter, which Diet to fetch.
     */
    where?: DietWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diets to fetch.
     */
    orderBy?: DietOrderByWithRelationInput | DietOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diets.
     */
    cursor?: DietWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diets.
     */
    distinct?: DietScalarFieldEnum | DietScalarFieldEnum[]
  }

  /**
   * Diet findMany
   */
  export type DietFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * Filter, which Diets to fetch.
     */
    where?: DietWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diets to fetch.
     */
    orderBy?: DietOrderByWithRelationInput | DietOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diets.
     */
    cursor?: DietWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diets.
     */
    skip?: number
    distinct?: DietScalarFieldEnum | DietScalarFieldEnum[]
  }

  /**
   * Diet create
   */
  export type DietCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * The data needed to create a Diet.
     */
    data: XOR<DietCreateInput, DietUncheckedCreateInput>
  }

  /**
   * Diet createMany
   */
  export type DietCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diets.
     */
    data: DietCreateManyInput | DietCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diet createManyAndReturn
   */
  export type DietCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Diets.
     */
    data: DietCreateManyInput | DietCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diet update
   */
  export type DietUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * The data needed to update a Diet.
     */
    data: XOR<DietUpdateInput, DietUncheckedUpdateInput>
    /**
     * Choose, which Diet to update.
     */
    where: DietWhereUniqueInput
  }

  /**
   * Diet updateMany
   */
  export type DietUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diets.
     */
    data: XOR<DietUpdateManyMutationInput, DietUncheckedUpdateManyInput>
    /**
     * Filter which Diets to update
     */
    where?: DietWhereInput
  }

  /**
   * Diet upsert
   */
  export type DietUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * The filter to search for the Diet to update in case it exists.
     */
    where: DietWhereUniqueInput
    /**
     * In case the Diet found by the `where` argument doesn't exist, create a new Diet with this data.
     */
    create: XOR<DietCreateInput, DietUncheckedCreateInput>
    /**
     * In case the Diet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DietUpdateInput, DietUncheckedUpdateInput>
  }

  /**
   * Diet delete
   */
  export type DietDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    /**
     * Filter which Diet to delete.
     */
    where: DietWhereUniqueInput
  }

  /**
   * Diet deleteMany
   */
  export type DietDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diets to delete
     */
    where?: DietWhereInput
  }

  /**
   * Diet.items
   */
  export type Diet$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    where?: DietaryItemWhereInput
    orderBy?: DietaryItemOrderByWithRelationInput | DietaryItemOrderByWithRelationInput[]
    cursor?: DietaryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DietaryItemScalarFieldEnum | DietaryItemScalarFieldEnum[]
  }

  /**
   * Diet.periodsFollowed
   */
  export type Diet$periodsFollowedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimePeriod
     */
    select?: TimePeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimePeriodInclude<ExtArgs> | null
    where?: TimePeriodWhereInput
    orderBy?: TimePeriodOrderByWithRelationInput | TimePeriodOrderByWithRelationInput[]
    cursor?: TimePeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimePeriodScalarFieldEnum | TimePeriodScalarFieldEnum[]
  }

  /**
   * Diet.HealthReport
   */
  export type Diet$HealthReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    where?: HealthReportWhereInput
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    cursor?: HealthReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthReportScalarFieldEnum | HealthReportScalarFieldEnum[]
  }

  /**
   * Diet without action
   */
  export type DietDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
  }


  /**
   * Model Serving
   */

  export type AggregateServing = {
    _count: ServingCountAggregateOutputType | null
    _avg: ServingAvgAggregateOutputType | null
    _sum: ServingSumAggregateOutputType | null
    _min: ServingMinAggregateOutputType | null
    _max: ServingMaxAggregateOutputType | null
  }

  export type ServingAvgAggregateOutputType = {
    id: number | null
    dietaryItemId: number | null
    quant_oz: number | null
  }

  export type ServingSumAggregateOutputType = {
    id: number | null
    dietaryItemId: number | null
    quant_oz: number | null
  }

  export type ServingMinAggregateOutputType = {
    id: number | null
    dietaryItemId: number | null
    quant_oz: number | null
    quant_guess: $Enums.QUANTITY_GUESS | null
  }

  export type ServingMaxAggregateOutputType = {
    id: number | null
    dietaryItemId: number | null
    quant_oz: number | null
    quant_guess: $Enums.QUANTITY_GUESS | null
  }

  export type ServingCountAggregateOutputType = {
    id: number
    dietaryItemId: number
    quant_oz: number
    quant_guess: number
    _all: number
  }


  export type ServingAvgAggregateInputType = {
    id?: true
    dietaryItemId?: true
    quant_oz?: true
  }

  export type ServingSumAggregateInputType = {
    id?: true
    dietaryItemId?: true
    quant_oz?: true
  }

  export type ServingMinAggregateInputType = {
    id?: true
    dietaryItemId?: true
    quant_oz?: true
    quant_guess?: true
  }

  export type ServingMaxAggregateInputType = {
    id?: true
    dietaryItemId?: true
    quant_oz?: true
    quant_guess?: true
  }

  export type ServingCountAggregateInputType = {
    id?: true
    dietaryItemId?: true
    quant_oz?: true
    quant_guess?: true
    _all?: true
  }

  export type ServingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Serving to aggregate.
     */
    where?: ServingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servings to fetch.
     */
    orderBy?: ServingOrderByWithRelationInput | ServingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servings
    **/
    _count?: true | ServingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServingMaxAggregateInputType
  }

  export type GetServingAggregateType<T extends ServingAggregateArgs> = {
        [P in keyof T & keyof AggregateServing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServing[P]>
      : GetScalarType<T[P], AggregateServing[P]>
  }




  export type ServingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServingWhereInput
    orderBy?: ServingOrderByWithAggregationInput | ServingOrderByWithAggregationInput[]
    by: ServingScalarFieldEnum[] | ServingScalarFieldEnum
    having?: ServingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServingCountAggregateInputType | true
    _avg?: ServingAvgAggregateInputType
    _sum?: ServingSumAggregateInputType
    _min?: ServingMinAggregateInputType
    _max?: ServingMaxAggregateInputType
  }

  export type ServingGroupByOutputType = {
    id: number
    dietaryItemId: number
    quant_oz: number | null
    quant_guess: $Enums.QUANTITY_GUESS | null
    _count: ServingCountAggregateOutputType | null
    _avg: ServingAvgAggregateOutputType | null
    _sum: ServingSumAggregateOutputType | null
    _min: ServingMinAggregateOutputType | null
    _max: ServingMaxAggregateOutputType | null
  }

  type GetServingGroupByPayload<T extends ServingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServingGroupByOutputType[P]>
            : GetScalarType<T[P], ServingGroupByOutputType[P]>
        }
      >
    >


  export type ServingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dietaryItemId?: boolean
    quant_oz?: boolean
    quant_guess?: boolean
    item?: boolean | DietaryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serving"]>

  export type ServingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dietaryItemId?: boolean
    quant_oz?: boolean
    quant_guess?: boolean
    item?: boolean | DietaryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serving"]>

  export type ServingSelectScalar = {
    id?: boolean
    dietaryItemId?: boolean
    quant_oz?: boolean
    quant_guess?: boolean
  }

  export type ServingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | DietaryItemDefaultArgs<ExtArgs>
  }
  export type ServingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | DietaryItemDefaultArgs<ExtArgs>
  }

  export type $ServingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Serving"
    objects: {
      item: Prisma.$DietaryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dietaryItemId: number
      quant_oz: number | null
      quant_guess: $Enums.QUANTITY_GUESS | null
    }, ExtArgs["result"]["serving"]>
    composites: {}
  }

  type ServingGetPayload<S extends boolean | null | undefined | ServingDefaultArgs> = $Result.GetResult<Prisma.$ServingPayload, S>

  type ServingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServingCountAggregateInputType | true
    }

  export interface ServingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Serving'], meta: { name: 'Serving' } }
    /**
     * Find zero or one Serving that matches the filter.
     * @param {ServingFindUniqueArgs} args - Arguments to find a Serving
     * @example
     * // Get one Serving
     * const serving = await prisma.serving.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServingFindUniqueArgs>(args: SelectSubset<T, ServingFindUniqueArgs<ExtArgs>>): Prisma__ServingClient<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Serving that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServingFindUniqueOrThrowArgs} args - Arguments to find a Serving
     * @example
     * // Get one Serving
     * const serving = await prisma.serving.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServingClient<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Serving that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingFindFirstArgs} args - Arguments to find a Serving
     * @example
     * // Get one Serving
     * const serving = await prisma.serving.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServingFindFirstArgs>(args?: SelectSubset<T, ServingFindFirstArgs<ExtArgs>>): Prisma__ServingClient<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Serving that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingFindFirstOrThrowArgs} args - Arguments to find a Serving
     * @example
     * // Get one Serving
     * const serving = await prisma.serving.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServingClient<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servings
     * const servings = await prisma.serving.findMany()
     * 
     * // Get first 10 Servings
     * const servings = await prisma.serving.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servingWithIdOnly = await prisma.serving.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServingFindManyArgs>(args?: SelectSubset<T, ServingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Serving.
     * @param {ServingCreateArgs} args - Arguments to create a Serving.
     * @example
     * // Create one Serving
     * const Serving = await prisma.serving.create({
     *   data: {
     *     // ... data to create a Serving
     *   }
     * })
     * 
     */
    create<T extends ServingCreateArgs>(args: SelectSubset<T, ServingCreateArgs<ExtArgs>>): Prisma__ServingClient<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servings.
     * @param {ServingCreateManyArgs} args - Arguments to create many Servings.
     * @example
     * // Create many Servings
     * const serving = await prisma.serving.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServingCreateManyArgs>(args?: SelectSubset<T, ServingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servings and returns the data saved in the database.
     * @param {ServingCreateManyAndReturnArgs} args - Arguments to create many Servings.
     * @example
     * // Create many Servings
     * const serving = await prisma.serving.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servings and only return the `id`
     * const servingWithIdOnly = await prisma.serving.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Serving.
     * @param {ServingDeleteArgs} args - Arguments to delete one Serving.
     * @example
     * // Delete one Serving
     * const Serving = await prisma.serving.delete({
     *   where: {
     *     // ... filter to delete one Serving
     *   }
     * })
     * 
     */
    delete<T extends ServingDeleteArgs>(args: SelectSubset<T, ServingDeleteArgs<ExtArgs>>): Prisma__ServingClient<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Serving.
     * @param {ServingUpdateArgs} args - Arguments to update one Serving.
     * @example
     * // Update one Serving
     * const serving = await prisma.serving.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServingUpdateArgs>(args: SelectSubset<T, ServingUpdateArgs<ExtArgs>>): Prisma__ServingClient<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servings.
     * @param {ServingDeleteManyArgs} args - Arguments to filter Servings to delete.
     * @example
     * // Delete a few Servings
     * const { count } = await prisma.serving.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServingDeleteManyArgs>(args?: SelectSubset<T, ServingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servings
     * const serving = await prisma.serving.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServingUpdateManyArgs>(args: SelectSubset<T, ServingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serving.
     * @param {ServingUpsertArgs} args - Arguments to update or create a Serving.
     * @example
     * // Update or create a Serving
     * const serving = await prisma.serving.upsert({
     *   create: {
     *     // ... data to create a Serving
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serving we want to update
     *   }
     * })
     */
    upsert<T extends ServingUpsertArgs>(args: SelectSubset<T, ServingUpsertArgs<ExtArgs>>): Prisma__ServingClient<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingCountArgs} args - Arguments to filter Servings to count.
     * @example
     * // Count the number of Servings
     * const count = await prisma.serving.count({
     *   where: {
     *     // ... the filter for the Servings we want to count
     *   }
     * })
    **/
    count<T extends ServingCountArgs>(
      args?: Subset<T, ServingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serving.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServingAggregateArgs>(args: Subset<T, ServingAggregateArgs>): Prisma.PrismaPromise<GetServingAggregateType<T>>

    /**
     * Group by Serving.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServingGroupByArgs['orderBy'] }
        : { orderBy?: ServingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Serving model
   */
  readonly fields: ServingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Serving.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends DietaryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DietaryItemDefaultArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Serving model
   */ 
  interface ServingFieldRefs {
    readonly id: FieldRef<"Serving", 'Int'>
    readonly dietaryItemId: FieldRef<"Serving", 'Int'>
    readonly quant_oz: FieldRef<"Serving", 'Float'>
    readonly quant_guess: FieldRef<"Serving", 'QUANTITY_GUESS'>
  }
    

  // Custom InputTypes
  /**
   * Serving findUnique
   */
  export type ServingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * Filter, which Serving to fetch.
     */
    where: ServingWhereUniqueInput
  }

  /**
   * Serving findUniqueOrThrow
   */
  export type ServingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * Filter, which Serving to fetch.
     */
    where: ServingWhereUniqueInput
  }

  /**
   * Serving findFirst
   */
  export type ServingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * Filter, which Serving to fetch.
     */
    where?: ServingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servings to fetch.
     */
    orderBy?: ServingOrderByWithRelationInput | ServingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servings.
     */
    cursor?: ServingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servings.
     */
    distinct?: ServingScalarFieldEnum | ServingScalarFieldEnum[]
  }

  /**
   * Serving findFirstOrThrow
   */
  export type ServingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * Filter, which Serving to fetch.
     */
    where?: ServingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servings to fetch.
     */
    orderBy?: ServingOrderByWithRelationInput | ServingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servings.
     */
    cursor?: ServingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servings.
     */
    distinct?: ServingScalarFieldEnum | ServingScalarFieldEnum[]
  }

  /**
   * Serving findMany
   */
  export type ServingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * Filter, which Servings to fetch.
     */
    where?: ServingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servings to fetch.
     */
    orderBy?: ServingOrderByWithRelationInput | ServingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servings.
     */
    cursor?: ServingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servings.
     */
    skip?: number
    distinct?: ServingScalarFieldEnum | ServingScalarFieldEnum[]
  }

  /**
   * Serving create
   */
  export type ServingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * The data needed to create a Serving.
     */
    data: XOR<ServingCreateInput, ServingUncheckedCreateInput>
  }

  /**
   * Serving createMany
   */
  export type ServingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servings.
     */
    data: ServingCreateManyInput | ServingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Serving createManyAndReturn
   */
  export type ServingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Servings.
     */
    data: ServingCreateManyInput | ServingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Serving update
   */
  export type ServingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * The data needed to update a Serving.
     */
    data: XOR<ServingUpdateInput, ServingUncheckedUpdateInput>
    /**
     * Choose, which Serving to update.
     */
    where: ServingWhereUniqueInput
  }

  /**
   * Serving updateMany
   */
  export type ServingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servings.
     */
    data: XOR<ServingUpdateManyMutationInput, ServingUncheckedUpdateManyInput>
    /**
     * Filter which Servings to update
     */
    where?: ServingWhereInput
  }

  /**
   * Serving upsert
   */
  export type ServingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * The filter to search for the Serving to update in case it exists.
     */
    where: ServingWhereUniqueInput
    /**
     * In case the Serving found by the `where` argument doesn't exist, create a new Serving with this data.
     */
    create: XOR<ServingCreateInput, ServingUncheckedCreateInput>
    /**
     * In case the Serving was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServingUpdateInput, ServingUncheckedUpdateInput>
  }

  /**
   * Serving delete
   */
  export type ServingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    /**
     * Filter which Serving to delete.
     */
    where: ServingWhereUniqueInput
  }

  /**
   * Serving deleteMany
   */
  export type ServingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servings to delete
     */
    where?: ServingWhereInput
  }

  /**
   * Serving without action
   */
  export type ServingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
  }


  /**
   * Model DietaryItem
   */

  export type AggregateDietaryItem = {
    _count: DietaryItemCountAggregateOutputType | null
    _avg: DietaryItemAvgAggregateOutputType | null
    _sum: DietaryItemSumAggregateOutputType | null
    _min: DietaryItemMinAggregateOutputType | null
    _max: DietaryItemMaxAggregateOutputType | null
  }

  export type DietaryItemAvgAggregateOutputType = {
    id: number | null
    gi: number | null
    calsPerOz: number | null
    impactScore: number | null
  }

  export type DietaryItemSumAggregateOutputType = {
    id: number | null
    gi: number | null
    calsPerOz: number | null
    impactScore: number | null
  }

  export type DietaryItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    barcode: string | null
    gi: number | null
    calsPerOz: number | null
    glutenFree: boolean | null
    minimalFructose: boolean | null
    natural: boolean | null
    organic: boolean | null
    impactScore: number | null
  }

  export type DietaryItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    barcode: string | null
    gi: number | null
    calsPerOz: number | null
    glutenFree: boolean | null
    minimalFructose: boolean | null
    natural: boolean | null
    organic: boolean | null
    impactScore: number | null
  }

  export type DietaryItemCountAggregateOutputType = {
    id: number
    name: number
    barcode: number
    gi: number
    calsPerOz: number
    glutenFree: number
    minimalFructose: number
    natural: number
    organic: number
    impactScore: number
    _all: number
  }


  export type DietaryItemAvgAggregateInputType = {
    id?: true
    gi?: true
    calsPerOz?: true
    impactScore?: true
  }

  export type DietaryItemSumAggregateInputType = {
    id?: true
    gi?: true
    calsPerOz?: true
    impactScore?: true
  }

  export type DietaryItemMinAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    gi?: true
    calsPerOz?: true
    glutenFree?: true
    minimalFructose?: true
    natural?: true
    organic?: true
    impactScore?: true
  }

  export type DietaryItemMaxAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    gi?: true
    calsPerOz?: true
    glutenFree?: true
    minimalFructose?: true
    natural?: true
    organic?: true
    impactScore?: true
  }

  export type DietaryItemCountAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    gi?: true
    calsPerOz?: true
    glutenFree?: true
    minimalFructose?: true
    natural?: true
    organic?: true
    impactScore?: true
    _all?: true
  }

  export type DietaryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietaryItem to aggregate.
     */
    where?: DietaryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietaryItems to fetch.
     */
    orderBy?: DietaryItemOrderByWithRelationInput | DietaryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DietaryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietaryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietaryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DietaryItems
    **/
    _count?: true | DietaryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DietaryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DietaryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DietaryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DietaryItemMaxAggregateInputType
  }

  export type GetDietaryItemAggregateType<T extends DietaryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateDietaryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDietaryItem[P]>
      : GetScalarType<T[P], AggregateDietaryItem[P]>
  }




  export type DietaryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietaryItemWhereInput
    orderBy?: DietaryItemOrderByWithAggregationInput | DietaryItemOrderByWithAggregationInput[]
    by: DietaryItemScalarFieldEnum[] | DietaryItemScalarFieldEnum
    having?: DietaryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DietaryItemCountAggregateInputType | true
    _avg?: DietaryItemAvgAggregateInputType
    _sum?: DietaryItemSumAggregateInputType
    _min?: DietaryItemMinAggregateInputType
    _max?: DietaryItemMaxAggregateInputType
  }

  export type DietaryItemGroupByOutputType = {
    id: number
    name: string
    barcode: string | null
    gi: number | null
    calsPerOz: number | null
    glutenFree: boolean
    minimalFructose: boolean
    natural: boolean
    organic: boolean
    impactScore: number
    _count: DietaryItemCountAggregateOutputType | null
    _avg: DietaryItemAvgAggregateOutputType | null
    _sum: DietaryItemSumAggregateOutputType | null
    _min: DietaryItemMinAggregateOutputType | null
    _max: DietaryItemMaxAggregateOutputType | null
  }

  type GetDietaryItemGroupByPayload<T extends DietaryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DietaryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DietaryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DietaryItemGroupByOutputType[P]>
            : GetScalarType<T[P], DietaryItemGroupByOutputType[P]>
        }
      >
    >


  export type DietaryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    gi?: boolean
    calsPerOz?: boolean
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: boolean
    Diet?: boolean | DietaryItem$DietArgs<ExtArgs>
    Serving?: boolean | DietaryItem$ServingArgs<ExtArgs>
    _count?: boolean | DietaryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dietaryItem"]>

  export type DietaryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    gi?: boolean
    calsPerOz?: boolean
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: boolean
  }, ExtArgs["result"]["dietaryItem"]>

  export type DietaryItemSelectScalar = {
    id?: boolean
    name?: boolean
    barcode?: boolean
    gi?: boolean
    calsPerOz?: boolean
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: boolean
  }

  export type DietaryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diet?: boolean | DietaryItem$DietArgs<ExtArgs>
    Serving?: boolean | DietaryItem$ServingArgs<ExtArgs>
    _count?: boolean | DietaryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DietaryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DietaryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DietaryItem"
    objects: {
      Diet: Prisma.$DietPayload<ExtArgs>[]
      Serving: Prisma.$ServingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      barcode: string | null
      gi: number | null
      calsPerOz: number | null
      glutenFree: boolean
      minimalFructose: boolean
      natural: boolean
      organic: boolean
      impactScore: number
    }, ExtArgs["result"]["dietaryItem"]>
    composites: {}
  }

  type DietaryItemGetPayload<S extends boolean | null | undefined | DietaryItemDefaultArgs> = $Result.GetResult<Prisma.$DietaryItemPayload, S>

  type DietaryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DietaryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DietaryItemCountAggregateInputType | true
    }

  export interface DietaryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DietaryItem'], meta: { name: 'DietaryItem' } }
    /**
     * Find zero or one DietaryItem that matches the filter.
     * @param {DietaryItemFindUniqueArgs} args - Arguments to find a DietaryItem
     * @example
     * // Get one DietaryItem
     * const dietaryItem = await prisma.dietaryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DietaryItemFindUniqueArgs>(args: SelectSubset<T, DietaryItemFindUniqueArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DietaryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DietaryItemFindUniqueOrThrowArgs} args - Arguments to find a DietaryItem
     * @example
     * // Get one DietaryItem
     * const dietaryItem = await prisma.dietaryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DietaryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, DietaryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DietaryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryItemFindFirstArgs} args - Arguments to find a DietaryItem
     * @example
     * // Get one DietaryItem
     * const dietaryItem = await prisma.dietaryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DietaryItemFindFirstArgs>(args?: SelectSubset<T, DietaryItemFindFirstArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DietaryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryItemFindFirstOrThrowArgs} args - Arguments to find a DietaryItem
     * @example
     * // Get one DietaryItem
     * const dietaryItem = await prisma.dietaryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DietaryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, DietaryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DietaryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DietaryItems
     * const dietaryItems = await prisma.dietaryItem.findMany()
     * 
     * // Get first 10 DietaryItems
     * const dietaryItems = await prisma.dietaryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dietaryItemWithIdOnly = await prisma.dietaryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DietaryItemFindManyArgs>(args?: SelectSubset<T, DietaryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DietaryItem.
     * @param {DietaryItemCreateArgs} args - Arguments to create a DietaryItem.
     * @example
     * // Create one DietaryItem
     * const DietaryItem = await prisma.dietaryItem.create({
     *   data: {
     *     // ... data to create a DietaryItem
     *   }
     * })
     * 
     */
    create<T extends DietaryItemCreateArgs>(args: SelectSubset<T, DietaryItemCreateArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DietaryItems.
     * @param {DietaryItemCreateManyArgs} args - Arguments to create many DietaryItems.
     * @example
     * // Create many DietaryItems
     * const dietaryItem = await prisma.dietaryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DietaryItemCreateManyArgs>(args?: SelectSubset<T, DietaryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DietaryItems and returns the data saved in the database.
     * @param {DietaryItemCreateManyAndReturnArgs} args - Arguments to create many DietaryItems.
     * @example
     * // Create many DietaryItems
     * const dietaryItem = await prisma.dietaryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DietaryItems and only return the `id`
     * const dietaryItemWithIdOnly = await prisma.dietaryItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DietaryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, DietaryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DietaryItem.
     * @param {DietaryItemDeleteArgs} args - Arguments to delete one DietaryItem.
     * @example
     * // Delete one DietaryItem
     * const DietaryItem = await prisma.dietaryItem.delete({
     *   where: {
     *     // ... filter to delete one DietaryItem
     *   }
     * })
     * 
     */
    delete<T extends DietaryItemDeleteArgs>(args: SelectSubset<T, DietaryItemDeleteArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DietaryItem.
     * @param {DietaryItemUpdateArgs} args - Arguments to update one DietaryItem.
     * @example
     * // Update one DietaryItem
     * const dietaryItem = await prisma.dietaryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DietaryItemUpdateArgs>(args: SelectSubset<T, DietaryItemUpdateArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DietaryItems.
     * @param {DietaryItemDeleteManyArgs} args - Arguments to filter DietaryItems to delete.
     * @example
     * // Delete a few DietaryItems
     * const { count } = await prisma.dietaryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DietaryItemDeleteManyArgs>(args?: SelectSubset<T, DietaryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietaryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DietaryItems
     * const dietaryItem = await prisma.dietaryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DietaryItemUpdateManyArgs>(args: SelectSubset<T, DietaryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DietaryItem.
     * @param {DietaryItemUpsertArgs} args - Arguments to update or create a DietaryItem.
     * @example
     * // Update or create a DietaryItem
     * const dietaryItem = await prisma.dietaryItem.upsert({
     *   create: {
     *     // ... data to create a DietaryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DietaryItem we want to update
     *   }
     * })
     */
    upsert<T extends DietaryItemUpsertArgs>(args: SelectSubset<T, DietaryItemUpsertArgs<ExtArgs>>): Prisma__DietaryItemClient<$Result.GetResult<Prisma.$DietaryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DietaryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryItemCountArgs} args - Arguments to filter DietaryItems to count.
     * @example
     * // Count the number of DietaryItems
     * const count = await prisma.dietaryItem.count({
     *   where: {
     *     // ... the filter for the DietaryItems we want to count
     *   }
     * })
    **/
    count<T extends DietaryItemCountArgs>(
      args?: Subset<T, DietaryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DietaryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DietaryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DietaryItemAggregateArgs>(args: Subset<T, DietaryItemAggregateArgs>): Prisma.PrismaPromise<GetDietaryItemAggregateType<T>>

    /**
     * Group by DietaryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DietaryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DietaryItemGroupByArgs['orderBy'] }
        : { orderBy?: DietaryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DietaryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDietaryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DietaryItem model
   */
  readonly fields: DietaryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DietaryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DietaryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Diet<T extends DietaryItem$DietArgs<ExtArgs> = {}>(args?: Subset<T, DietaryItem$DietArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "findMany"> | Null>
    Serving<T extends DietaryItem$ServingArgs<ExtArgs> = {}>(args?: Subset<T, DietaryItem$ServingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DietaryItem model
   */ 
  interface DietaryItemFieldRefs {
    readonly id: FieldRef<"DietaryItem", 'Int'>
    readonly name: FieldRef<"DietaryItem", 'String'>
    readonly barcode: FieldRef<"DietaryItem", 'String'>
    readonly gi: FieldRef<"DietaryItem", 'Int'>
    readonly calsPerOz: FieldRef<"DietaryItem", 'Float'>
    readonly glutenFree: FieldRef<"DietaryItem", 'Boolean'>
    readonly minimalFructose: FieldRef<"DietaryItem", 'Boolean'>
    readonly natural: FieldRef<"DietaryItem", 'Boolean'>
    readonly organic: FieldRef<"DietaryItem", 'Boolean'>
    readonly impactScore: FieldRef<"DietaryItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * DietaryItem findUnique
   */
  export type DietaryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * Filter, which DietaryItem to fetch.
     */
    where: DietaryItemWhereUniqueInput
  }

  /**
   * DietaryItem findUniqueOrThrow
   */
  export type DietaryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * Filter, which DietaryItem to fetch.
     */
    where: DietaryItemWhereUniqueInput
  }

  /**
   * DietaryItem findFirst
   */
  export type DietaryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * Filter, which DietaryItem to fetch.
     */
    where?: DietaryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietaryItems to fetch.
     */
    orderBy?: DietaryItemOrderByWithRelationInput | DietaryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietaryItems.
     */
    cursor?: DietaryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietaryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietaryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietaryItems.
     */
    distinct?: DietaryItemScalarFieldEnum | DietaryItemScalarFieldEnum[]
  }

  /**
   * DietaryItem findFirstOrThrow
   */
  export type DietaryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * Filter, which DietaryItem to fetch.
     */
    where?: DietaryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietaryItems to fetch.
     */
    orderBy?: DietaryItemOrderByWithRelationInput | DietaryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietaryItems.
     */
    cursor?: DietaryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietaryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietaryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietaryItems.
     */
    distinct?: DietaryItemScalarFieldEnum | DietaryItemScalarFieldEnum[]
  }

  /**
   * DietaryItem findMany
   */
  export type DietaryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * Filter, which DietaryItems to fetch.
     */
    where?: DietaryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietaryItems to fetch.
     */
    orderBy?: DietaryItemOrderByWithRelationInput | DietaryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DietaryItems.
     */
    cursor?: DietaryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietaryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietaryItems.
     */
    skip?: number
    distinct?: DietaryItemScalarFieldEnum | DietaryItemScalarFieldEnum[]
  }

  /**
   * DietaryItem create
   */
  export type DietaryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a DietaryItem.
     */
    data: XOR<DietaryItemCreateInput, DietaryItemUncheckedCreateInput>
  }

  /**
   * DietaryItem createMany
   */
  export type DietaryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DietaryItems.
     */
    data: DietaryItemCreateManyInput | DietaryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DietaryItem createManyAndReturn
   */
  export type DietaryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DietaryItems.
     */
    data: DietaryItemCreateManyInput | DietaryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DietaryItem update
   */
  export type DietaryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a DietaryItem.
     */
    data: XOR<DietaryItemUpdateInput, DietaryItemUncheckedUpdateInput>
    /**
     * Choose, which DietaryItem to update.
     */
    where: DietaryItemWhereUniqueInput
  }

  /**
   * DietaryItem updateMany
   */
  export type DietaryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DietaryItems.
     */
    data: XOR<DietaryItemUpdateManyMutationInput, DietaryItemUncheckedUpdateManyInput>
    /**
     * Filter which DietaryItems to update
     */
    where?: DietaryItemWhereInput
  }

  /**
   * DietaryItem upsert
   */
  export type DietaryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the DietaryItem to update in case it exists.
     */
    where: DietaryItemWhereUniqueInput
    /**
     * In case the DietaryItem found by the `where` argument doesn't exist, create a new DietaryItem with this data.
     */
    create: XOR<DietaryItemCreateInput, DietaryItemUncheckedCreateInput>
    /**
     * In case the DietaryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DietaryItemUpdateInput, DietaryItemUncheckedUpdateInput>
  }

  /**
   * DietaryItem delete
   */
  export type DietaryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
    /**
     * Filter which DietaryItem to delete.
     */
    where: DietaryItemWhereUniqueInput
  }

  /**
   * DietaryItem deleteMany
   */
  export type DietaryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietaryItems to delete
     */
    where?: DietaryItemWhereInput
  }

  /**
   * DietaryItem.Diet
   */
  export type DietaryItem$DietArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    where?: DietWhereInput
    orderBy?: DietOrderByWithRelationInput | DietOrderByWithRelationInput[]
    cursor?: DietWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DietScalarFieldEnum | DietScalarFieldEnum[]
  }

  /**
   * DietaryItem.Serving
   */
  export type DietaryItem$ServingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serving
     */
    select?: ServingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServingInclude<ExtArgs> | null
    where?: ServingWhereInput
    orderBy?: ServingOrderByWithRelationInput | ServingOrderByWithRelationInput[]
    cursor?: ServingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServingScalarFieldEnum | ServingScalarFieldEnum[]
  }

  /**
   * DietaryItem without action
   */
  export type DietaryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryItem
     */
    select?: DietaryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryItemInclude<ExtArgs> | null
  }


  /**
   * Model HealthReport
   */

  export type AggregateHealthReport = {
    _count: HealthReportCountAggregateOutputType | null
    _avg: HealthReportAvgAggregateOutputType | null
    _sum: HealthReportSumAggregateOutputType | null
    _min: HealthReportMinAggregateOutputType | null
    _max: HealthReportMaxAggregateOutputType | null
  }

  export type HealthReportAvgAggregateOutputType = {
    id: number | null
    overall: number | null
    skin: number | null
    bloat: number | null
    weight_feeling: number | null
    fullness: number | null
    weight: number | null
    cardiacCapacity: number | null
    jawLine: number | null
    joints: number | null
    flexibility: number | null
    anxiety: number | null
    mood: number | null
    sexDrive: number | null
    intruisiveThoughts: number | null
    caffeineIntake: number | null
    glutenIntake: number | null
    sugarIntake: number | null
    artificialSweetenerIntake: number | null
    artificalDyes: number | null
    sleepQuality: number | null
    hydration: number | null
    twitching: number | null
    sleepHours: number | null
    calorie_est: number | null
    times_meals_more_than_gap_apart: number | null
    estHoursInExcessFast: number | null
  }

  export type HealthReportSumAggregateOutputType = {
    id: number | null
    overall: number | null
    skin: number | null
    bloat: number | null
    weight_feeling: number | null
    fullness: number | null
    weight: number | null
    cardiacCapacity: number | null
    jawLine: number | null
    joints: number | null
    flexibility: number | null
    anxiety: number | null
    mood: number | null
    sexDrive: number | null
    intruisiveThoughts: number | null
    caffeineIntake: number | null
    glutenIntake: number | null
    sugarIntake: number | null
    artificialSweetenerIntake: number | null
    artificalDyes: number | null
    sleepQuality: number | null
    hydration: number | null
    twitching: number | null
    sleepHours: number | null
    calorie_est: number | null
    times_meals_more_than_gap_apart: number | null
    estHoursInExcessFast: number | null
  }

  export type HealthReportMinAggregateOutputType = {
    id: number | null
    title: string | null
    summary: string | null
    overall: number | null
    skin: number | null
    bloat: number | null
    weight_feeling: number | null
    fullness: number | null
    weight: number | null
    cardiacCapacity: number | null
    jawLine: number | null
    joints: number | null
    flexibility: number | null
    anxiety: number | null
    anxiety_desc: string | null
    mood_desc: string | null
    mood: number | null
    sexDrive: number | null
    intruisiveThoughts: number | null
    caffeineIntake: number | null
    glutenIntake: number | null
    sugarIntake: number | null
    artificialSweetenerIntake: number | null
    artificalDyes: number | null
    sleepQuality: number | null
    hydration: number | null
    twitching: number | null
    sleepHours: number | null
    calorie_est: number | null
    times_meals_more_than_gap_apart: number | null
    estHoursInExcessFast: number | null
    dietId: string | null
    created: Date | null
  }

  export type HealthReportMaxAggregateOutputType = {
    id: number | null
    title: string | null
    summary: string | null
    overall: number | null
    skin: number | null
    bloat: number | null
    weight_feeling: number | null
    fullness: number | null
    weight: number | null
    cardiacCapacity: number | null
    jawLine: number | null
    joints: number | null
    flexibility: number | null
    anxiety: number | null
    anxiety_desc: string | null
    mood_desc: string | null
    mood: number | null
    sexDrive: number | null
    intruisiveThoughts: number | null
    caffeineIntake: number | null
    glutenIntake: number | null
    sugarIntake: number | null
    artificialSweetenerIntake: number | null
    artificalDyes: number | null
    sleepQuality: number | null
    hydration: number | null
    twitching: number | null
    sleepHours: number | null
    calorie_est: number | null
    times_meals_more_than_gap_apart: number | null
    estHoursInExcessFast: number | null
    dietId: string | null
    created: Date | null
  }

  export type HealthReportCountAggregateOutputType = {
    id: number
    title: number
    summary: number
    overall: number
    skin: number
    bloat: number
    weight_feeling: number
    fullness: number
    weight: number
    cardiacCapacity: number
    jawLine: number
    joints: number
    flexibility: number
    anxiety: number
    anxiety_desc: number
    mood_desc: number
    mood: number
    sexDrive: number
    intruisiveThoughts: number
    caffeineIntake: number
    glutenIntake: number
    sugarIntake: number
    artificialSweetenerIntake: number
    artificalDyes: number
    sleepQuality: number
    hydration: number
    twitching: number
    sleepHours: number
    calorie_est: number
    times_meals_more_than_gap_apart: number
    estHoursInExcessFast: number
    dietId: number
    created: number
    _all: number
  }


  export type HealthReportAvgAggregateInputType = {
    id?: true
    overall?: true
    skin?: true
    bloat?: true
    weight_feeling?: true
    fullness?: true
    weight?: true
    cardiacCapacity?: true
    jawLine?: true
    joints?: true
    flexibility?: true
    anxiety?: true
    mood?: true
    sexDrive?: true
    intruisiveThoughts?: true
    caffeineIntake?: true
    glutenIntake?: true
    sugarIntake?: true
    artificialSweetenerIntake?: true
    artificalDyes?: true
    sleepQuality?: true
    hydration?: true
    twitching?: true
    sleepHours?: true
    calorie_est?: true
    times_meals_more_than_gap_apart?: true
    estHoursInExcessFast?: true
  }

  export type HealthReportSumAggregateInputType = {
    id?: true
    overall?: true
    skin?: true
    bloat?: true
    weight_feeling?: true
    fullness?: true
    weight?: true
    cardiacCapacity?: true
    jawLine?: true
    joints?: true
    flexibility?: true
    anxiety?: true
    mood?: true
    sexDrive?: true
    intruisiveThoughts?: true
    caffeineIntake?: true
    glutenIntake?: true
    sugarIntake?: true
    artificialSweetenerIntake?: true
    artificalDyes?: true
    sleepQuality?: true
    hydration?: true
    twitching?: true
    sleepHours?: true
    calorie_est?: true
    times_meals_more_than_gap_apart?: true
    estHoursInExcessFast?: true
  }

  export type HealthReportMinAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    overall?: true
    skin?: true
    bloat?: true
    weight_feeling?: true
    fullness?: true
    weight?: true
    cardiacCapacity?: true
    jawLine?: true
    joints?: true
    flexibility?: true
    anxiety?: true
    anxiety_desc?: true
    mood_desc?: true
    mood?: true
    sexDrive?: true
    intruisiveThoughts?: true
    caffeineIntake?: true
    glutenIntake?: true
    sugarIntake?: true
    artificialSweetenerIntake?: true
    artificalDyes?: true
    sleepQuality?: true
    hydration?: true
    twitching?: true
    sleepHours?: true
    calorie_est?: true
    times_meals_more_than_gap_apart?: true
    estHoursInExcessFast?: true
    dietId?: true
    created?: true
  }

  export type HealthReportMaxAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    overall?: true
    skin?: true
    bloat?: true
    weight_feeling?: true
    fullness?: true
    weight?: true
    cardiacCapacity?: true
    jawLine?: true
    joints?: true
    flexibility?: true
    anxiety?: true
    anxiety_desc?: true
    mood_desc?: true
    mood?: true
    sexDrive?: true
    intruisiveThoughts?: true
    caffeineIntake?: true
    glutenIntake?: true
    sugarIntake?: true
    artificialSweetenerIntake?: true
    artificalDyes?: true
    sleepQuality?: true
    hydration?: true
    twitching?: true
    sleepHours?: true
    calorie_est?: true
    times_meals_more_than_gap_apart?: true
    estHoursInExcessFast?: true
    dietId?: true
    created?: true
  }

  export type HealthReportCountAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    overall?: true
    skin?: true
    bloat?: true
    weight_feeling?: true
    fullness?: true
    weight?: true
    cardiacCapacity?: true
    jawLine?: true
    joints?: true
    flexibility?: true
    anxiety?: true
    anxiety_desc?: true
    mood_desc?: true
    mood?: true
    sexDrive?: true
    intruisiveThoughts?: true
    caffeineIntake?: true
    glutenIntake?: true
    sugarIntake?: true
    artificialSweetenerIntake?: true
    artificalDyes?: true
    sleepQuality?: true
    hydration?: true
    twitching?: true
    sleepHours?: true
    calorie_est?: true
    times_meals_more_than_gap_apart?: true
    estHoursInExcessFast?: true
    dietId?: true
    created?: true
    _all?: true
  }

  export type HealthReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthReport to aggregate.
     */
    where?: HealthReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthReports to fetch.
     */
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthReports
    **/
    _count?: true | HealthReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthReportMaxAggregateInputType
  }

  export type GetHealthReportAggregateType<T extends HealthReportAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthReport[P]>
      : GetScalarType<T[P], AggregateHealthReport[P]>
  }




  export type HealthReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthReportWhereInput
    orderBy?: HealthReportOrderByWithAggregationInput | HealthReportOrderByWithAggregationInput[]
    by: HealthReportScalarFieldEnum[] | HealthReportScalarFieldEnum
    having?: HealthReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthReportCountAggregateInputType | true
    _avg?: HealthReportAvgAggregateInputType
    _sum?: HealthReportSumAggregateInputType
    _min?: HealthReportMinAggregateInputType
    _max?: HealthReportMaxAggregateInputType
  }

  export type HealthReportGroupByOutputType = {
    id: number
    title: string | null
    summary: string | null
    overall: number
    skin: number
    bloat: number
    weight_feeling: number
    fullness: number
    weight: number | null
    cardiacCapacity: number
    jawLine: number
    joints: number
    flexibility: number
    anxiety: number
    anxiety_desc: string | null
    mood_desc: string | null
    mood: number
    sexDrive: number
    intruisiveThoughts: number
    caffeineIntake: number
    glutenIntake: number
    sugarIntake: number
    artificialSweetenerIntake: number
    artificalDyes: number
    sleepQuality: number
    hydration: number
    twitching: number
    sleepHours: number | null
    calorie_est: number | null
    times_meals_more_than_gap_apart: number | null
    estHoursInExcessFast: number | null
    dietId: string | null
    created: Date
    _count: HealthReportCountAggregateOutputType | null
    _avg: HealthReportAvgAggregateOutputType | null
    _sum: HealthReportSumAggregateOutputType | null
    _min: HealthReportMinAggregateOutputType | null
    _max: HealthReportMaxAggregateOutputType | null
  }

  type GetHealthReportGroupByPayload<T extends HealthReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthReportGroupByOutputType[P]>
            : GetScalarType<T[P], HealthReportGroupByOutputType[P]>
        }
      >
    >


  export type HealthReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    overall?: boolean
    skin?: boolean
    bloat?: boolean
    weight_feeling?: boolean
    fullness?: boolean
    weight?: boolean
    cardiacCapacity?: boolean
    jawLine?: boolean
    joints?: boolean
    flexibility?: boolean
    anxiety?: boolean
    anxiety_desc?: boolean
    mood_desc?: boolean
    mood?: boolean
    sexDrive?: boolean
    intruisiveThoughts?: boolean
    caffeineIntake?: boolean
    glutenIntake?: boolean
    sugarIntake?: boolean
    artificialSweetenerIntake?: boolean
    artificalDyes?: boolean
    sleepQuality?: boolean
    hydration?: boolean
    twitching?: boolean
    sleepHours?: boolean
    calorie_est?: boolean
    times_meals_more_than_gap_apart?: boolean
    estHoursInExcessFast?: boolean
    dietId?: boolean
    created?: boolean
    currentDiet?: boolean | HealthReport$currentDietArgs<ExtArgs>
  }, ExtArgs["result"]["healthReport"]>

  export type HealthReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    overall?: boolean
    skin?: boolean
    bloat?: boolean
    weight_feeling?: boolean
    fullness?: boolean
    weight?: boolean
    cardiacCapacity?: boolean
    jawLine?: boolean
    joints?: boolean
    flexibility?: boolean
    anxiety?: boolean
    anxiety_desc?: boolean
    mood_desc?: boolean
    mood?: boolean
    sexDrive?: boolean
    intruisiveThoughts?: boolean
    caffeineIntake?: boolean
    glutenIntake?: boolean
    sugarIntake?: boolean
    artificialSweetenerIntake?: boolean
    artificalDyes?: boolean
    sleepQuality?: boolean
    hydration?: boolean
    twitching?: boolean
    sleepHours?: boolean
    calorie_est?: boolean
    times_meals_more_than_gap_apart?: boolean
    estHoursInExcessFast?: boolean
    dietId?: boolean
    created?: boolean
    currentDiet?: boolean | HealthReport$currentDietArgs<ExtArgs>
  }, ExtArgs["result"]["healthReport"]>

  export type HealthReportSelectScalar = {
    id?: boolean
    title?: boolean
    summary?: boolean
    overall?: boolean
    skin?: boolean
    bloat?: boolean
    weight_feeling?: boolean
    fullness?: boolean
    weight?: boolean
    cardiacCapacity?: boolean
    jawLine?: boolean
    joints?: boolean
    flexibility?: boolean
    anxiety?: boolean
    anxiety_desc?: boolean
    mood_desc?: boolean
    mood?: boolean
    sexDrive?: boolean
    intruisiveThoughts?: boolean
    caffeineIntake?: boolean
    glutenIntake?: boolean
    sugarIntake?: boolean
    artificialSweetenerIntake?: boolean
    artificalDyes?: boolean
    sleepQuality?: boolean
    hydration?: boolean
    twitching?: boolean
    sleepHours?: boolean
    calorie_est?: boolean
    times_meals_more_than_gap_apart?: boolean
    estHoursInExcessFast?: boolean
    dietId?: boolean
    created?: boolean
  }

  export type HealthReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentDiet?: boolean | HealthReport$currentDietArgs<ExtArgs>
  }
  export type HealthReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentDiet?: boolean | HealthReport$currentDietArgs<ExtArgs>
  }

  export type $HealthReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthReport"
    objects: {
      currentDiet: Prisma.$DietPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      summary: string | null
      overall: number
      skin: number
      bloat: number
      weight_feeling: number
      fullness: number
      weight: number | null
      cardiacCapacity: number
      jawLine: number
      joints: number
      flexibility: number
      anxiety: number
      anxiety_desc: string | null
      mood_desc: string | null
      mood: number
      sexDrive: number
      intruisiveThoughts: number
      caffeineIntake: number
      glutenIntake: number
      sugarIntake: number
      artificialSweetenerIntake: number
      artificalDyes: number
      sleepQuality: number
      hydration: number
      twitching: number
      sleepHours: number | null
      calorie_est: number | null
      times_meals_more_than_gap_apart: number | null
      estHoursInExcessFast: number | null
      dietId: string | null
      created: Date
    }, ExtArgs["result"]["healthReport"]>
    composites: {}
  }

  type HealthReportGetPayload<S extends boolean | null | undefined | HealthReportDefaultArgs> = $Result.GetResult<Prisma.$HealthReportPayload, S>

  type HealthReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthReportCountAggregateInputType | true
    }

  export interface HealthReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthReport'], meta: { name: 'HealthReport' } }
    /**
     * Find zero or one HealthReport that matches the filter.
     * @param {HealthReportFindUniqueArgs} args - Arguments to find a HealthReport
     * @example
     * // Get one HealthReport
     * const healthReport = await prisma.healthReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthReportFindUniqueArgs>(args: SelectSubset<T, HealthReportFindUniqueArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthReportFindUniqueOrThrowArgs} args - Arguments to find a HealthReport
     * @example
     * // Get one HealthReport
     * const healthReport = await prisma.healthReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthReportFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportFindFirstArgs} args - Arguments to find a HealthReport
     * @example
     * // Get one HealthReport
     * const healthReport = await prisma.healthReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthReportFindFirstArgs>(args?: SelectSubset<T, HealthReportFindFirstArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportFindFirstOrThrowArgs} args - Arguments to find a HealthReport
     * @example
     * // Get one HealthReport
     * const healthReport = await prisma.healthReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthReportFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthReports
     * const healthReports = await prisma.healthReport.findMany()
     * 
     * // Get first 10 HealthReports
     * const healthReports = await prisma.healthReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthReportWithIdOnly = await prisma.healthReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthReportFindManyArgs>(args?: SelectSubset<T, HealthReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthReport.
     * @param {HealthReportCreateArgs} args - Arguments to create a HealthReport.
     * @example
     * // Create one HealthReport
     * const HealthReport = await prisma.healthReport.create({
     *   data: {
     *     // ... data to create a HealthReport
     *   }
     * })
     * 
     */
    create<T extends HealthReportCreateArgs>(args: SelectSubset<T, HealthReportCreateArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthReports.
     * @param {HealthReportCreateManyArgs} args - Arguments to create many HealthReports.
     * @example
     * // Create many HealthReports
     * const healthReport = await prisma.healthReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthReportCreateManyArgs>(args?: SelectSubset<T, HealthReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthReports and returns the data saved in the database.
     * @param {HealthReportCreateManyAndReturnArgs} args - Arguments to create many HealthReports.
     * @example
     * // Create many HealthReports
     * const healthReport = await prisma.healthReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthReports and only return the `id`
     * const healthReportWithIdOnly = await prisma.healthReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthReportCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthReport.
     * @param {HealthReportDeleteArgs} args - Arguments to delete one HealthReport.
     * @example
     * // Delete one HealthReport
     * const HealthReport = await prisma.healthReport.delete({
     *   where: {
     *     // ... filter to delete one HealthReport
     *   }
     * })
     * 
     */
    delete<T extends HealthReportDeleteArgs>(args: SelectSubset<T, HealthReportDeleteArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthReport.
     * @param {HealthReportUpdateArgs} args - Arguments to update one HealthReport.
     * @example
     * // Update one HealthReport
     * const healthReport = await prisma.healthReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthReportUpdateArgs>(args: SelectSubset<T, HealthReportUpdateArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthReports.
     * @param {HealthReportDeleteManyArgs} args - Arguments to filter HealthReports to delete.
     * @example
     * // Delete a few HealthReports
     * const { count } = await prisma.healthReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthReportDeleteManyArgs>(args?: SelectSubset<T, HealthReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthReports
     * const healthReport = await prisma.healthReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthReportUpdateManyArgs>(args: SelectSubset<T, HealthReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthReport.
     * @param {HealthReportUpsertArgs} args - Arguments to update or create a HealthReport.
     * @example
     * // Update or create a HealthReport
     * const healthReport = await prisma.healthReport.upsert({
     *   create: {
     *     // ... data to create a HealthReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthReport we want to update
     *   }
     * })
     */
    upsert<T extends HealthReportUpsertArgs>(args: SelectSubset<T, HealthReportUpsertArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportCountArgs} args - Arguments to filter HealthReports to count.
     * @example
     * // Count the number of HealthReports
     * const count = await prisma.healthReport.count({
     *   where: {
     *     // ... the filter for the HealthReports we want to count
     *   }
     * })
    **/
    count<T extends HealthReportCountArgs>(
      args?: Subset<T, HealthReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthReportAggregateArgs>(args: Subset<T, HealthReportAggregateArgs>): Prisma.PrismaPromise<GetHealthReportAggregateType<T>>

    /**
     * Group by HealthReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthReportGroupByArgs['orderBy'] }
        : { orderBy?: HealthReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthReport model
   */
  readonly fields: HealthReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currentDiet<T extends HealthReport$currentDietArgs<ExtArgs> = {}>(args?: Subset<T, HealthReport$currentDietArgs<ExtArgs>>): Prisma__DietClient<$Result.GetResult<Prisma.$DietPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthReport model
   */ 
  interface HealthReportFieldRefs {
    readonly id: FieldRef<"HealthReport", 'Int'>
    readonly title: FieldRef<"HealthReport", 'String'>
    readonly summary: FieldRef<"HealthReport", 'String'>
    readonly overall: FieldRef<"HealthReport", 'Float'>
    readonly skin: FieldRef<"HealthReport", 'Float'>
    readonly bloat: FieldRef<"HealthReport", 'Float'>
    readonly weight_feeling: FieldRef<"HealthReport", 'Float'>
    readonly fullness: FieldRef<"HealthReport", 'Float'>
    readonly weight: FieldRef<"HealthReport", 'Float'>
    readonly cardiacCapacity: FieldRef<"HealthReport", 'Float'>
    readonly jawLine: FieldRef<"HealthReport", 'Float'>
    readonly joints: FieldRef<"HealthReport", 'Float'>
    readonly flexibility: FieldRef<"HealthReport", 'Float'>
    readonly anxiety: FieldRef<"HealthReport", 'Float'>
    readonly anxiety_desc: FieldRef<"HealthReport", 'String'>
    readonly mood_desc: FieldRef<"HealthReport", 'String'>
    readonly mood: FieldRef<"HealthReport", 'Float'>
    readonly sexDrive: FieldRef<"HealthReport", 'Float'>
    readonly intruisiveThoughts: FieldRef<"HealthReport", 'Float'>
    readonly caffeineIntake: FieldRef<"HealthReport", 'Float'>
    readonly glutenIntake: FieldRef<"HealthReport", 'Float'>
    readonly sugarIntake: FieldRef<"HealthReport", 'Float'>
    readonly artificialSweetenerIntake: FieldRef<"HealthReport", 'Float'>
    readonly artificalDyes: FieldRef<"HealthReport", 'Float'>
    readonly sleepQuality: FieldRef<"HealthReport", 'Float'>
    readonly hydration: FieldRef<"HealthReport", 'Float'>
    readonly twitching: FieldRef<"HealthReport", 'Float'>
    readonly sleepHours: FieldRef<"HealthReport", 'Float'>
    readonly calorie_est: FieldRef<"HealthReport", 'Int'>
    readonly times_meals_more_than_gap_apart: FieldRef<"HealthReport", 'Int'>
    readonly estHoursInExcessFast: FieldRef<"HealthReport", 'Float'>
    readonly dietId: FieldRef<"HealthReport", 'String'>
    readonly created: FieldRef<"HealthReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthReport findUnique
   */
  export type HealthReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReport to fetch.
     */
    where: HealthReportWhereUniqueInput
  }

  /**
   * HealthReport findUniqueOrThrow
   */
  export type HealthReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReport to fetch.
     */
    where: HealthReportWhereUniqueInput
  }

  /**
   * HealthReport findFirst
   */
  export type HealthReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReport to fetch.
     */
    where?: HealthReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthReports to fetch.
     */
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthReports.
     */
    cursor?: HealthReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthReports.
     */
    distinct?: HealthReportScalarFieldEnum | HealthReportScalarFieldEnum[]
  }

  /**
   * HealthReport findFirstOrThrow
   */
  export type HealthReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReport to fetch.
     */
    where?: HealthReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthReports to fetch.
     */
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthReports.
     */
    cursor?: HealthReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthReports.
     */
    distinct?: HealthReportScalarFieldEnum | HealthReportScalarFieldEnum[]
  }

  /**
   * HealthReport findMany
   */
  export type HealthReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReports to fetch.
     */
    where?: HealthReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthReports to fetch.
     */
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthReports.
     */
    cursor?: HealthReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthReports.
     */
    skip?: number
    distinct?: HealthReportScalarFieldEnum | HealthReportScalarFieldEnum[]
  }

  /**
   * HealthReport create
   */
  export type HealthReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthReport.
     */
    data?: XOR<HealthReportCreateInput, HealthReportUncheckedCreateInput>
  }

  /**
   * HealthReport createMany
   */
  export type HealthReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthReports.
     */
    data: HealthReportCreateManyInput | HealthReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthReport createManyAndReturn
   */
  export type HealthReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthReports.
     */
    data: HealthReportCreateManyInput | HealthReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthReport update
   */
  export type HealthReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthReport.
     */
    data: XOR<HealthReportUpdateInput, HealthReportUncheckedUpdateInput>
    /**
     * Choose, which HealthReport to update.
     */
    where: HealthReportWhereUniqueInput
  }

  /**
   * HealthReport updateMany
   */
  export type HealthReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthReports.
     */
    data: XOR<HealthReportUpdateManyMutationInput, HealthReportUncheckedUpdateManyInput>
    /**
     * Filter which HealthReports to update
     */
    where?: HealthReportWhereInput
  }

  /**
   * HealthReport upsert
   */
  export type HealthReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthReport to update in case it exists.
     */
    where: HealthReportWhereUniqueInput
    /**
     * In case the HealthReport found by the `where` argument doesn't exist, create a new HealthReport with this data.
     */
    create: XOR<HealthReportCreateInput, HealthReportUncheckedCreateInput>
    /**
     * In case the HealthReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthReportUpdateInput, HealthReportUncheckedUpdateInput>
  }

  /**
   * HealthReport delete
   */
  export type HealthReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter which HealthReport to delete.
     */
    where: HealthReportWhereUniqueInput
  }

  /**
   * HealthReport deleteMany
   */
  export type HealthReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthReports to delete
     */
    where?: HealthReportWhereInput
  }

  /**
   * HealthReport.currentDiet
   */
  export type HealthReport$currentDietArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diet
     */
    select?: DietSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietInclude<ExtArgs> | null
    where?: DietWhereInput
  }

  /**
   * HealthReport without action
   */
  export type HealthReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
  }


  /**
   * Model Whiteboard
   */

  export type AggregateWhiteboard = {
    _count: WhiteboardCountAggregateOutputType | null
    _min: WhiteboardMinAggregateOutputType | null
    _max: WhiteboardMaxAggregateOutputType | null
  }

  export type WhiteboardMinAggregateOutputType = {
    id: string | null
    data: Buffer | null
  }

  export type WhiteboardMaxAggregateOutputType = {
    id: string | null
    data: Buffer | null
  }

  export type WhiteboardCountAggregateOutputType = {
    id: number
    data: number
    _all: number
  }


  export type WhiteboardMinAggregateInputType = {
    id?: true
    data?: true
  }

  export type WhiteboardMaxAggregateInputType = {
    id?: true
    data?: true
  }

  export type WhiteboardCountAggregateInputType = {
    id?: true
    data?: true
    _all?: true
  }

  export type WhiteboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whiteboard to aggregate.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Whiteboards
    **/
    _count?: true | WhiteboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhiteboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhiteboardMaxAggregateInputType
  }

  export type GetWhiteboardAggregateType<T extends WhiteboardAggregateArgs> = {
        [P in keyof T & keyof AggregateWhiteboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhiteboard[P]>
      : GetScalarType<T[P], AggregateWhiteboard[P]>
  }




  export type WhiteboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhiteboardWhereInput
    orderBy?: WhiteboardOrderByWithAggregationInput | WhiteboardOrderByWithAggregationInput[]
    by: WhiteboardScalarFieldEnum[] | WhiteboardScalarFieldEnum
    having?: WhiteboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhiteboardCountAggregateInputType | true
    _min?: WhiteboardMinAggregateInputType
    _max?: WhiteboardMaxAggregateInputType
  }

  export type WhiteboardGroupByOutputType = {
    id: string
    data: Buffer
    _count: WhiteboardCountAggregateOutputType | null
    _min: WhiteboardMinAggregateOutputType | null
    _max: WhiteboardMaxAggregateOutputType | null
  }

  type GetWhiteboardGroupByPayload<T extends WhiteboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhiteboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhiteboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhiteboardGroupByOutputType[P]>
            : GetScalarType<T[P], WhiteboardGroupByOutputType[P]>
        }
      >
    >


  export type WhiteboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
  }, ExtArgs["result"]["whiteboard"]>

  export type WhiteboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
  }, ExtArgs["result"]["whiteboard"]>

  export type WhiteboardSelectScalar = {
    id?: boolean
    data?: boolean
  }


  export type $WhiteboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Whiteboard"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      data: Buffer
    }, ExtArgs["result"]["whiteboard"]>
    composites: {}
  }

  type WhiteboardGetPayload<S extends boolean | null | undefined | WhiteboardDefaultArgs> = $Result.GetResult<Prisma.$WhiteboardPayload, S>

  type WhiteboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhiteboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WhiteboardCountAggregateInputType | true
    }

  export interface WhiteboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Whiteboard'], meta: { name: 'Whiteboard' } }
    /**
     * Find zero or one Whiteboard that matches the filter.
     * @param {WhiteboardFindUniqueArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhiteboardFindUniqueArgs>(args: SelectSubset<T, WhiteboardFindUniqueArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Whiteboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhiteboardFindUniqueOrThrowArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhiteboardFindUniqueOrThrowArgs>(args: SelectSubset<T, WhiteboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Whiteboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindFirstArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhiteboardFindFirstArgs>(args?: SelectSubset<T, WhiteboardFindFirstArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Whiteboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindFirstOrThrowArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhiteboardFindFirstOrThrowArgs>(args?: SelectSubset<T, WhiteboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Whiteboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whiteboards
     * const whiteboards = await prisma.whiteboard.findMany()
     * 
     * // Get first 10 Whiteboards
     * const whiteboards = await prisma.whiteboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whiteboardWithIdOnly = await prisma.whiteboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhiteboardFindManyArgs>(args?: SelectSubset<T, WhiteboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Whiteboard.
     * @param {WhiteboardCreateArgs} args - Arguments to create a Whiteboard.
     * @example
     * // Create one Whiteboard
     * const Whiteboard = await prisma.whiteboard.create({
     *   data: {
     *     // ... data to create a Whiteboard
     *   }
     * })
     * 
     */
    create<T extends WhiteboardCreateArgs>(args: SelectSubset<T, WhiteboardCreateArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Whiteboards.
     * @param {WhiteboardCreateManyArgs} args - Arguments to create many Whiteboards.
     * @example
     * // Create many Whiteboards
     * const whiteboard = await prisma.whiteboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhiteboardCreateManyArgs>(args?: SelectSubset<T, WhiteboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whiteboards and returns the data saved in the database.
     * @param {WhiteboardCreateManyAndReturnArgs} args - Arguments to create many Whiteboards.
     * @example
     * // Create many Whiteboards
     * const whiteboard = await prisma.whiteboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whiteboards and only return the `id`
     * const whiteboardWithIdOnly = await prisma.whiteboard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhiteboardCreateManyAndReturnArgs>(args?: SelectSubset<T, WhiteboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Whiteboard.
     * @param {WhiteboardDeleteArgs} args - Arguments to delete one Whiteboard.
     * @example
     * // Delete one Whiteboard
     * const Whiteboard = await prisma.whiteboard.delete({
     *   where: {
     *     // ... filter to delete one Whiteboard
     *   }
     * })
     * 
     */
    delete<T extends WhiteboardDeleteArgs>(args: SelectSubset<T, WhiteboardDeleteArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Whiteboard.
     * @param {WhiteboardUpdateArgs} args - Arguments to update one Whiteboard.
     * @example
     * // Update one Whiteboard
     * const whiteboard = await prisma.whiteboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhiteboardUpdateArgs>(args: SelectSubset<T, WhiteboardUpdateArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Whiteboards.
     * @param {WhiteboardDeleteManyArgs} args - Arguments to filter Whiteboards to delete.
     * @example
     * // Delete a few Whiteboards
     * const { count } = await prisma.whiteboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhiteboardDeleteManyArgs>(args?: SelectSubset<T, WhiteboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whiteboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whiteboards
     * const whiteboard = await prisma.whiteboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhiteboardUpdateManyArgs>(args: SelectSubset<T, WhiteboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Whiteboard.
     * @param {WhiteboardUpsertArgs} args - Arguments to update or create a Whiteboard.
     * @example
     * // Update or create a Whiteboard
     * const whiteboard = await prisma.whiteboard.upsert({
     *   create: {
     *     // ... data to create a Whiteboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whiteboard we want to update
     *   }
     * })
     */
    upsert<T extends WhiteboardUpsertArgs>(args: SelectSubset<T, WhiteboardUpsertArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Whiteboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardCountArgs} args - Arguments to filter Whiteboards to count.
     * @example
     * // Count the number of Whiteboards
     * const count = await prisma.whiteboard.count({
     *   where: {
     *     // ... the filter for the Whiteboards we want to count
     *   }
     * })
    **/
    count<T extends WhiteboardCountArgs>(
      args?: Subset<T, WhiteboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhiteboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whiteboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhiteboardAggregateArgs>(args: Subset<T, WhiteboardAggregateArgs>): Prisma.PrismaPromise<GetWhiteboardAggregateType<T>>

    /**
     * Group by Whiteboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhiteboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhiteboardGroupByArgs['orderBy'] }
        : { orderBy?: WhiteboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhiteboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhiteboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Whiteboard model
   */
  readonly fields: WhiteboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Whiteboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhiteboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Whiteboard model
   */ 
  interface WhiteboardFieldRefs {
    readonly id: FieldRef<"Whiteboard", 'String'>
    readonly data: FieldRef<"Whiteboard", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * Whiteboard findUnique
   */
  export type WhiteboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard findUniqueOrThrow
   */
  export type WhiteboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard findFirst
   */
  export type WhiteboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whiteboards.
     */
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard findFirstOrThrow
   */
  export type WhiteboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whiteboards.
     */
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard findMany
   */
  export type WhiteboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Filter, which Whiteboards to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard create
   */
  export type WhiteboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * The data needed to create a Whiteboard.
     */
    data: XOR<WhiteboardCreateInput, WhiteboardUncheckedCreateInput>
  }

  /**
   * Whiteboard createMany
   */
  export type WhiteboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Whiteboards.
     */
    data: WhiteboardCreateManyInput | WhiteboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Whiteboard createManyAndReturn
   */
  export type WhiteboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Whiteboards.
     */
    data: WhiteboardCreateManyInput | WhiteboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Whiteboard update
   */
  export type WhiteboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * The data needed to update a Whiteboard.
     */
    data: XOR<WhiteboardUpdateInput, WhiteboardUncheckedUpdateInput>
    /**
     * Choose, which Whiteboard to update.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard updateMany
   */
  export type WhiteboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Whiteboards.
     */
    data: XOR<WhiteboardUpdateManyMutationInput, WhiteboardUncheckedUpdateManyInput>
    /**
     * Filter which Whiteboards to update
     */
    where?: WhiteboardWhereInput
  }

  /**
   * Whiteboard upsert
   */
  export type WhiteboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * The filter to search for the Whiteboard to update in case it exists.
     */
    where: WhiteboardWhereUniqueInput
    /**
     * In case the Whiteboard found by the `where` argument doesn't exist, create a new Whiteboard with this data.
     */
    create: XOR<WhiteboardCreateInput, WhiteboardUncheckedCreateInput>
    /**
     * In case the Whiteboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhiteboardUpdateInput, WhiteboardUncheckedUpdateInput>
  }

  /**
   * Whiteboard delete
   */
  export type WhiteboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Filter which Whiteboard to delete.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard deleteMany
   */
  export type WhiteboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whiteboards to delete
     */
    where?: WhiteboardWhereInput
  }

  /**
   * Whiteboard without action
   */
  export type WhiteboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
  }


  /**
   * Model DJT
   */

  export type AggregateDJT = {
    _count: DJTCountAggregateOutputType | null
    _avg: DJTAvgAggregateOutputType | null
    _sum: DJTSumAggregateOutputType | null
    _min: DJTMinAggregateOutputType | null
    _max: DJTMaxAggregateOutputType | null
  }

  export type DJTAvgAggregateOutputType = {
    id: number | null
  }

  export type DJTSumAggregateOutputType = {
    id: number | null
  }

  export type DJTMinAggregateOutputType = {
    id: number | null
    type: string | null
    data: Buffer | null
  }

  export type DJTMaxAggregateOutputType = {
    id: number | null
    type: string | null
    data: Buffer | null
  }

  export type DJTCountAggregateOutputType = {
    id: number
    type: number
    data: number
    _all: number
  }


  export type DJTAvgAggregateInputType = {
    id?: true
  }

  export type DJTSumAggregateInputType = {
    id?: true
  }

  export type DJTMinAggregateInputType = {
    id?: true
    type?: true
    data?: true
  }

  export type DJTMaxAggregateInputType = {
    id?: true
    type?: true
    data?: true
  }

  export type DJTCountAggregateInputType = {
    id?: true
    type?: true
    data?: true
    _all?: true
  }

  export type DJTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DJT to aggregate.
     */
    where?: DJTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DJTS to fetch.
     */
    orderBy?: DJTOrderByWithRelationInput | DJTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DJTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DJTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DJTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DJTS
    **/
    _count?: true | DJTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DJTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DJTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DJTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DJTMaxAggregateInputType
  }

  export type GetDJTAggregateType<T extends DJTAggregateArgs> = {
        [P in keyof T & keyof AggregateDJT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDJT[P]>
      : GetScalarType<T[P], AggregateDJT[P]>
  }




  export type DJTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DJTWhereInput
    orderBy?: DJTOrderByWithAggregationInput | DJTOrderByWithAggregationInput[]
    by: DJTScalarFieldEnum[] | DJTScalarFieldEnum
    having?: DJTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DJTCountAggregateInputType | true
    _avg?: DJTAvgAggregateInputType
    _sum?: DJTSumAggregateInputType
    _min?: DJTMinAggregateInputType
    _max?: DJTMaxAggregateInputType
  }

  export type DJTGroupByOutputType = {
    id: number
    type: string
    data: Buffer
    _count: DJTCountAggregateOutputType | null
    _avg: DJTAvgAggregateOutputType | null
    _sum: DJTSumAggregateOutputType | null
    _min: DJTMinAggregateOutputType | null
    _max: DJTMaxAggregateOutputType | null
  }

  type GetDJTGroupByPayload<T extends DJTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DJTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DJTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DJTGroupByOutputType[P]>
            : GetScalarType<T[P], DJTGroupByOutputType[P]>
        }
      >
    >


  export type DJTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
  }, ExtArgs["result"]["dJT"]>

  export type DJTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
  }, ExtArgs["result"]["dJT"]>

  export type DJTSelectScalar = {
    id?: boolean
    type?: boolean
    data?: boolean
  }


  export type $DJTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DJT"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      data: Buffer
    }, ExtArgs["result"]["dJT"]>
    composites: {}
  }

  type DJTGetPayload<S extends boolean | null | undefined | DJTDefaultArgs> = $Result.GetResult<Prisma.$DJTPayload, S>

  type DJTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DJTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DJTCountAggregateInputType | true
    }

  export interface DJTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DJT'], meta: { name: 'DJT' } }
    /**
     * Find zero or one DJT that matches the filter.
     * @param {DJTFindUniqueArgs} args - Arguments to find a DJT
     * @example
     * // Get one DJT
     * const dJT = await prisma.dJT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DJTFindUniqueArgs>(args: SelectSubset<T, DJTFindUniqueArgs<ExtArgs>>): Prisma__DJTClient<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DJT that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DJTFindUniqueOrThrowArgs} args - Arguments to find a DJT
     * @example
     * // Get one DJT
     * const dJT = await prisma.dJT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DJTFindUniqueOrThrowArgs>(args: SelectSubset<T, DJTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DJTClient<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DJT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DJTFindFirstArgs} args - Arguments to find a DJT
     * @example
     * // Get one DJT
     * const dJT = await prisma.dJT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DJTFindFirstArgs>(args?: SelectSubset<T, DJTFindFirstArgs<ExtArgs>>): Prisma__DJTClient<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DJT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DJTFindFirstOrThrowArgs} args - Arguments to find a DJT
     * @example
     * // Get one DJT
     * const dJT = await prisma.dJT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DJTFindFirstOrThrowArgs>(args?: SelectSubset<T, DJTFindFirstOrThrowArgs<ExtArgs>>): Prisma__DJTClient<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DJTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DJTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DJTS
     * const dJTS = await prisma.dJT.findMany()
     * 
     * // Get first 10 DJTS
     * const dJTS = await prisma.dJT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dJTWithIdOnly = await prisma.dJT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DJTFindManyArgs>(args?: SelectSubset<T, DJTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DJT.
     * @param {DJTCreateArgs} args - Arguments to create a DJT.
     * @example
     * // Create one DJT
     * const DJT = await prisma.dJT.create({
     *   data: {
     *     // ... data to create a DJT
     *   }
     * })
     * 
     */
    create<T extends DJTCreateArgs>(args: SelectSubset<T, DJTCreateArgs<ExtArgs>>): Prisma__DJTClient<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DJTS.
     * @param {DJTCreateManyArgs} args - Arguments to create many DJTS.
     * @example
     * // Create many DJTS
     * const dJT = await prisma.dJT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DJTCreateManyArgs>(args?: SelectSubset<T, DJTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DJTS and returns the data saved in the database.
     * @param {DJTCreateManyAndReturnArgs} args - Arguments to create many DJTS.
     * @example
     * // Create many DJTS
     * const dJT = await prisma.dJT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DJTS and only return the `id`
     * const dJTWithIdOnly = await prisma.dJT.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DJTCreateManyAndReturnArgs>(args?: SelectSubset<T, DJTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DJT.
     * @param {DJTDeleteArgs} args - Arguments to delete one DJT.
     * @example
     * // Delete one DJT
     * const DJT = await prisma.dJT.delete({
     *   where: {
     *     // ... filter to delete one DJT
     *   }
     * })
     * 
     */
    delete<T extends DJTDeleteArgs>(args: SelectSubset<T, DJTDeleteArgs<ExtArgs>>): Prisma__DJTClient<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DJT.
     * @param {DJTUpdateArgs} args - Arguments to update one DJT.
     * @example
     * // Update one DJT
     * const dJT = await prisma.dJT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DJTUpdateArgs>(args: SelectSubset<T, DJTUpdateArgs<ExtArgs>>): Prisma__DJTClient<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DJTS.
     * @param {DJTDeleteManyArgs} args - Arguments to filter DJTS to delete.
     * @example
     * // Delete a few DJTS
     * const { count } = await prisma.dJT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DJTDeleteManyArgs>(args?: SelectSubset<T, DJTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DJTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DJTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DJTS
     * const dJT = await prisma.dJT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DJTUpdateManyArgs>(args: SelectSubset<T, DJTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DJT.
     * @param {DJTUpsertArgs} args - Arguments to update or create a DJT.
     * @example
     * // Update or create a DJT
     * const dJT = await prisma.dJT.upsert({
     *   create: {
     *     // ... data to create a DJT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DJT we want to update
     *   }
     * })
     */
    upsert<T extends DJTUpsertArgs>(args: SelectSubset<T, DJTUpsertArgs<ExtArgs>>): Prisma__DJTClient<$Result.GetResult<Prisma.$DJTPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DJTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DJTCountArgs} args - Arguments to filter DJTS to count.
     * @example
     * // Count the number of DJTS
     * const count = await prisma.dJT.count({
     *   where: {
     *     // ... the filter for the DJTS we want to count
     *   }
     * })
    **/
    count<T extends DJTCountArgs>(
      args?: Subset<T, DJTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DJTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DJT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DJTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DJTAggregateArgs>(args: Subset<T, DJTAggregateArgs>): Prisma.PrismaPromise<GetDJTAggregateType<T>>

    /**
     * Group by DJT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DJTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DJTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DJTGroupByArgs['orderBy'] }
        : { orderBy?: DJTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DJTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDJTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DJT model
   */
  readonly fields: DJTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DJT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DJTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DJT model
   */ 
  interface DJTFieldRefs {
    readonly id: FieldRef<"DJT", 'Int'>
    readonly type: FieldRef<"DJT", 'String'>
    readonly data: FieldRef<"DJT", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * DJT findUnique
   */
  export type DJTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * Filter, which DJT to fetch.
     */
    where: DJTWhereUniqueInput
  }

  /**
   * DJT findUniqueOrThrow
   */
  export type DJTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * Filter, which DJT to fetch.
     */
    where: DJTWhereUniqueInput
  }

  /**
   * DJT findFirst
   */
  export type DJTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * Filter, which DJT to fetch.
     */
    where?: DJTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DJTS to fetch.
     */
    orderBy?: DJTOrderByWithRelationInput | DJTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DJTS.
     */
    cursor?: DJTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DJTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DJTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DJTS.
     */
    distinct?: DJTScalarFieldEnum | DJTScalarFieldEnum[]
  }

  /**
   * DJT findFirstOrThrow
   */
  export type DJTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * Filter, which DJT to fetch.
     */
    where?: DJTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DJTS to fetch.
     */
    orderBy?: DJTOrderByWithRelationInput | DJTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DJTS.
     */
    cursor?: DJTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DJTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DJTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DJTS.
     */
    distinct?: DJTScalarFieldEnum | DJTScalarFieldEnum[]
  }

  /**
   * DJT findMany
   */
  export type DJTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * Filter, which DJTS to fetch.
     */
    where?: DJTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DJTS to fetch.
     */
    orderBy?: DJTOrderByWithRelationInput | DJTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DJTS.
     */
    cursor?: DJTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DJTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DJTS.
     */
    skip?: number
    distinct?: DJTScalarFieldEnum | DJTScalarFieldEnum[]
  }

  /**
   * DJT create
   */
  export type DJTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * The data needed to create a DJT.
     */
    data: XOR<DJTCreateInput, DJTUncheckedCreateInput>
  }

  /**
   * DJT createMany
   */
  export type DJTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DJTS.
     */
    data: DJTCreateManyInput | DJTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DJT createManyAndReturn
   */
  export type DJTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DJTS.
     */
    data: DJTCreateManyInput | DJTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DJT update
   */
  export type DJTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * The data needed to update a DJT.
     */
    data: XOR<DJTUpdateInput, DJTUncheckedUpdateInput>
    /**
     * Choose, which DJT to update.
     */
    where: DJTWhereUniqueInput
  }

  /**
   * DJT updateMany
   */
  export type DJTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DJTS.
     */
    data: XOR<DJTUpdateManyMutationInput, DJTUncheckedUpdateManyInput>
    /**
     * Filter which DJTS to update
     */
    where?: DJTWhereInput
  }

  /**
   * DJT upsert
   */
  export type DJTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * The filter to search for the DJT to update in case it exists.
     */
    where: DJTWhereUniqueInput
    /**
     * In case the DJT found by the `where` argument doesn't exist, create a new DJT with this data.
     */
    create: XOR<DJTCreateInput, DJTUncheckedCreateInput>
    /**
     * In case the DJT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DJTUpdateInput, DJTUncheckedUpdateInput>
  }

  /**
   * DJT delete
   */
  export type DJTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
    /**
     * Filter which DJT to delete.
     */
    where: DJTWhereUniqueInput
  }

  /**
   * DJT deleteMany
   */
  export type DJTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DJTS to delete
     */
    where?: DJTWhereInput
  }

  /**
   * DJT without action
   */
  export type DJTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DJT
     */
    select?: DJTSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const FeatureRequestScalarFieldEnum: {
    id: 'id',
    email: 'email',
    message: 'message',
    category: 'category',
    userBase: 'userBase',
    receivedOn: 'receivedOn'
  };

  export type FeatureRequestScalarFieldEnum = (typeof FeatureRequestScalarFieldEnum)[keyof typeof FeatureRequestScalarFieldEnum]


  export const WaitlistRequestScalarFieldEnum: {
    id: 'id',
    email: 'email',
    receivedOn: 'receivedOn',
    emailsSent: 'emailsSent'
  };

  export type WaitlistRequestScalarFieldEnum = (typeof WaitlistRequestScalarFieldEnum)[keyof typeof WaitlistRequestScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    value: 'value',
    kanbanId: 'kanbanId'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    value: 'value',
    kanbanId: 'kanbanId'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const TagScalarFieldEnum: {
    value: 'value',
    kanbanId: 'kanbanId'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    body: 'body',
    author: 'author',
    source: 'source',
    pinned: 'pinned',
    createdAt: 'createdAt'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const DailyFocusScalarFieldEnum: {
    value: 'value',
    createdAt: 'createdAt'
  };

  export type DailyFocusScalarFieldEnum = (typeof DailyFocusScalarFieldEnum)[keyof typeof DailyFocusScalarFieldEnum]


  export const AutoSettingScalarFieldEnum: {
    id: 'id',
    type: 'type',
    glob: 'glob',
    value: 'value'
  };

  export type AutoSettingScalarFieldEnum = (typeof AutoSettingScalarFieldEnum)[keyof typeof AutoSettingScalarFieldEnum]


  export const ReadingListScalarFieldEnum: {
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    lastUpdate: 'lastUpdate'
  };

  export type ReadingListScalarFieldEnum = (typeof ReadingListScalarFieldEnum)[keyof typeof ReadingListScalarFieldEnum]


  export const BibEntryScalarFieldEnum: {
    id: 'id',
    BibId: 'BibId',
    OwnWork: 'OwnWork',
    ColleaguesWork: 'ColleaguesWork',
    read: 'read',
    htmlCitation: 'htmlCitation',
    PdfPath: 'PdfPath',
    address: 'address',
    annote: 'annote',
    author: 'author',
    booktitle: 'booktitle',
    chapter: 'chapter',
    crossref: 'crossref',
    doi: 'doi',
    edition: 'edition',
    editor: 'editor',
    email: 'email',
    howpublished: 'howpublished',
    institution: 'institution',
    journal: 'journal',
    month: 'month',
    note: 'note',
    number: 'number',
    organization: 'organization',
    pages: 'pages',
    publisher: 'publisher',
    school: 'school',
    series: 'series',
    title: 'title',
    volume: 'volume',
    type: 'type',
    year: 'year',
    numpages: 'numpages',
    url: 'url',
    issue: 'issue',
    issn: 'issn',
    abstract: 'abstract',
    urldate: 'urldate',
    keywords: 'keywords',
    copyright: 'copyright',
    added: 'added'
  };

  export type BibEntryScalarFieldEnum = (typeof BibEntryScalarFieldEnum)[keyof typeof BibEntryScalarFieldEnum]


  export const CitationsGroupScalarFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type CitationsGroupScalarFieldEnum = (typeof CitationsGroupScalarFieldEnum)[keyof typeof CitationsGroupScalarFieldEnum]


  export const BibScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    firstSync: 'firstSync',
    lastSync: 'lastSync'
  };

  export type BibScalarFieldEnum = (typeof BibScalarFieldEnum)[keyof typeof BibScalarFieldEnum]


  export const GoogleCalendarAuthScalarFieldEnum: {
    id: 'id',
    auth: 'auth'
  };

  export type GoogleCalendarAuthScalarFieldEnum = (typeof GoogleCalendarAuthScalarFieldEnum)[keyof typeof GoogleCalendarAuthScalarFieldEnum]


  export const SnippetScalarFieldEnum: {
    id: 'id',
    content: 'content',
    description: 'description',
    keywords: 'keywords',
    language: 'language'
  };

  export type SnippetScalarFieldEnum = (typeof SnippetScalarFieldEnum)[keyof typeof SnippetScalarFieldEnum]


  export const RelatedValuesScalarFieldEnum: {
    id: 'id',
    input: 'input',
    output: 'output',
    equationId: 'equationId'
  };

  export type RelatedValuesScalarFieldEnum = (typeof RelatedValuesScalarFieldEnum)[keyof typeof RelatedValuesScalarFieldEnum]


  export const EquationScalarFieldEnum: {
    id: 'id',
    equationId: 'equationId',
    title: 'title',
    desc: 'desc',
    content: 'content',
    asPython: 'asPython',
    variableLegend: 'variableLegend',
    variables: 'variables',
    keywords: 'keywords',
    createdAt: 'createdAt'
  };

  export type EquationScalarFieldEnum = (typeof EquationScalarFieldEnum)[keyof typeof EquationScalarFieldEnum]


  export const DefinitionScalarFieldEnum: {
    id: 'id',
    label: 'label',
    content: 'content',
    alphabeticalLabel: 'alphabeticalLabel',
    mdxNoteId: 'mdxNoteId'
  };

  export type DefinitionScalarFieldEnum = (typeof DefinitionScalarFieldEnum)[keyof typeof DefinitionScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    tooltips: 'tooltips',
    title: 'title',
    summary_showCitations: 'summary_showCitations',
    summary_showTags: 'summary_showTags',
    landingImageAlign: 'landingImageAlign',
    lockedLandingImage: 'lockedLandingImage',
    cleanOnSync: 'cleanOnSync',
    firstSync: 'firstSync',
    lastSync: 'lastSync'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const SettingsAppendixScalarFieldEnum: {
    id: 'id',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingsAppendixScalarFieldEnum = (typeof SettingsAppendixScalarFieldEnum)[keyof typeof SettingsAppendixScalarFieldEnum]


  export const RandomImageScalarFieldEnum: {
    path: 'path',
    createdAt: 'createdAt'
  };

  export type RandomImageScalarFieldEnum = (typeof RandomImageScalarFieldEnum)[keyof typeof RandomImageScalarFieldEnum]


  export const NoteTypeScalarFieldEnum: {
    name: 'name'
  };

  export type NoteTypeScalarFieldEnum = (typeof NoteTypeScalarFieldEnum)[keyof typeof NoteTypeScalarFieldEnum]


  export const QAPairScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    description: 'description',
    secondaryLabel: 'secondaryLabel',
    correctCount: 'correctCount',
    inCorrectCount: 'inCorrectCount'
  };

  export type QAPairScalarFieldEnum = (typeof QAPairScalarFieldEnum)[keyof typeof QAPairScalarFieldEnum]


  export const PracticeExamScalarFieldEnum: {
    id: 'id',
    correctCount: 'correctCount',
    inCorrectCount: 'inCorrectCount',
    timeLimitInSeconds: 'timeLimitInSeconds',
    timeCompletedInSeconds: 'timeCompletedInSeconds',
    date: 'date'
  };

  export type PracticeExamScalarFieldEnum = (typeof PracticeExamScalarFieldEnum)[keyof typeof PracticeExamScalarFieldEnum]


  export const SequentialNoteListScalarFieldEnum: {
    sequentialKey: 'sequentialKey'
  };

  export type SequentialNoteListScalarFieldEnum = (typeof SequentialNoteListScalarFieldEnum)[keyof typeof SequentialNoteListScalarFieldEnum]


  export const MdxNoteScalarFieldEnum: {
    id: 'id',
    isProtected: 'isProtected',
    dietSummaryKey: 'dietSummaryKey',
    title: 'title',
    latexTitle: 'latexTitle',
    rootRelativePath: 'rootRelativePath',
    noteType: 'noteType',
    content: 'content',
    formatted: 'formatted',
    summary: 'summary',
    citationsListOrder: 'citationsListOrder',
    importantValues: 'importantValues',
    imageSrc: 'imageSrc',
    href: 'href',
    sequentialKey: 'sequentialKey',
    sequentialIndex: 'sequentialIndex',
    floatImages: 'floatImages',
    remoteUrl: 'remoteUrl',
    trackRemote: 'trackRemote',
    outgoingQuickLinks: 'outgoingQuickLinks',
    quickLink: 'quickLink',
    bookmarked: 'bookmarked',
    firstSync: 'firstSync',
    lastSync: 'lastSync'
  };

  export type MdxNoteScalarFieldEnum = (typeof MdxNoteScalarFieldEnum)[keyof typeof MdxNoteScalarFieldEnum]


  export const IpynbScalarFieldEnum: {
    id: 'id',
    rootRelativePath: 'rootRelativePath',
    isProtected: 'isProtected',
    title: 'title',
    latexTitle: 'latexTitle',
    citationsListOrder: 'citationsListOrder',
    importantValues: 'importantValues',
    href: 'href',
    outgoingQuickLinks: 'outgoingQuickLinks',
    raw: 'raw',
    sequentialKey: 'sequentialKey',
    sequentialIndex: 'sequentialIndex',
    bookmarked: 'bookmarked',
    firstSync: 'firstSync',
    lastSync: 'lastSync'
  };

  export type IpynbScalarFieldEnum = (typeof IpynbScalarFieldEnum)[keyof typeof IpynbScalarFieldEnum]


  export const ToDoListScalarFieldEnum: {
    id: 'id',
    label: 'label',
    createdAt: 'createdAt',
    lastUpdate: 'lastUpdate'
  };

  export type ToDoListScalarFieldEnum = (typeof ToDoListScalarFieldEnum)[keyof typeof ToDoListScalarFieldEnum]


  export const ToDoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    task: 'task',
    dueAt: 'dueAt',
    details: 'details',
    parentId: 'parentId',
    category: 'category',
    bookmarked: 'bookmarked',
    status: 'status',
    priority: 'priority',
    toDoListId: 'toDoListId'
  };

  export type ToDoScalarFieldEnum = (typeof ToDoScalarFieldEnum)[keyof typeof ToDoScalarFieldEnum]


  export const KanBanCardScalarFieldEnum: {
    id: 'id',
    listId: 'listId',
    indexWithinList: 'indexWithinList',
    label: 'label',
    details: 'details'
  };

  export type KanBanCardScalarFieldEnum = (typeof KanBanCardScalarFieldEnum)[keyof typeof KanBanCardScalarFieldEnum]


  export const KanBanListScalarFieldEnum: {
    id: 'id',
    indexWithinBoard: 'indexWithinBoard',
    title: 'title',
    boardId: 'boardId'
  };

  export type KanBanListScalarFieldEnum = (typeof KanBanListScalarFieldEnum)[keyof typeof KanBanListScalarFieldEnum]


  export const KanbanScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    lastUpdate: 'lastUpdate'
  };

  export type KanbanScalarFieldEnum = (typeof KanbanScalarFieldEnum)[keyof typeof KanbanScalarFieldEnum]


  export const TimePeriodScalarFieldEnum: {
    id: 'id',
    start: 'start',
    end: 'end',
    dietId: 'dietId'
  };

  export type TimePeriodScalarFieldEnum = (typeof TimePeriodScalarFieldEnum)[keyof typeof TimePeriodScalarFieldEnum]


  export const DietScalarFieldEnum: {
    name: 'name',
    summary: 'summary',
    activelyFollowing: 'activelyFollowing',
    gf: 'gf',
    vegan: 'vegan',
    pescatarian: 'pescatarian',
    vegetarian: 'vegetarian',
    fasting: 'fasting',
    cardioTraining: 'cardioTraining',
    weightTraining: 'weightTraining',
    carb: 'carb',
    pro: 'pro',
    fat: 'fat',
    goals: 'goals',
    created: 'created',
    lastUpdate: 'lastUpdate'
  };

  export type DietScalarFieldEnum = (typeof DietScalarFieldEnum)[keyof typeof DietScalarFieldEnum]


  export const ServingScalarFieldEnum: {
    id: 'id',
    dietaryItemId: 'dietaryItemId',
    quant_oz: 'quant_oz',
    quant_guess: 'quant_guess'
  };

  export type ServingScalarFieldEnum = (typeof ServingScalarFieldEnum)[keyof typeof ServingScalarFieldEnum]


  export const DietaryItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    barcode: 'barcode',
    gi: 'gi',
    calsPerOz: 'calsPerOz',
    glutenFree: 'glutenFree',
    minimalFructose: 'minimalFructose',
    natural: 'natural',
    organic: 'organic',
    impactScore: 'impactScore'
  };

  export type DietaryItemScalarFieldEnum = (typeof DietaryItemScalarFieldEnum)[keyof typeof DietaryItemScalarFieldEnum]


  export const HealthReportScalarFieldEnum: {
    id: 'id',
    title: 'title',
    summary: 'summary',
    overall: 'overall',
    skin: 'skin',
    bloat: 'bloat',
    weight_feeling: 'weight_feeling',
    fullness: 'fullness',
    weight: 'weight',
    cardiacCapacity: 'cardiacCapacity',
    jawLine: 'jawLine',
    joints: 'joints',
    flexibility: 'flexibility',
    anxiety: 'anxiety',
    anxiety_desc: 'anxiety_desc',
    mood_desc: 'mood_desc',
    mood: 'mood',
    sexDrive: 'sexDrive',
    intruisiveThoughts: 'intruisiveThoughts',
    caffeineIntake: 'caffeineIntake',
    glutenIntake: 'glutenIntake',
    sugarIntake: 'sugarIntake',
    artificialSweetenerIntake: 'artificialSweetenerIntake',
    artificalDyes: 'artificalDyes',
    sleepQuality: 'sleepQuality',
    hydration: 'hydration',
    twitching: 'twitching',
    sleepHours: 'sleepHours',
    calorie_est: 'calorie_est',
    times_meals_more_than_gap_apart: 'times_meals_more_than_gap_apart',
    estHoursInExcessFast: 'estHoursInExcessFast',
    dietId: 'dietId',
    created: 'created'
  };

  export type HealthReportScalarFieldEnum = (typeof HealthReportScalarFieldEnum)[keyof typeof HealthReportScalarFieldEnum]


  export const WhiteboardScalarFieldEnum: {
    id: 'id',
    data: 'data'
  };

  export type WhiteboardScalarFieldEnum = (typeof WhiteboardScalarFieldEnum)[keyof typeof WhiteboardScalarFieldEnum]


  export const DJTScalarFieldEnum: {
    id: 'id',
    type: 'type',
    data: 'data'
  };

  export type DJTScalarFieldEnum = (typeof DJTScalarFieldEnum)[keyof typeof DJTScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const FeatureRequestOrderByRelevanceFieldEnum: {
    email: 'email',
    message: 'message',
    category: 'category',
    userBase: 'userBase'
  };

  export type FeatureRequestOrderByRelevanceFieldEnum = (typeof FeatureRequestOrderByRelevanceFieldEnum)[keyof typeof FeatureRequestOrderByRelevanceFieldEnum]


  export const WaitlistRequestOrderByRelevanceFieldEnum: {
    email: 'email'
  };

  export type WaitlistRequestOrderByRelevanceFieldEnum = (typeof WaitlistRequestOrderByRelevanceFieldEnum)[keyof typeof WaitlistRequestOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const SubjectOrderByRelevanceFieldEnum: {
    value: 'value'
  };

  export type SubjectOrderByRelevanceFieldEnum = (typeof SubjectOrderByRelevanceFieldEnum)[keyof typeof SubjectOrderByRelevanceFieldEnum]


  export const TopicOrderByRelevanceFieldEnum: {
    value: 'value'
  };

  export type TopicOrderByRelevanceFieldEnum = (typeof TopicOrderByRelevanceFieldEnum)[keyof typeof TopicOrderByRelevanceFieldEnum]


  export const TagOrderByRelevanceFieldEnum: {
    value: 'value'
  };

  export type TagOrderByRelevanceFieldEnum = (typeof TagOrderByRelevanceFieldEnum)[keyof typeof TagOrderByRelevanceFieldEnum]


  export const QuoteOrderByRelevanceFieldEnum: {
    body: 'body',
    author: 'author',
    source: 'source'
  };

  export type QuoteOrderByRelevanceFieldEnum = (typeof QuoteOrderByRelevanceFieldEnum)[keyof typeof QuoteOrderByRelevanceFieldEnum]


  export const DailyFocusOrderByRelevanceFieldEnum: {
    value: 'value'
  };

  export type DailyFocusOrderByRelevanceFieldEnum = (typeof DailyFocusOrderByRelevanceFieldEnum)[keyof typeof DailyFocusOrderByRelevanceFieldEnum]


  export const AutoSettingOrderByRelevanceFieldEnum: {
    glob: 'glob',
    value: 'value'
  };

  export type AutoSettingOrderByRelevanceFieldEnum = (typeof AutoSettingOrderByRelevanceFieldEnum)[keyof typeof AutoSettingOrderByRelevanceFieldEnum]


  export const ReadingListOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type ReadingListOrderByRelevanceFieldEnum = (typeof ReadingListOrderByRelevanceFieldEnum)[keyof typeof ReadingListOrderByRelevanceFieldEnum]


  export const BibEntryOrderByRelevanceFieldEnum: {
    id: 'id',
    htmlCitation: 'htmlCitation',
    PdfPath: 'PdfPath',
    address: 'address',
    annote: 'annote',
    author: 'author',
    booktitle: 'booktitle',
    chapter: 'chapter',
    crossref: 'crossref',
    doi: 'doi',
    edition: 'edition',
    editor: 'editor',
    email: 'email',
    howpublished: 'howpublished',
    institution: 'institution',
    journal: 'journal',
    month: 'month',
    note: 'note',
    number: 'number',
    organization: 'organization',
    pages: 'pages',
    publisher: 'publisher',
    school: 'school',
    series: 'series',
    title: 'title',
    volume: 'volume',
    type: 'type',
    year: 'year',
    numpages: 'numpages',
    url: 'url',
    issue: 'issue',
    issn: 'issn',
    abstract: 'abstract',
    urldate: 'urldate',
    keywords: 'keywords',
    copyright: 'copyright'
  };

  export type BibEntryOrderByRelevanceFieldEnum = (typeof BibEntryOrderByRelevanceFieldEnum)[keyof typeof BibEntryOrderByRelevanceFieldEnum]


  export const CitationsGroupOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type CitationsGroupOrderByRelevanceFieldEnum = (typeof CitationsGroupOrderByRelevanceFieldEnum)[keyof typeof CitationsGroupOrderByRelevanceFieldEnum]


  export const BibOrderByRelevanceFieldEnum: {
    filename: 'filename'
  };

  export type BibOrderByRelevanceFieldEnum = (typeof BibOrderByRelevanceFieldEnum)[keyof typeof BibOrderByRelevanceFieldEnum]


  export const GoogleCalendarAuthOrderByRelevanceFieldEnum: {
    auth: 'auth'
  };

  export type GoogleCalendarAuthOrderByRelevanceFieldEnum = (typeof GoogleCalendarAuthOrderByRelevanceFieldEnum)[keyof typeof GoogleCalendarAuthOrderByRelevanceFieldEnum]


  export const SnippetOrderByRelevanceFieldEnum: {
    content: 'content',
    description: 'description',
    keywords: 'keywords'
  };

  export type SnippetOrderByRelevanceFieldEnum = (typeof SnippetOrderByRelevanceFieldEnum)[keyof typeof SnippetOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const EquationOrderByRelevanceFieldEnum: {
    equationId: 'equationId',
    title: 'title',
    desc: 'desc',
    content: 'content',
    asPython: 'asPython',
    variables: 'variables',
    keywords: 'keywords'
  };

  export type EquationOrderByRelevanceFieldEnum = (typeof EquationOrderByRelevanceFieldEnum)[keyof typeof EquationOrderByRelevanceFieldEnum]


  export const DefinitionOrderByRelevanceFieldEnum: {
    id: 'id',
    label: 'label',
    content: 'content',
    alphabeticalLabel: 'alphabeticalLabel'
  };

  export type DefinitionOrderByRelevanceFieldEnum = (typeof DefinitionOrderByRelevanceFieldEnum)[keyof typeof DefinitionOrderByRelevanceFieldEnum]


  export const SettingsOrderByRelevanceFieldEnum: {
    title: 'title',
    lockedLandingImage: 'lockedLandingImage'
  };

  export type SettingsOrderByRelevanceFieldEnum = (typeof SettingsOrderByRelevanceFieldEnum)[keyof typeof SettingsOrderByRelevanceFieldEnum]


  export const SettingsAppendixOrderByRelevanceFieldEnum: {
    id: 'id'
  };

  export type SettingsAppendixOrderByRelevanceFieldEnum = (typeof SettingsAppendixOrderByRelevanceFieldEnum)[keyof typeof SettingsAppendixOrderByRelevanceFieldEnum]


  export const RandomImageOrderByRelevanceFieldEnum: {
    path: 'path'
  };

  export type RandomImageOrderByRelevanceFieldEnum = (typeof RandomImageOrderByRelevanceFieldEnum)[keyof typeof RandomImageOrderByRelevanceFieldEnum]


  export const NoteTypeOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type NoteTypeOrderByRelevanceFieldEnum = (typeof NoteTypeOrderByRelevanceFieldEnum)[keyof typeof NoteTypeOrderByRelevanceFieldEnum]


  export const QAPairOrderByRelevanceFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    description: 'description',
    secondaryLabel: 'secondaryLabel'
  };

  export type QAPairOrderByRelevanceFieldEnum = (typeof QAPairOrderByRelevanceFieldEnum)[keyof typeof QAPairOrderByRelevanceFieldEnum]


  export const SequentialNoteListOrderByRelevanceFieldEnum: {
    sequentialKey: 'sequentialKey'
  };

  export type SequentialNoteListOrderByRelevanceFieldEnum = (typeof SequentialNoteListOrderByRelevanceFieldEnum)[keyof typeof SequentialNoteListOrderByRelevanceFieldEnum]


  export const MdxNoteOrderByRelevanceFieldEnum: {
    dietSummaryKey: 'dietSummaryKey',
    title: 'title',
    latexTitle: 'latexTitle',
    rootRelativePath: 'rootRelativePath',
    noteType: 'noteType',
    content: 'content',
    formatted: 'formatted',
    summary: 'summary',
    citationsListOrder: 'citationsListOrder',
    imageSrc: 'imageSrc',
    href: 'href',
    sequentialKey: 'sequentialKey',
    remoteUrl: 'remoteUrl',
    outgoingQuickLinks: 'outgoingQuickLinks',
    quickLink: 'quickLink'
  };

  export type MdxNoteOrderByRelevanceFieldEnum = (typeof MdxNoteOrderByRelevanceFieldEnum)[keyof typeof MdxNoteOrderByRelevanceFieldEnum]


  export const IpynbOrderByRelevanceFieldEnum: {
    rootRelativePath: 'rootRelativePath',
    title: 'title',
    latexTitle: 'latexTitle',
    citationsListOrder: 'citationsListOrder',
    href: 'href',
    outgoingQuickLinks: 'outgoingQuickLinks',
    sequentialKey: 'sequentialKey'
  };

  export type IpynbOrderByRelevanceFieldEnum = (typeof IpynbOrderByRelevanceFieldEnum)[keyof typeof IpynbOrderByRelevanceFieldEnum]


  export const ToDoListOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type ToDoListOrderByRelevanceFieldEnum = (typeof ToDoListOrderByRelevanceFieldEnum)[keyof typeof ToDoListOrderByRelevanceFieldEnum]


  export const ToDoOrderByRelevanceFieldEnum: {
    task: 'task',
    details: 'details'
  };

  export type ToDoOrderByRelevanceFieldEnum = (typeof ToDoOrderByRelevanceFieldEnum)[keyof typeof ToDoOrderByRelevanceFieldEnum]


  export const KanBanCardOrderByRelevanceFieldEnum: {
    label: 'label',
    details: 'details'
  };

  export type KanBanCardOrderByRelevanceFieldEnum = (typeof KanBanCardOrderByRelevanceFieldEnum)[keyof typeof KanBanCardOrderByRelevanceFieldEnum]


  export const KanBanListOrderByRelevanceFieldEnum: {
    title: 'title'
  };

  export type KanBanListOrderByRelevanceFieldEnum = (typeof KanBanListOrderByRelevanceFieldEnum)[keyof typeof KanBanListOrderByRelevanceFieldEnum]


  export const KanbanOrderByRelevanceFieldEnum: {
    title: 'title'
  };

  export type KanbanOrderByRelevanceFieldEnum = (typeof KanbanOrderByRelevanceFieldEnum)[keyof typeof KanbanOrderByRelevanceFieldEnum]


  export const TimePeriodOrderByRelevanceFieldEnum: {
    dietId: 'dietId'
  };

  export type TimePeriodOrderByRelevanceFieldEnum = (typeof TimePeriodOrderByRelevanceFieldEnum)[keyof typeof TimePeriodOrderByRelevanceFieldEnum]


  export const DietOrderByRelevanceFieldEnum: {
    name: 'name',
    summary: 'summary'
  };

  export type DietOrderByRelevanceFieldEnum = (typeof DietOrderByRelevanceFieldEnum)[keyof typeof DietOrderByRelevanceFieldEnum]


  export const DietaryItemOrderByRelevanceFieldEnum: {
    name: 'name',
    barcode: 'barcode'
  };

  export type DietaryItemOrderByRelevanceFieldEnum = (typeof DietaryItemOrderByRelevanceFieldEnum)[keyof typeof DietaryItemOrderByRelevanceFieldEnum]


  export const HealthReportOrderByRelevanceFieldEnum: {
    title: 'title',
    summary: 'summary',
    anxiety_desc: 'anxiety_desc',
    mood_desc: 'mood_desc',
    dietId: 'dietId'
  };

  export type HealthReportOrderByRelevanceFieldEnum = (typeof HealthReportOrderByRelevanceFieldEnum)[keyof typeof HealthReportOrderByRelevanceFieldEnum]


  export const WhiteboardOrderByRelevanceFieldEnum: {
    id: 'id'
  };

  export type WhiteboardOrderByRelevanceFieldEnum = (typeof WhiteboardOrderByRelevanceFieldEnum)[keyof typeof WhiteboardOrderByRelevanceFieldEnum]


  export const DJTOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type DJTOrderByRelevanceFieldEnum = (typeof DJTOrderByRelevanceFieldEnum)[keyof typeof DJTOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'autoSetting'
   */
  export type EnumautoSettingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'autoSetting'>
    


  /**
   * Reference to a field of type 'autoSetting[]'
   */
  export type ListEnumautoSettingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'autoSetting[]'>
    


  /**
   * Reference to a field of type 'Technologies'
   */
  export type EnumTechnologiesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Technologies'>
    


  /**
   * Reference to a field of type 'Technologies[]'
   */
  export type ListEnumTechnologiesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Technologies[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ImageAlignment'
   */
  export type EnumImageAlignmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageAlignment'>
    


  /**
   * Reference to a field of type 'ImageAlignment[]'
   */
  export type ListEnumImageAlignmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageAlignment[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'TaskCategory'
   */
  export type EnumTaskCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskCategory'>
    


  /**
   * Reference to a field of type 'TaskCategory[]'
   */
  export type ListEnumTaskCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskCategory[]'>
    


  /**
   * Reference to a field of type 'ToDoListStatus'
   */
  export type EnumToDoListStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ToDoListStatus'>
    


  /**
   * Reference to a field of type 'ToDoListStatus[]'
   */
  export type ListEnumToDoListStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ToDoListStatus[]'>
    


  /**
   * Reference to a field of type 'TERTIARY_TOGGLE'
   */
  export type EnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TERTIARY_TOGGLE'>
    


  /**
   * Reference to a field of type 'TERTIARY_TOGGLE[]'
   */
  export type ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TERTIARY_TOGGLE[]'>
    


  /**
   * Reference to a field of type 'DIETARY_GOAL[]'
   */
  export type ListEnumDIETARY_GOALFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DIETARY_GOAL[]'>
    


  /**
   * Reference to a field of type 'DIETARY_GOAL'
   */
  export type EnumDIETARY_GOALFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DIETARY_GOAL'>
    


  /**
   * Reference to a field of type 'QUANTITY_GUESS'
   */
  export type EnumQUANTITY_GUESSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QUANTITY_GUESS'>
    


  /**
   * Reference to a field of type 'QUANTITY_GUESS[]'
   */
  export type ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QUANTITY_GUESS[]'>
    
  /**
   * Deep Input Types
   */


  export type FeatureRequestWhereInput = {
    AND?: FeatureRequestWhereInput | FeatureRequestWhereInput[]
    OR?: FeatureRequestWhereInput[]
    NOT?: FeatureRequestWhereInput | FeatureRequestWhereInput[]
    id?: IntFilter<"FeatureRequest"> | number
    email?: StringFilter<"FeatureRequest"> | string
    message?: StringFilter<"FeatureRequest"> | string
    category?: StringNullableListFilter<"FeatureRequest">
    userBase?: StringNullableListFilter<"FeatureRequest">
    receivedOn?: DateTimeFilter<"FeatureRequest"> | Date | string
  }

  export type FeatureRequestOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    message?: SortOrder
    category?: SortOrder
    userBase?: SortOrder
    receivedOn?: SortOrder
    _relevance?: FeatureRequestOrderByRelevanceInput
  }

  export type FeatureRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeatureRequestWhereInput | FeatureRequestWhereInput[]
    OR?: FeatureRequestWhereInput[]
    NOT?: FeatureRequestWhereInput | FeatureRequestWhereInput[]
    email?: StringFilter<"FeatureRequest"> | string
    message?: StringFilter<"FeatureRequest"> | string
    category?: StringNullableListFilter<"FeatureRequest">
    userBase?: StringNullableListFilter<"FeatureRequest">
    receivedOn?: DateTimeFilter<"FeatureRequest"> | Date | string
  }, "id">

  export type FeatureRequestOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    message?: SortOrder
    category?: SortOrder
    userBase?: SortOrder
    receivedOn?: SortOrder
    _count?: FeatureRequestCountOrderByAggregateInput
    _avg?: FeatureRequestAvgOrderByAggregateInput
    _max?: FeatureRequestMaxOrderByAggregateInput
    _min?: FeatureRequestMinOrderByAggregateInput
    _sum?: FeatureRequestSumOrderByAggregateInput
  }

  export type FeatureRequestScalarWhereWithAggregatesInput = {
    AND?: FeatureRequestScalarWhereWithAggregatesInput | FeatureRequestScalarWhereWithAggregatesInput[]
    OR?: FeatureRequestScalarWhereWithAggregatesInput[]
    NOT?: FeatureRequestScalarWhereWithAggregatesInput | FeatureRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeatureRequest"> | number
    email?: StringWithAggregatesFilter<"FeatureRequest"> | string
    message?: StringWithAggregatesFilter<"FeatureRequest"> | string
    category?: StringNullableListFilter<"FeatureRequest">
    userBase?: StringNullableListFilter<"FeatureRequest">
    receivedOn?: DateTimeWithAggregatesFilter<"FeatureRequest"> | Date | string
  }

  export type WaitlistRequestWhereInput = {
    AND?: WaitlistRequestWhereInput | WaitlistRequestWhereInput[]
    OR?: WaitlistRequestWhereInput[]
    NOT?: WaitlistRequestWhereInput | WaitlistRequestWhereInput[]
    id?: IntFilter<"WaitlistRequest"> | number
    email?: StringFilter<"WaitlistRequest"> | string
    receivedOn?: DateTimeFilter<"WaitlistRequest"> | Date | string
    emailsSent?: IntFilter<"WaitlistRequest"> | number
  }

  export type WaitlistRequestOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    receivedOn?: SortOrder
    emailsSent?: SortOrder
    _relevance?: WaitlistRequestOrderByRelevanceInput
  }

  export type WaitlistRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WaitlistRequestWhereInput | WaitlistRequestWhereInput[]
    OR?: WaitlistRequestWhereInput[]
    NOT?: WaitlistRequestWhereInput | WaitlistRequestWhereInput[]
    email?: StringFilter<"WaitlistRequest"> | string
    receivedOn?: DateTimeFilter<"WaitlistRequest"> | Date | string
    emailsSent?: IntFilter<"WaitlistRequest"> | number
  }, "id">

  export type WaitlistRequestOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    receivedOn?: SortOrder
    emailsSent?: SortOrder
    _count?: WaitlistRequestCountOrderByAggregateInput
    _avg?: WaitlistRequestAvgOrderByAggregateInput
    _max?: WaitlistRequestMaxOrderByAggregateInput
    _min?: WaitlistRequestMinOrderByAggregateInput
    _sum?: WaitlistRequestSumOrderByAggregateInput
  }

  export type WaitlistRequestScalarWhereWithAggregatesInput = {
    AND?: WaitlistRequestScalarWhereWithAggregatesInput | WaitlistRequestScalarWhereWithAggregatesInput[]
    OR?: WaitlistRequestScalarWhereWithAggregatesInput[]
    NOT?: WaitlistRequestScalarWhereWithAggregatesInput | WaitlistRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WaitlistRequest"> | number
    email?: StringWithAggregatesFilter<"WaitlistRequest"> | string
    receivedOn?: DateTimeWithAggregatesFilter<"WaitlistRequest"> | Date | string
    emailsSent?: IntWithAggregatesFilter<"WaitlistRequest"> | number
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    value?: StringFilter<"Subject"> | string
    kanbanId?: IntNullableFilter<"Subject"> | number | null
    MdxNotes?: MdxNoteListRelationFilter
    IpynbNotes?: IpynbListRelationFilter
    QaPair?: QAPairListRelationFilter
    practiceExam?: PracticeExamListRelationFilter
    Kanban?: XOR<KanbanNullableRelationFilter, KanbanWhereInput> | null
    todoList?: ToDoListListRelationFilter
    toDo?: ToDoListRelationFilter
    bibEntries?: BibEntryListRelationFilter
    equations?: EquationListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    value?: SortOrder
    kanbanId?: SortOrderInput | SortOrder
    MdxNotes?: MdxNoteOrderByRelationAggregateInput
    IpynbNotes?: IpynbOrderByRelationAggregateInput
    QaPair?: QAPairOrderByRelationAggregateInput
    practiceExam?: PracticeExamOrderByRelationAggregateInput
    Kanban?: KanbanOrderByWithRelationInput
    todoList?: ToDoListOrderByRelationAggregateInput
    toDo?: ToDoOrderByRelationAggregateInput
    bibEntries?: BibEntryOrderByRelationAggregateInput
    equations?: EquationOrderByRelationAggregateInput
    _relevance?: SubjectOrderByRelevanceInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    value?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    kanbanId?: IntNullableFilter<"Subject"> | number | null
    MdxNotes?: MdxNoteListRelationFilter
    IpynbNotes?: IpynbListRelationFilter
    QaPair?: QAPairListRelationFilter
    practiceExam?: PracticeExamListRelationFilter
    Kanban?: XOR<KanbanNullableRelationFilter, KanbanWhereInput> | null
    todoList?: ToDoListListRelationFilter
    toDo?: ToDoListRelationFilter
    bibEntries?: BibEntryListRelationFilter
    equations?: EquationListRelationFilter
  }, "value" | "value">

  export type SubjectOrderByWithAggregationInput = {
    value?: SortOrder
    kanbanId?: SortOrderInput | SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    value?: StringWithAggregatesFilter<"Subject"> | string
    kanbanId?: IntNullableWithAggregatesFilter<"Subject"> | number | null
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    value?: StringFilter<"Topic"> | string
    kanbanId?: IntNullableFilter<"Topic"> | number | null
    MdxNotes?: MdxNoteListRelationFilter
    ipynbNotes?: IpynbListRelationFilter
    QAPair?: QAPairListRelationFilter
    practiceExam?: PracticeExamListRelationFilter
    toDo?: ToDoListRelationFilter
    Kanban?: XOR<KanbanNullableRelationFilter, KanbanWhereInput> | null
    todoList?: ToDoListListRelationFilter
    bibEntries?: BibEntryListRelationFilter
    equations?: EquationListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    value?: SortOrder
    kanbanId?: SortOrderInput | SortOrder
    MdxNotes?: MdxNoteOrderByRelationAggregateInput
    ipynbNotes?: IpynbOrderByRelationAggregateInput
    QAPair?: QAPairOrderByRelationAggregateInput
    practiceExam?: PracticeExamOrderByRelationAggregateInput
    toDo?: ToDoOrderByRelationAggregateInput
    Kanban?: KanbanOrderByWithRelationInput
    todoList?: ToDoListOrderByRelationAggregateInput
    bibEntries?: BibEntryOrderByRelationAggregateInput
    equations?: EquationOrderByRelationAggregateInput
    _relevance?: TopicOrderByRelevanceInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    value?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    kanbanId?: IntNullableFilter<"Topic"> | number | null
    MdxNotes?: MdxNoteListRelationFilter
    ipynbNotes?: IpynbListRelationFilter
    QAPair?: QAPairListRelationFilter
    practiceExam?: PracticeExamListRelationFilter
    toDo?: ToDoListRelationFilter
    Kanban?: XOR<KanbanNullableRelationFilter, KanbanWhereInput> | null
    todoList?: ToDoListListRelationFilter
    bibEntries?: BibEntryListRelationFilter
    equations?: EquationListRelationFilter
  }, "value" | "value">

  export type TopicOrderByWithAggregationInput = {
    value?: SortOrder
    kanbanId?: SortOrderInput | SortOrder
    _count?: TopicCountOrderByAggregateInput
    _avg?: TopicAvgOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
    _sum?: TopicSumOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    value?: StringWithAggregatesFilter<"Topic"> | string
    kanbanId?: IntNullableWithAggregatesFilter<"Topic"> | number | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    value?: StringFilter<"Tag"> | string
    kanbanId?: IntNullableFilter<"Tag"> | number | null
    MdxNotes?: MdxNoteListRelationFilter
    bibEntries?: BibEntryListRelationFilter
    ipynbNotes?: IpynbListRelationFilter
    QAPair?: QAPairListRelationFilter
    practiceExam?: PracticeExamListRelationFilter
    equations?: EquationListRelationFilter
    toDo?: ToDoListRelationFilter
    Kanban?: XOR<KanbanNullableRelationFilter, KanbanWhereInput> | null
    todoList?: ToDoListListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    value?: SortOrder
    kanbanId?: SortOrderInput | SortOrder
    MdxNotes?: MdxNoteOrderByRelationAggregateInput
    bibEntries?: BibEntryOrderByRelationAggregateInput
    ipynbNotes?: IpynbOrderByRelationAggregateInput
    QAPair?: QAPairOrderByRelationAggregateInput
    practiceExam?: PracticeExamOrderByRelationAggregateInput
    equations?: EquationOrderByRelationAggregateInput
    toDo?: ToDoOrderByRelationAggregateInput
    Kanban?: KanbanOrderByWithRelationInput
    todoList?: ToDoListOrderByRelationAggregateInput
    _relevance?: TagOrderByRelevanceInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    value?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    kanbanId?: IntNullableFilter<"Tag"> | number | null
    MdxNotes?: MdxNoteListRelationFilter
    bibEntries?: BibEntryListRelationFilter
    ipynbNotes?: IpynbListRelationFilter
    QAPair?: QAPairListRelationFilter
    practiceExam?: PracticeExamListRelationFilter
    equations?: EquationListRelationFilter
    toDo?: ToDoListRelationFilter
    Kanban?: XOR<KanbanNullableRelationFilter, KanbanWhereInput> | null
    todoList?: ToDoListListRelationFilter
  }, "value" | "value">

  export type TagOrderByWithAggregationInput = {
    value?: SortOrder
    kanbanId?: SortOrderInput | SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    value?: StringWithAggregatesFilter<"Tag"> | string
    kanbanId?: IntNullableWithAggregatesFilter<"Tag"> | number | null
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    body?: StringFilter<"Quote"> | string
    author?: StringFilter<"Quote"> | string
    source?: StringNullableFilter<"Quote"> | string | null
    pinned?: BoolFilter<"Quote"> | boolean
    createdAt?: DateTimeFilter<"Quote"> | Date | string
  }

  export type QuoteOrderByWithRelationInput = {
    body?: SortOrder
    author?: SortOrder
    source?: SortOrderInput | SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
    _relevance?: QuoteOrderByRelevanceInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    body?: string
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    author?: StringFilter<"Quote"> | string
    source?: StringNullableFilter<"Quote"> | string | null
    pinned?: BoolFilter<"Quote"> | boolean
    createdAt?: DateTimeFilter<"Quote"> | Date | string
  }, "body" | "body">

  export type QuoteOrderByWithAggregationInput = {
    body?: SortOrder
    author?: SortOrder
    source?: SortOrderInput | SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    body?: StringWithAggregatesFilter<"Quote"> | string
    author?: StringWithAggregatesFilter<"Quote"> | string
    source?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    pinned?: BoolWithAggregatesFilter<"Quote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
  }

  export type DailyFocusWhereInput = {
    AND?: DailyFocusWhereInput | DailyFocusWhereInput[]
    OR?: DailyFocusWhereInput[]
    NOT?: DailyFocusWhereInput | DailyFocusWhereInput[]
    value?: StringFilter<"DailyFocus"> | string
    createdAt?: DateTimeFilter<"DailyFocus"> | Date | string
  }

  export type DailyFocusOrderByWithRelationInput = {
    value?: SortOrder
    createdAt?: SortOrder
    _relevance?: DailyFocusOrderByRelevanceInput
  }

  export type DailyFocusWhereUniqueInput = Prisma.AtLeast<{
    value?: string
    AND?: DailyFocusWhereInput | DailyFocusWhereInput[]
    OR?: DailyFocusWhereInput[]
    NOT?: DailyFocusWhereInput | DailyFocusWhereInput[]
    createdAt?: DateTimeFilter<"DailyFocus"> | Date | string
  }, "value" | "value">

  export type DailyFocusOrderByWithAggregationInput = {
    value?: SortOrder
    createdAt?: SortOrder
    _count?: DailyFocusCountOrderByAggregateInput
    _max?: DailyFocusMaxOrderByAggregateInput
    _min?: DailyFocusMinOrderByAggregateInput
  }

  export type DailyFocusScalarWhereWithAggregatesInput = {
    AND?: DailyFocusScalarWhereWithAggregatesInput | DailyFocusScalarWhereWithAggregatesInput[]
    OR?: DailyFocusScalarWhereWithAggregatesInput[]
    NOT?: DailyFocusScalarWhereWithAggregatesInput | DailyFocusScalarWhereWithAggregatesInput[]
    value?: StringWithAggregatesFilter<"DailyFocus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DailyFocus"> | Date | string
  }

  export type AutoSettingWhereInput = {
    AND?: AutoSettingWhereInput | AutoSettingWhereInput[]
    OR?: AutoSettingWhereInput[]
    NOT?: AutoSettingWhereInput | AutoSettingWhereInput[]
    id?: IntFilter<"AutoSetting"> | number
    type?: EnumautoSettingFilter<"AutoSetting"> | $Enums.autoSetting
    glob?: StringFilter<"AutoSetting"> | string
    value?: StringFilter<"AutoSetting"> | string
  }

  export type AutoSettingOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    glob?: SortOrder
    value?: SortOrder
    _relevance?: AutoSettingOrderByRelevanceInput
  }

  export type AutoSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AutoSettingWhereInput | AutoSettingWhereInput[]
    OR?: AutoSettingWhereInput[]
    NOT?: AutoSettingWhereInput | AutoSettingWhereInput[]
    type?: EnumautoSettingFilter<"AutoSetting"> | $Enums.autoSetting
    glob?: StringFilter<"AutoSetting"> | string
    value?: StringFilter<"AutoSetting"> | string
  }, "id">

  export type AutoSettingOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    glob?: SortOrder
    value?: SortOrder
    _count?: AutoSettingCountOrderByAggregateInput
    _avg?: AutoSettingAvgOrderByAggregateInput
    _max?: AutoSettingMaxOrderByAggregateInput
    _min?: AutoSettingMinOrderByAggregateInput
    _sum?: AutoSettingSumOrderByAggregateInput
  }

  export type AutoSettingScalarWhereWithAggregatesInput = {
    AND?: AutoSettingScalarWhereWithAggregatesInput | AutoSettingScalarWhereWithAggregatesInput[]
    OR?: AutoSettingScalarWhereWithAggregatesInput[]
    NOT?: AutoSettingScalarWhereWithAggregatesInput | AutoSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AutoSetting"> | number
    type?: EnumautoSettingWithAggregatesFilter<"AutoSetting"> | $Enums.autoSetting
    glob?: StringWithAggregatesFilter<"AutoSetting"> | string
    value?: StringWithAggregatesFilter<"AutoSetting"> | string
  }

  export type ReadingListWhereInput = {
    AND?: ReadingListWhereInput | ReadingListWhereInput[]
    OR?: ReadingListWhereInput[]
    NOT?: ReadingListWhereInput | ReadingListWhereInput[]
    name?: StringFilter<"ReadingList"> | string
    description?: StringNullableFilter<"ReadingList"> | string | null
    createdAt?: DateTimeFilter<"ReadingList"> | Date | string
    lastUpdate?: DateTimeFilter<"ReadingList"> | Date | string
    bibEntries?: BibEntryListRelationFilter
    mdxNotes?: MdxNoteListRelationFilter
    ipynbNotes?: IpynbListRelationFilter
  }

  export type ReadingListOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
    bibEntries?: BibEntryOrderByRelationAggregateInput
    mdxNotes?: MdxNoteOrderByRelationAggregateInput
    ipynbNotes?: IpynbOrderByRelationAggregateInput
    _relevance?: ReadingListOrderByRelevanceInput
  }

  export type ReadingListWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: ReadingListWhereInput | ReadingListWhereInput[]
    OR?: ReadingListWhereInput[]
    NOT?: ReadingListWhereInput | ReadingListWhereInput[]
    description?: StringNullableFilter<"ReadingList"> | string | null
    createdAt?: DateTimeFilter<"ReadingList"> | Date | string
    lastUpdate?: DateTimeFilter<"ReadingList"> | Date | string
    bibEntries?: BibEntryListRelationFilter
    mdxNotes?: MdxNoteListRelationFilter
    ipynbNotes?: IpynbListRelationFilter
  }, "name" | "name">

  export type ReadingListOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
    _count?: ReadingListCountOrderByAggregateInput
    _max?: ReadingListMaxOrderByAggregateInput
    _min?: ReadingListMinOrderByAggregateInput
  }

  export type ReadingListScalarWhereWithAggregatesInput = {
    AND?: ReadingListScalarWhereWithAggregatesInput | ReadingListScalarWhereWithAggregatesInput[]
    OR?: ReadingListScalarWhereWithAggregatesInput[]
    NOT?: ReadingListScalarWhereWithAggregatesInput | ReadingListScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"ReadingList"> | string
    description?: StringNullableWithAggregatesFilter<"ReadingList"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReadingList"> | Date | string
    lastUpdate?: DateTimeWithAggregatesFilter<"ReadingList"> | Date | string
  }

  export type BibEntryWhereInput = {
    AND?: BibEntryWhereInput | BibEntryWhereInput[]
    OR?: BibEntryWhereInput[]
    NOT?: BibEntryWhereInput | BibEntryWhereInput[]
    id?: StringFilter<"BibEntry"> | string
    BibId?: IntNullableFilter<"BibEntry"> | number | null
    OwnWork?: BoolFilter<"BibEntry"> | boolean
    ColleaguesWork?: BoolFilter<"BibEntry"> | boolean
    read?: BoolFilter<"BibEntry"> | boolean
    htmlCitation?: StringNullableFilter<"BibEntry"> | string | null
    PdfPath?: StringNullableFilter<"BibEntry"> | string | null
    address?: StringNullableFilter<"BibEntry"> | string | null
    annote?: StringNullableFilter<"BibEntry"> | string | null
    author?: StringNullableFilter<"BibEntry"> | string | null
    booktitle?: StringNullableFilter<"BibEntry"> | string | null
    chapter?: StringNullableFilter<"BibEntry"> | string | null
    crossref?: StringNullableFilter<"BibEntry"> | string | null
    doi?: StringNullableFilter<"BibEntry"> | string | null
    edition?: StringNullableFilter<"BibEntry"> | string | null
    editor?: StringNullableFilter<"BibEntry"> | string | null
    email?: StringNullableFilter<"BibEntry"> | string | null
    howpublished?: StringNullableFilter<"BibEntry"> | string | null
    institution?: StringNullableFilter<"BibEntry"> | string | null
    journal?: StringNullableFilter<"BibEntry"> | string | null
    month?: StringNullableFilter<"BibEntry"> | string | null
    note?: StringNullableFilter<"BibEntry"> | string | null
    number?: StringNullableFilter<"BibEntry"> | string | null
    organization?: StringNullableFilter<"BibEntry"> | string | null
    pages?: StringNullableFilter<"BibEntry"> | string | null
    publisher?: StringNullableFilter<"BibEntry"> | string | null
    school?: StringNullableFilter<"BibEntry"> | string | null
    series?: StringNullableFilter<"BibEntry"> | string | null
    title?: StringNullableFilter<"BibEntry"> | string | null
    volume?: StringNullableFilter<"BibEntry"> | string | null
    type?: StringNullableFilter<"BibEntry"> | string | null
    year?: StringNullableFilter<"BibEntry"> | string | null
    numpages?: StringNullableFilter<"BibEntry"> | string | null
    url?: StringNullableFilter<"BibEntry"> | string | null
    issue?: StringNullableFilter<"BibEntry"> | string | null
    issn?: StringNullableFilter<"BibEntry"> | string | null
    abstract?: StringNullableFilter<"BibEntry"> | string | null
    urldate?: StringNullableFilter<"BibEntry"> | string | null
    keywords?: StringNullableFilter<"BibEntry"> | string | null
    copyright?: StringNullableFilter<"BibEntry"> | string | null
    added?: DateTimeFilter<"BibEntry"> | Date | string
    Bib?: XOR<BibNullableRelationFilter, BibWhereInput> | null
    citationGroups?: CitationsGroupListRelationFilter
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    MdxNotes?: MdxNoteListRelationFilter
    ipynbNotes?: IpynbListRelationFilter
    readingList?: ReadingListListRelationFilter
  }

  export type BibEntryOrderByWithRelationInput = {
    id?: SortOrder
    BibId?: SortOrderInput | SortOrder
    OwnWork?: SortOrder
    ColleaguesWork?: SortOrder
    read?: SortOrder
    htmlCitation?: SortOrderInput | SortOrder
    PdfPath?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    annote?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    booktitle?: SortOrderInput | SortOrder
    chapter?: SortOrderInput | SortOrder
    crossref?: SortOrderInput | SortOrder
    doi?: SortOrderInput | SortOrder
    edition?: SortOrderInput | SortOrder
    editor?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    howpublished?: SortOrderInput | SortOrder
    institution?: SortOrderInput | SortOrder
    journal?: SortOrderInput | SortOrder
    month?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    pages?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    series?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    numpages?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    issue?: SortOrderInput | SortOrder
    issn?: SortOrderInput | SortOrder
    abstract?: SortOrderInput | SortOrder
    urldate?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    copyright?: SortOrderInput | SortOrder
    added?: SortOrder
    Bib?: BibOrderByWithRelationInput
    citationGroups?: CitationsGroupOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    MdxNotes?: MdxNoteOrderByRelationAggregateInput
    ipynbNotes?: IpynbOrderByRelationAggregateInput
    readingList?: ReadingListOrderByRelationAggregateInput
    _relevance?: BibEntryOrderByRelevanceInput
  }

  export type BibEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BibEntryWhereInput | BibEntryWhereInput[]
    OR?: BibEntryWhereInput[]
    NOT?: BibEntryWhereInput | BibEntryWhereInput[]
    BibId?: IntNullableFilter<"BibEntry"> | number | null
    OwnWork?: BoolFilter<"BibEntry"> | boolean
    ColleaguesWork?: BoolFilter<"BibEntry"> | boolean
    read?: BoolFilter<"BibEntry"> | boolean
    htmlCitation?: StringNullableFilter<"BibEntry"> | string | null
    PdfPath?: StringNullableFilter<"BibEntry"> | string | null
    address?: StringNullableFilter<"BibEntry"> | string | null
    annote?: StringNullableFilter<"BibEntry"> | string | null
    author?: StringNullableFilter<"BibEntry"> | string | null
    booktitle?: StringNullableFilter<"BibEntry"> | string | null
    chapter?: StringNullableFilter<"BibEntry"> | string | null
    crossref?: StringNullableFilter<"BibEntry"> | string | null
    doi?: StringNullableFilter<"BibEntry"> | string | null
    edition?: StringNullableFilter<"BibEntry"> | string | null
    editor?: StringNullableFilter<"BibEntry"> | string | null
    email?: StringNullableFilter<"BibEntry"> | string | null
    howpublished?: StringNullableFilter<"BibEntry"> | string | null
    institution?: StringNullableFilter<"BibEntry"> | string | null
    journal?: StringNullableFilter<"BibEntry"> | string | null
    month?: StringNullableFilter<"BibEntry"> | string | null
    note?: StringNullableFilter<"BibEntry"> | string | null
    number?: StringNullableFilter<"BibEntry"> | string | null
    organization?: StringNullableFilter<"BibEntry"> | string | null
    pages?: StringNullableFilter<"BibEntry"> | string | null
    publisher?: StringNullableFilter<"BibEntry"> | string | null
    school?: StringNullableFilter<"BibEntry"> | string | null
    series?: StringNullableFilter<"BibEntry"> | string | null
    title?: StringNullableFilter<"BibEntry"> | string | null
    volume?: StringNullableFilter<"BibEntry"> | string | null
    type?: StringNullableFilter<"BibEntry"> | string | null
    year?: StringNullableFilter<"BibEntry"> | string | null
    numpages?: StringNullableFilter<"BibEntry"> | string | null
    url?: StringNullableFilter<"BibEntry"> | string | null
    issue?: StringNullableFilter<"BibEntry"> | string | null
    issn?: StringNullableFilter<"BibEntry"> | string | null
    abstract?: StringNullableFilter<"BibEntry"> | string | null
    urldate?: StringNullableFilter<"BibEntry"> | string | null
    keywords?: StringNullableFilter<"BibEntry"> | string | null
    copyright?: StringNullableFilter<"BibEntry"> | string | null
    added?: DateTimeFilter<"BibEntry"> | Date | string
    Bib?: XOR<BibNullableRelationFilter, BibWhereInput> | null
    citationGroups?: CitationsGroupListRelationFilter
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    MdxNotes?: MdxNoteListRelationFilter
    ipynbNotes?: IpynbListRelationFilter
    readingList?: ReadingListListRelationFilter
  }, "id" | "id">

  export type BibEntryOrderByWithAggregationInput = {
    id?: SortOrder
    BibId?: SortOrderInput | SortOrder
    OwnWork?: SortOrder
    ColleaguesWork?: SortOrder
    read?: SortOrder
    htmlCitation?: SortOrderInput | SortOrder
    PdfPath?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    annote?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    booktitle?: SortOrderInput | SortOrder
    chapter?: SortOrderInput | SortOrder
    crossref?: SortOrderInput | SortOrder
    doi?: SortOrderInput | SortOrder
    edition?: SortOrderInput | SortOrder
    editor?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    howpublished?: SortOrderInput | SortOrder
    institution?: SortOrderInput | SortOrder
    journal?: SortOrderInput | SortOrder
    month?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    pages?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    series?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    numpages?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    issue?: SortOrderInput | SortOrder
    issn?: SortOrderInput | SortOrder
    abstract?: SortOrderInput | SortOrder
    urldate?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    copyright?: SortOrderInput | SortOrder
    added?: SortOrder
    _count?: BibEntryCountOrderByAggregateInput
    _avg?: BibEntryAvgOrderByAggregateInput
    _max?: BibEntryMaxOrderByAggregateInput
    _min?: BibEntryMinOrderByAggregateInput
    _sum?: BibEntrySumOrderByAggregateInput
  }

  export type BibEntryScalarWhereWithAggregatesInput = {
    AND?: BibEntryScalarWhereWithAggregatesInput | BibEntryScalarWhereWithAggregatesInput[]
    OR?: BibEntryScalarWhereWithAggregatesInput[]
    NOT?: BibEntryScalarWhereWithAggregatesInput | BibEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BibEntry"> | string
    BibId?: IntNullableWithAggregatesFilter<"BibEntry"> | number | null
    OwnWork?: BoolWithAggregatesFilter<"BibEntry"> | boolean
    ColleaguesWork?: BoolWithAggregatesFilter<"BibEntry"> | boolean
    read?: BoolWithAggregatesFilter<"BibEntry"> | boolean
    htmlCitation?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    PdfPath?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    address?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    annote?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    author?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    booktitle?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    chapter?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    crossref?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    doi?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    edition?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    editor?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    email?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    howpublished?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    institution?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    journal?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    month?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    note?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    number?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    organization?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    pages?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    publisher?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    school?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    series?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    title?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    volume?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    type?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    year?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    numpages?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    url?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    issue?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    issn?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    abstract?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    urldate?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    copyright?: StringNullableWithAggregatesFilter<"BibEntry"> | string | null
    added?: DateTimeWithAggregatesFilter<"BibEntry"> | Date | string
  }

  export type CitationsGroupWhereInput = {
    AND?: CitationsGroupWhereInput | CitationsGroupWhereInput[]
    OR?: CitationsGroupWhereInput[]
    NOT?: CitationsGroupWhereInput | CitationsGroupWhereInput[]
    name?: StringFilter<"CitationsGroup"> | string
    description?: StringNullableFilter<"CitationsGroup"> | string | null
    entries?: BibEntryListRelationFilter
  }

  export type CitationsGroupOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entries?: BibEntryOrderByRelationAggregateInput
    _relevance?: CitationsGroupOrderByRelevanceInput
  }

  export type CitationsGroupWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: CitationsGroupWhereInput | CitationsGroupWhereInput[]
    OR?: CitationsGroupWhereInput[]
    NOT?: CitationsGroupWhereInput | CitationsGroupWhereInput[]
    description?: StringNullableFilter<"CitationsGroup"> | string | null
    entries?: BibEntryListRelationFilter
  }, "name" | "name">

  export type CitationsGroupOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CitationsGroupCountOrderByAggregateInput
    _max?: CitationsGroupMaxOrderByAggregateInput
    _min?: CitationsGroupMinOrderByAggregateInput
  }

  export type CitationsGroupScalarWhereWithAggregatesInput = {
    AND?: CitationsGroupScalarWhereWithAggregatesInput | CitationsGroupScalarWhereWithAggregatesInput[]
    OR?: CitationsGroupScalarWhereWithAggregatesInput[]
    NOT?: CitationsGroupScalarWhereWithAggregatesInput | CitationsGroupScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"CitationsGroup"> | string
    description?: StringNullableWithAggregatesFilter<"CitationsGroup"> | string | null
  }

  export type BibWhereInput = {
    AND?: BibWhereInput | BibWhereInput[]
    OR?: BibWhereInput[]
    NOT?: BibWhereInput | BibWhereInput[]
    id?: IntFilter<"Bib"> | number
    filename?: StringFilter<"Bib"> | string
    firstSync?: DateTimeFilter<"Bib"> | Date | string
    lastSync?: DateTimeFilter<"Bib"> | Date | string
    entries?: BibEntryListRelationFilter
  }

  export type BibOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
    entries?: BibEntryOrderByRelationAggregateInput
    _relevance?: BibOrderByRelevanceInput
  }

  export type BibWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BibWhereInput | BibWhereInput[]
    OR?: BibWhereInput[]
    NOT?: BibWhereInput | BibWhereInput[]
    filename?: StringFilter<"Bib"> | string
    firstSync?: DateTimeFilter<"Bib"> | Date | string
    lastSync?: DateTimeFilter<"Bib"> | Date | string
    entries?: BibEntryListRelationFilter
  }, "id">

  export type BibOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
    _count?: BibCountOrderByAggregateInput
    _avg?: BibAvgOrderByAggregateInput
    _max?: BibMaxOrderByAggregateInput
    _min?: BibMinOrderByAggregateInput
    _sum?: BibSumOrderByAggregateInput
  }

  export type BibScalarWhereWithAggregatesInput = {
    AND?: BibScalarWhereWithAggregatesInput | BibScalarWhereWithAggregatesInput[]
    OR?: BibScalarWhereWithAggregatesInput[]
    NOT?: BibScalarWhereWithAggregatesInput | BibScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bib"> | number
    filename?: StringWithAggregatesFilter<"Bib"> | string
    firstSync?: DateTimeWithAggregatesFilter<"Bib"> | Date | string
    lastSync?: DateTimeWithAggregatesFilter<"Bib"> | Date | string
  }

  export type GoogleCalendarAuthWhereInput = {
    AND?: GoogleCalendarAuthWhereInput | GoogleCalendarAuthWhereInput[]
    OR?: GoogleCalendarAuthWhereInput[]
    NOT?: GoogleCalendarAuthWhereInput | GoogleCalendarAuthWhereInput[]
    id?: IntFilter<"GoogleCalendarAuth"> | number
    auth?: StringNullableFilter<"GoogleCalendarAuth"> | string | null
  }

  export type GoogleCalendarAuthOrderByWithRelationInput = {
    id?: SortOrder
    auth?: SortOrderInput | SortOrder
    _relevance?: GoogleCalendarAuthOrderByRelevanceInput
  }

  export type GoogleCalendarAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GoogleCalendarAuthWhereInput | GoogleCalendarAuthWhereInput[]
    OR?: GoogleCalendarAuthWhereInput[]
    NOT?: GoogleCalendarAuthWhereInput | GoogleCalendarAuthWhereInput[]
    auth?: StringNullableFilter<"GoogleCalendarAuth"> | string | null
  }, "id">

  export type GoogleCalendarAuthOrderByWithAggregationInput = {
    id?: SortOrder
    auth?: SortOrderInput | SortOrder
    _count?: GoogleCalendarAuthCountOrderByAggregateInput
    _avg?: GoogleCalendarAuthAvgOrderByAggregateInput
    _max?: GoogleCalendarAuthMaxOrderByAggregateInput
    _min?: GoogleCalendarAuthMinOrderByAggregateInput
    _sum?: GoogleCalendarAuthSumOrderByAggregateInput
  }

  export type GoogleCalendarAuthScalarWhereWithAggregatesInput = {
    AND?: GoogleCalendarAuthScalarWhereWithAggregatesInput | GoogleCalendarAuthScalarWhereWithAggregatesInput[]
    OR?: GoogleCalendarAuthScalarWhereWithAggregatesInput[]
    NOT?: GoogleCalendarAuthScalarWhereWithAggregatesInput | GoogleCalendarAuthScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GoogleCalendarAuth"> | number
    auth?: StringNullableWithAggregatesFilter<"GoogleCalendarAuth"> | string | null
  }

  export type SnippetWhereInput = {
    AND?: SnippetWhereInput | SnippetWhereInput[]
    OR?: SnippetWhereInput[]
    NOT?: SnippetWhereInput | SnippetWhereInput[]
    id?: IntFilter<"Snippet"> | number
    content?: StringFilter<"Snippet"> | string
    description?: StringFilter<"Snippet"> | string
    keywords?: StringNullableListFilter<"Snippet">
    language?: EnumTechnologiesFilter<"Snippet"> | $Enums.Technologies
  }

  export type SnippetOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    language?: SortOrder
    _relevance?: SnippetOrderByRelevanceInput
  }

  export type SnippetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SnippetWhereInput | SnippetWhereInput[]
    OR?: SnippetWhereInput[]
    NOT?: SnippetWhereInput | SnippetWhereInput[]
    content?: StringFilter<"Snippet"> | string
    description?: StringFilter<"Snippet"> | string
    keywords?: StringNullableListFilter<"Snippet">
    language?: EnumTechnologiesFilter<"Snippet"> | $Enums.Technologies
  }, "id">

  export type SnippetOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    language?: SortOrder
    _count?: SnippetCountOrderByAggregateInput
    _avg?: SnippetAvgOrderByAggregateInput
    _max?: SnippetMaxOrderByAggregateInput
    _min?: SnippetMinOrderByAggregateInput
    _sum?: SnippetSumOrderByAggregateInput
  }

  export type SnippetScalarWhereWithAggregatesInput = {
    AND?: SnippetScalarWhereWithAggregatesInput | SnippetScalarWhereWithAggregatesInput[]
    OR?: SnippetScalarWhereWithAggregatesInput[]
    NOT?: SnippetScalarWhereWithAggregatesInput | SnippetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Snippet"> | number
    content?: StringWithAggregatesFilter<"Snippet"> | string
    description?: StringWithAggregatesFilter<"Snippet"> | string
    keywords?: StringNullableListFilter<"Snippet">
    language?: EnumTechnologiesWithAggregatesFilter<"Snippet"> | $Enums.Technologies
  }

  export type RelatedValuesWhereInput = {
    AND?: RelatedValuesWhereInput | RelatedValuesWhereInput[]
    OR?: RelatedValuesWhereInput[]
    NOT?: RelatedValuesWhereInput | RelatedValuesWhereInput[]
    id?: IntFilter<"RelatedValues"> | number
    input?: JsonFilter<"RelatedValues">
    output?: FloatFilter<"RelatedValues"> | number
    equationId?: IntNullableListFilter<"RelatedValues">
    equations?: EquationListRelationFilter
  }

  export type RelatedValuesOrderByWithRelationInput = {
    id?: SortOrder
    input?: SortOrder
    output?: SortOrder
    equationId?: SortOrder
    equations?: EquationOrderByRelationAggregateInput
  }

  export type RelatedValuesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    equationId?: number[]
    AND?: RelatedValuesWhereInput | RelatedValuesWhereInput[]
    OR?: RelatedValuesWhereInput[]
    NOT?: RelatedValuesWhereInput | RelatedValuesWhereInput[]
    input?: JsonFilter<"RelatedValues">
    output?: FloatFilter<"RelatedValues"> | number
    equations?: EquationListRelationFilter
  }, "id" | "equationId">

  export type RelatedValuesOrderByWithAggregationInput = {
    id?: SortOrder
    input?: SortOrder
    output?: SortOrder
    equationId?: SortOrder
    _count?: RelatedValuesCountOrderByAggregateInput
    _avg?: RelatedValuesAvgOrderByAggregateInput
    _max?: RelatedValuesMaxOrderByAggregateInput
    _min?: RelatedValuesMinOrderByAggregateInput
    _sum?: RelatedValuesSumOrderByAggregateInput
  }

  export type RelatedValuesScalarWhereWithAggregatesInput = {
    AND?: RelatedValuesScalarWhereWithAggregatesInput | RelatedValuesScalarWhereWithAggregatesInput[]
    OR?: RelatedValuesScalarWhereWithAggregatesInput[]
    NOT?: RelatedValuesScalarWhereWithAggregatesInput | RelatedValuesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RelatedValues"> | number
    input?: JsonWithAggregatesFilter<"RelatedValues">
    output?: FloatWithAggregatesFilter<"RelatedValues"> | number
    equationId?: IntNullableListFilter<"RelatedValues">
  }

  export type EquationWhereInput = {
    AND?: EquationWhereInput | EquationWhereInput[]
    OR?: EquationWhereInput[]
    NOT?: EquationWhereInput | EquationWhereInput[]
    id?: IntFilter<"Equation"> | number
    equationId?: StringNullableFilter<"Equation"> | string | null
    title?: StringFilter<"Equation"> | string
    desc?: StringNullableFilter<"Equation"> | string | null
    content?: StringFilter<"Equation"> | string
    asPython?: StringNullableFilter<"Equation"> | string | null
    variableLegend?: JsonNullableFilter<"Equation">
    variables?: StringNullableListFilter<"Equation">
    keywords?: StringNullableListFilter<"Equation">
    createdAt?: DateTimeFilter<"Equation"> | Date | string
    relatedValues?: RelatedValuesListRelationFilter
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    mdxNotes?: MdxNoteListRelationFilter
  }

  export type EquationOrderByWithRelationInput = {
    id?: SortOrder
    equationId?: SortOrderInput | SortOrder
    title?: SortOrder
    desc?: SortOrderInput | SortOrder
    content?: SortOrder
    asPython?: SortOrderInput | SortOrder
    variableLegend?: SortOrderInput | SortOrder
    variables?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    relatedValues?: RelatedValuesOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    mdxNotes?: MdxNoteOrderByRelationAggregateInput
    _relevance?: EquationOrderByRelevanceInput
  }

  export type EquationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    equationId?: string
    AND?: EquationWhereInput | EquationWhereInput[]
    OR?: EquationWhereInput[]
    NOT?: EquationWhereInput | EquationWhereInput[]
    title?: StringFilter<"Equation"> | string
    desc?: StringNullableFilter<"Equation"> | string | null
    content?: StringFilter<"Equation"> | string
    asPython?: StringNullableFilter<"Equation"> | string | null
    variableLegend?: JsonNullableFilter<"Equation">
    variables?: StringNullableListFilter<"Equation">
    keywords?: StringNullableListFilter<"Equation">
    createdAt?: DateTimeFilter<"Equation"> | Date | string
    relatedValues?: RelatedValuesListRelationFilter
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    mdxNotes?: MdxNoteListRelationFilter
  }, "id" | "equationId">

  export type EquationOrderByWithAggregationInput = {
    id?: SortOrder
    equationId?: SortOrderInput | SortOrder
    title?: SortOrder
    desc?: SortOrderInput | SortOrder
    content?: SortOrder
    asPython?: SortOrderInput | SortOrder
    variableLegend?: SortOrderInput | SortOrder
    variables?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    _count?: EquationCountOrderByAggregateInput
    _avg?: EquationAvgOrderByAggregateInput
    _max?: EquationMaxOrderByAggregateInput
    _min?: EquationMinOrderByAggregateInput
    _sum?: EquationSumOrderByAggregateInput
  }

  export type EquationScalarWhereWithAggregatesInput = {
    AND?: EquationScalarWhereWithAggregatesInput | EquationScalarWhereWithAggregatesInput[]
    OR?: EquationScalarWhereWithAggregatesInput[]
    NOT?: EquationScalarWhereWithAggregatesInput | EquationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Equation"> | number
    equationId?: StringNullableWithAggregatesFilter<"Equation"> | string | null
    title?: StringWithAggregatesFilter<"Equation"> | string
    desc?: StringNullableWithAggregatesFilter<"Equation"> | string | null
    content?: StringWithAggregatesFilter<"Equation"> | string
    asPython?: StringNullableWithAggregatesFilter<"Equation"> | string | null
    variableLegend?: JsonNullableWithAggregatesFilter<"Equation">
    variables?: StringNullableListFilter<"Equation">
    keywords?: StringNullableListFilter<"Equation">
    createdAt?: DateTimeWithAggregatesFilter<"Equation"> | Date | string
  }

  export type DefinitionWhereInput = {
    AND?: DefinitionWhereInput | DefinitionWhereInput[]
    OR?: DefinitionWhereInput[]
    NOT?: DefinitionWhereInput | DefinitionWhereInput[]
    id?: StringFilter<"Definition"> | string
    label?: StringNullableFilter<"Definition"> | string | null
    content?: StringNullableFilter<"Definition"> | string | null
    alphabeticalLabel?: StringNullableFilter<"Definition"> | string | null
    mdxNoteId?: IntNullableFilter<"Definition"> | number | null
    mdxNote?: XOR<MdxNoteNullableRelationFilter, MdxNoteWhereInput> | null
  }

  export type DefinitionOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    alphabeticalLabel?: SortOrderInput | SortOrder
    mdxNoteId?: SortOrderInput | SortOrder
    mdxNote?: MdxNoteOrderByWithRelationInput
    _relevance?: DefinitionOrderByRelevanceInput
  }

  export type DefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DefinitionWhereInput | DefinitionWhereInput[]
    OR?: DefinitionWhereInput[]
    NOT?: DefinitionWhereInput | DefinitionWhereInput[]
    label?: StringNullableFilter<"Definition"> | string | null
    content?: StringNullableFilter<"Definition"> | string | null
    alphabeticalLabel?: StringNullableFilter<"Definition"> | string | null
    mdxNoteId?: IntNullableFilter<"Definition"> | number | null
    mdxNote?: XOR<MdxNoteNullableRelationFilter, MdxNoteWhereInput> | null
  }, "id" | "id">

  export type DefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    alphabeticalLabel?: SortOrderInput | SortOrder
    mdxNoteId?: SortOrderInput | SortOrder
    _count?: DefinitionCountOrderByAggregateInput
    _avg?: DefinitionAvgOrderByAggregateInput
    _max?: DefinitionMaxOrderByAggregateInput
    _min?: DefinitionMinOrderByAggregateInput
    _sum?: DefinitionSumOrderByAggregateInput
  }

  export type DefinitionScalarWhereWithAggregatesInput = {
    AND?: DefinitionScalarWhereWithAggregatesInput | DefinitionScalarWhereWithAggregatesInput[]
    OR?: DefinitionScalarWhereWithAggregatesInput[]
    NOT?: DefinitionScalarWhereWithAggregatesInput | DefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Definition"> | string
    label?: StringNullableWithAggregatesFilter<"Definition"> | string | null
    content?: StringNullableWithAggregatesFilter<"Definition"> | string | null
    alphabeticalLabel?: StringNullableWithAggregatesFilter<"Definition"> | string | null
    mdxNoteId?: IntNullableWithAggregatesFilter<"Definition"> | number | null
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: IntFilter<"Settings"> | number
    tooltips?: BoolFilter<"Settings"> | boolean
    title?: StringFilter<"Settings"> | string
    summary_showCitations?: BoolFilter<"Settings"> | boolean
    summary_showTags?: BoolFilter<"Settings"> | boolean
    landingImageAlign?: EnumImageAlignmentFilter<"Settings"> | $Enums.ImageAlignment
    lockedLandingImage?: StringNullableFilter<"Settings"> | string | null
    cleanOnSync?: BoolFilter<"Settings"> | boolean
    firstSync?: DateTimeFilter<"Settings"> | Date | string
    lastSync?: DateTimeFilter<"Settings"> | Date | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    tooltips?: SortOrder
    title?: SortOrder
    summary_showCitations?: SortOrder
    summary_showTags?: SortOrder
    landingImageAlign?: SortOrder
    lockedLandingImage?: SortOrderInput | SortOrder
    cleanOnSync?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
    _relevance?: SettingsOrderByRelevanceInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    tooltips?: BoolFilter<"Settings"> | boolean
    title?: StringFilter<"Settings"> | string
    summary_showCitations?: BoolFilter<"Settings"> | boolean
    summary_showTags?: BoolFilter<"Settings"> | boolean
    landingImageAlign?: EnumImageAlignmentFilter<"Settings"> | $Enums.ImageAlignment
    lockedLandingImage?: StringNullableFilter<"Settings"> | string | null
    cleanOnSync?: BoolFilter<"Settings"> | boolean
    firstSync?: DateTimeFilter<"Settings"> | Date | string
    lastSync?: DateTimeFilter<"Settings"> | Date | string
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    tooltips?: SortOrder
    title?: SortOrder
    summary_showCitations?: SortOrder
    summary_showTags?: SortOrder
    landingImageAlign?: SortOrder
    lockedLandingImage?: SortOrderInput | SortOrder
    cleanOnSync?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Settings"> | number
    tooltips?: BoolWithAggregatesFilter<"Settings"> | boolean
    title?: StringWithAggregatesFilter<"Settings"> | string
    summary_showCitations?: BoolWithAggregatesFilter<"Settings"> | boolean
    summary_showTags?: BoolWithAggregatesFilter<"Settings"> | boolean
    landingImageAlign?: EnumImageAlignmentWithAggregatesFilter<"Settings"> | $Enums.ImageAlignment
    lockedLandingImage?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    cleanOnSync?: BoolWithAggregatesFilter<"Settings"> | boolean
    firstSync?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    lastSync?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type SettingsAppendixWhereInput = {
    AND?: SettingsAppendixWhereInput | SettingsAppendixWhereInput[]
    OR?: SettingsAppendixWhereInput[]
    NOT?: SettingsAppendixWhereInput | SettingsAppendixWhereInput[]
    id?: StringFilter<"SettingsAppendix"> | string
    data?: BytesFilter<"SettingsAppendix"> | Buffer
    createdAt?: DateTimeFilter<"SettingsAppendix"> | Date | string
    updatedAt?: DateTimeFilter<"SettingsAppendix"> | Date | string
  }

  export type SettingsAppendixOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SettingsAppendixOrderByRelevanceInput
  }

  export type SettingsAppendixWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingsAppendixWhereInput | SettingsAppendixWhereInput[]
    OR?: SettingsAppendixWhereInput[]
    NOT?: SettingsAppendixWhereInput | SettingsAppendixWhereInput[]
    data?: BytesFilter<"SettingsAppendix"> | Buffer
    createdAt?: DateTimeFilter<"SettingsAppendix"> | Date | string
    updatedAt?: DateTimeFilter<"SettingsAppendix"> | Date | string
  }, "id" | "id">

  export type SettingsAppendixOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingsAppendixCountOrderByAggregateInput
    _max?: SettingsAppendixMaxOrderByAggregateInput
    _min?: SettingsAppendixMinOrderByAggregateInput
  }

  export type SettingsAppendixScalarWhereWithAggregatesInput = {
    AND?: SettingsAppendixScalarWhereWithAggregatesInput | SettingsAppendixScalarWhereWithAggregatesInput[]
    OR?: SettingsAppendixScalarWhereWithAggregatesInput[]
    NOT?: SettingsAppendixScalarWhereWithAggregatesInput | SettingsAppendixScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SettingsAppendix"> | string
    data?: BytesWithAggregatesFilter<"SettingsAppendix"> | Buffer
    createdAt?: DateTimeWithAggregatesFilter<"SettingsAppendix"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SettingsAppendix"> | Date | string
  }

  export type RandomImageWhereInput = {
    AND?: RandomImageWhereInput | RandomImageWhereInput[]
    OR?: RandomImageWhereInput[]
    NOT?: RandomImageWhereInput | RandomImageWhereInput[]
    path?: StringFilter<"RandomImage"> | string
    createdAt?: DateTimeFilter<"RandomImage"> | Date | string
  }

  export type RandomImageOrderByWithRelationInput = {
    path?: SortOrder
    createdAt?: SortOrder
    _relevance?: RandomImageOrderByRelevanceInput
  }

  export type RandomImageWhereUniqueInput = Prisma.AtLeast<{
    path?: string
    AND?: RandomImageWhereInput | RandomImageWhereInput[]
    OR?: RandomImageWhereInput[]
    NOT?: RandomImageWhereInput | RandomImageWhereInput[]
    createdAt?: DateTimeFilter<"RandomImage"> | Date | string
  }, "path" | "path">

  export type RandomImageOrderByWithAggregationInput = {
    path?: SortOrder
    createdAt?: SortOrder
    _count?: RandomImageCountOrderByAggregateInput
    _max?: RandomImageMaxOrderByAggregateInput
    _min?: RandomImageMinOrderByAggregateInput
  }

  export type RandomImageScalarWhereWithAggregatesInput = {
    AND?: RandomImageScalarWhereWithAggregatesInput | RandomImageScalarWhereWithAggregatesInput[]
    OR?: RandomImageScalarWhereWithAggregatesInput[]
    NOT?: RandomImageScalarWhereWithAggregatesInput | RandomImageScalarWhereWithAggregatesInput[]
    path?: StringWithAggregatesFilter<"RandomImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RandomImage"> | Date | string
  }

  export type NoteTypeWhereInput = {
    AND?: NoteTypeWhereInput | NoteTypeWhereInput[]
    OR?: NoteTypeWhereInput[]
    NOT?: NoteTypeWhereInput | NoteTypeWhereInput[]
    name?: StringFilter<"NoteType"> | string
  }

  export type NoteTypeOrderByWithRelationInput = {
    name?: SortOrder
    _relevance?: NoteTypeOrderByRelevanceInput
  }

  export type NoteTypeWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: NoteTypeWhereInput | NoteTypeWhereInput[]
    OR?: NoteTypeWhereInput[]
    NOT?: NoteTypeWhereInput | NoteTypeWhereInput[]
  }, "name" | "name">

  export type NoteTypeOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: NoteTypeCountOrderByAggregateInput
    _max?: NoteTypeMaxOrderByAggregateInput
    _min?: NoteTypeMinOrderByAggregateInput
  }

  export type NoteTypeScalarWhereWithAggregatesInput = {
    AND?: NoteTypeScalarWhereWithAggregatesInput | NoteTypeScalarWhereWithAggregatesInput[]
    OR?: NoteTypeScalarWhereWithAggregatesInput[]
    NOT?: NoteTypeScalarWhereWithAggregatesInput | NoteTypeScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"NoteType"> | string
  }

  export type QAPairWhereInput = {
    AND?: QAPairWhereInput | QAPairWhereInput[]
    OR?: QAPairWhereInput[]
    NOT?: QAPairWhereInput | QAPairWhereInput[]
    id?: StringFilter<"QAPair"> | string
    question?: StringFilter<"QAPair"> | string
    answer?: StringFilter<"QAPair"> | string
    description?: StringNullableFilter<"QAPair"> | string | null
    secondaryLabel?: StringNullableFilter<"QAPair"> | string | null
    correctCount?: IntFilter<"QAPair"> | number
    inCorrectCount?: IntFilter<"QAPair"> | number
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    practiceExam?: PracticeExamListRelationFilter
  }

  export type QAPairOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    description?: SortOrderInput | SortOrder
    secondaryLabel?: SortOrderInput | SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    tags?: TagOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    practiceExam?: PracticeExamOrderByRelationAggregateInput
    _relevance?: QAPairOrderByRelevanceInput
  }

  export type QAPairWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    question?: string
    AND?: QAPairWhereInput | QAPairWhereInput[]
    OR?: QAPairWhereInput[]
    NOT?: QAPairWhereInput | QAPairWhereInput[]
    answer?: StringFilter<"QAPair"> | string
    description?: StringNullableFilter<"QAPair"> | string | null
    secondaryLabel?: StringNullableFilter<"QAPair"> | string | null
    correctCount?: IntFilter<"QAPair"> | number
    inCorrectCount?: IntFilter<"QAPair"> | number
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    practiceExam?: PracticeExamListRelationFilter
  }, "id" | "id" | "question">

  export type QAPairOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    description?: SortOrderInput | SortOrder
    secondaryLabel?: SortOrderInput | SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    _count?: QAPairCountOrderByAggregateInput
    _avg?: QAPairAvgOrderByAggregateInput
    _max?: QAPairMaxOrderByAggregateInput
    _min?: QAPairMinOrderByAggregateInput
    _sum?: QAPairSumOrderByAggregateInput
  }

  export type QAPairScalarWhereWithAggregatesInput = {
    AND?: QAPairScalarWhereWithAggregatesInput | QAPairScalarWhereWithAggregatesInput[]
    OR?: QAPairScalarWhereWithAggregatesInput[]
    NOT?: QAPairScalarWhereWithAggregatesInput | QAPairScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QAPair"> | string
    question?: StringWithAggregatesFilter<"QAPair"> | string
    answer?: StringWithAggregatesFilter<"QAPair"> | string
    description?: StringNullableWithAggregatesFilter<"QAPair"> | string | null
    secondaryLabel?: StringNullableWithAggregatesFilter<"QAPair"> | string | null
    correctCount?: IntWithAggregatesFilter<"QAPair"> | number
    inCorrectCount?: IntWithAggregatesFilter<"QAPair"> | number
  }

  export type PracticeExamWhereInput = {
    AND?: PracticeExamWhereInput | PracticeExamWhereInput[]
    OR?: PracticeExamWhereInput[]
    NOT?: PracticeExamWhereInput | PracticeExamWhereInput[]
    id?: IntFilter<"PracticeExam"> | number
    correctCount?: IntFilter<"PracticeExam"> | number
    inCorrectCount?: IntFilter<"PracticeExam"> | number
    timeLimitInSeconds?: IntFilter<"PracticeExam"> | number
    timeCompletedInSeconds?: IntFilter<"PracticeExam"> | number
    date?: DateTimeFilter<"PracticeExam"> | Date | string
    topics?: TopicListRelationFilter
    tags?: TagListRelationFilter
    subjects?: SubjectListRelationFilter
    questions?: QAPairListRelationFilter
  }

  export type PracticeExamOrderByWithRelationInput = {
    id?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    timeLimitInSeconds?: SortOrder
    timeCompletedInSeconds?: SortOrder
    date?: SortOrder
    topics?: TopicOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    questions?: QAPairOrderByRelationAggregateInput
  }

  export type PracticeExamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PracticeExamWhereInput | PracticeExamWhereInput[]
    OR?: PracticeExamWhereInput[]
    NOT?: PracticeExamWhereInput | PracticeExamWhereInput[]
    correctCount?: IntFilter<"PracticeExam"> | number
    inCorrectCount?: IntFilter<"PracticeExam"> | number
    timeLimitInSeconds?: IntFilter<"PracticeExam"> | number
    timeCompletedInSeconds?: IntFilter<"PracticeExam"> | number
    date?: DateTimeFilter<"PracticeExam"> | Date | string
    topics?: TopicListRelationFilter
    tags?: TagListRelationFilter
    subjects?: SubjectListRelationFilter
    questions?: QAPairListRelationFilter
  }, "id">

  export type PracticeExamOrderByWithAggregationInput = {
    id?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    timeLimitInSeconds?: SortOrder
    timeCompletedInSeconds?: SortOrder
    date?: SortOrder
    _count?: PracticeExamCountOrderByAggregateInput
    _avg?: PracticeExamAvgOrderByAggregateInput
    _max?: PracticeExamMaxOrderByAggregateInput
    _min?: PracticeExamMinOrderByAggregateInput
    _sum?: PracticeExamSumOrderByAggregateInput
  }

  export type PracticeExamScalarWhereWithAggregatesInput = {
    AND?: PracticeExamScalarWhereWithAggregatesInput | PracticeExamScalarWhereWithAggregatesInput[]
    OR?: PracticeExamScalarWhereWithAggregatesInput[]
    NOT?: PracticeExamScalarWhereWithAggregatesInput | PracticeExamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PracticeExam"> | number
    correctCount?: IntWithAggregatesFilter<"PracticeExam"> | number
    inCorrectCount?: IntWithAggregatesFilter<"PracticeExam"> | number
    timeLimitInSeconds?: IntWithAggregatesFilter<"PracticeExam"> | number
    timeCompletedInSeconds?: IntWithAggregatesFilter<"PracticeExam"> | number
    date?: DateTimeWithAggregatesFilter<"PracticeExam"> | Date | string
  }

  export type SequentialNoteListWhereInput = {
    AND?: SequentialNoteListWhereInput | SequentialNoteListWhereInput[]
    OR?: SequentialNoteListWhereInput[]
    NOT?: SequentialNoteListWhereInput | SequentialNoteListWhereInput[]
    sequentialKey?: StringFilter<"SequentialNoteList"> | string
    MdxNote?: MdxNoteListRelationFilter
    Ipynb?: IpynbListRelationFilter
  }

  export type SequentialNoteListOrderByWithRelationInput = {
    sequentialKey?: SortOrder
    MdxNote?: MdxNoteOrderByRelationAggregateInput
    Ipynb?: IpynbOrderByRelationAggregateInput
    _relevance?: SequentialNoteListOrderByRelevanceInput
  }

  export type SequentialNoteListWhereUniqueInput = Prisma.AtLeast<{
    sequentialKey?: string
    AND?: SequentialNoteListWhereInput | SequentialNoteListWhereInput[]
    OR?: SequentialNoteListWhereInput[]
    NOT?: SequentialNoteListWhereInput | SequentialNoteListWhereInput[]
    MdxNote?: MdxNoteListRelationFilter
    Ipynb?: IpynbListRelationFilter
  }, "sequentialKey" | "sequentialKey">

  export type SequentialNoteListOrderByWithAggregationInput = {
    sequentialKey?: SortOrder
    _count?: SequentialNoteListCountOrderByAggregateInput
    _max?: SequentialNoteListMaxOrderByAggregateInput
    _min?: SequentialNoteListMinOrderByAggregateInput
  }

  export type SequentialNoteListScalarWhereWithAggregatesInput = {
    AND?: SequentialNoteListScalarWhereWithAggregatesInput | SequentialNoteListScalarWhereWithAggregatesInput[]
    OR?: SequentialNoteListScalarWhereWithAggregatesInput[]
    NOT?: SequentialNoteListScalarWhereWithAggregatesInput | SequentialNoteListScalarWhereWithAggregatesInput[]
    sequentialKey?: StringWithAggregatesFilter<"SequentialNoteList"> | string
  }

  export type MdxNoteWhereInput = {
    AND?: MdxNoteWhereInput | MdxNoteWhereInput[]
    OR?: MdxNoteWhereInput[]
    NOT?: MdxNoteWhereInput | MdxNoteWhereInput[]
    id?: IntFilter<"MdxNote"> | number
    isProtected?: BoolNullableFilter<"MdxNote"> | boolean | null
    dietSummaryKey?: StringNullableFilter<"MdxNote"> | string | null
    title?: StringFilter<"MdxNote"> | string
    latexTitle?: StringNullableFilter<"MdxNote"> | string | null
    rootRelativePath?: StringFilter<"MdxNote"> | string
    noteType?: StringFilter<"MdxNote"> | string
    content?: StringFilter<"MdxNote"> | string
    formatted?: StringNullableFilter<"MdxNote"> | string | null
    summary?: StringNullableFilter<"MdxNote"> | string | null
    citationsListOrder?: StringNullableListFilter<"MdxNote">
    importantValues?: FloatNullableListFilter<"MdxNote">
    imageSrc?: StringNullableFilter<"MdxNote"> | string | null
    href?: StringFilter<"MdxNote"> | string
    sequentialKey?: StringNullableFilter<"MdxNote"> | string | null
    sequentialIndex?: FloatNullableFilter<"MdxNote"> | number | null
    floatImages?: BoolFilter<"MdxNote"> | boolean
    remoteUrl?: StringNullableFilter<"MdxNote"> | string | null
    trackRemote?: BoolFilter<"MdxNote"> | boolean
    outgoingQuickLinks?: StringNullableListFilter<"MdxNote">
    quickLink?: StringNullableFilter<"MdxNote"> | string | null
    bookmarked?: BoolFilter<"MdxNote"> | boolean
    firstSync?: DateTimeFilter<"MdxNote"> | Date | string
    lastSync?: DateTimeFilter<"MdxNote"> | Date | string
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    tags?: TagListRelationFilter
    citations?: BibEntryListRelationFilter
    sequentialList?: XOR<SequentialNoteListNullableRelationFilter, SequentialNoteListWhereInput> | null
    ReadingList?: ReadingListListRelationFilter
    equations?: EquationListRelationFilter
    definitions?: DefinitionListRelationFilter
    toDo?: ToDoListRelationFilter
  }

  export type MdxNoteOrderByWithRelationInput = {
    id?: SortOrder
    isProtected?: SortOrderInput | SortOrder
    dietSummaryKey?: SortOrderInput | SortOrder
    title?: SortOrder
    latexTitle?: SortOrderInput | SortOrder
    rootRelativePath?: SortOrder
    noteType?: SortOrder
    content?: SortOrder
    formatted?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    citationsListOrder?: SortOrder
    importantValues?: SortOrder
    imageSrc?: SortOrderInput | SortOrder
    href?: SortOrder
    sequentialKey?: SortOrderInput | SortOrder
    sequentialIndex?: SortOrderInput | SortOrder
    floatImages?: SortOrder
    remoteUrl?: SortOrderInput | SortOrder
    trackRemote?: SortOrder
    outgoingQuickLinks?: SortOrder
    quickLink?: SortOrderInput | SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
    topics?: TopicOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    citations?: BibEntryOrderByRelationAggregateInput
    sequentialList?: SequentialNoteListOrderByWithRelationInput
    ReadingList?: ReadingListOrderByRelationAggregateInput
    equations?: EquationOrderByRelationAggregateInput
    definitions?: DefinitionOrderByRelationAggregateInput
    toDo?: ToDoOrderByRelationAggregateInput
    _relevance?: MdxNoteOrderByRelevanceInput
  }

  export type MdxNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rootRelativePath?: string
    quickLink?: string
    AND?: MdxNoteWhereInput | MdxNoteWhereInput[]
    OR?: MdxNoteWhereInput[]
    NOT?: MdxNoteWhereInput | MdxNoteWhereInput[]
    isProtected?: BoolNullableFilter<"MdxNote"> | boolean | null
    dietSummaryKey?: StringNullableFilter<"MdxNote"> | string | null
    title?: StringFilter<"MdxNote"> | string
    latexTitle?: StringNullableFilter<"MdxNote"> | string | null
    noteType?: StringFilter<"MdxNote"> | string
    content?: StringFilter<"MdxNote"> | string
    formatted?: StringNullableFilter<"MdxNote"> | string | null
    summary?: StringNullableFilter<"MdxNote"> | string | null
    citationsListOrder?: StringNullableListFilter<"MdxNote">
    importantValues?: FloatNullableListFilter<"MdxNote">
    imageSrc?: StringNullableFilter<"MdxNote"> | string | null
    href?: StringFilter<"MdxNote"> | string
    sequentialKey?: StringNullableFilter<"MdxNote"> | string | null
    sequentialIndex?: FloatNullableFilter<"MdxNote"> | number | null
    floatImages?: BoolFilter<"MdxNote"> | boolean
    remoteUrl?: StringNullableFilter<"MdxNote"> | string | null
    trackRemote?: BoolFilter<"MdxNote"> | boolean
    outgoingQuickLinks?: StringNullableListFilter<"MdxNote">
    bookmarked?: BoolFilter<"MdxNote"> | boolean
    firstSync?: DateTimeFilter<"MdxNote"> | Date | string
    lastSync?: DateTimeFilter<"MdxNote"> | Date | string
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    tags?: TagListRelationFilter
    citations?: BibEntryListRelationFilter
    sequentialList?: XOR<SequentialNoteListNullableRelationFilter, SequentialNoteListWhereInput> | null
    ReadingList?: ReadingListListRelationFilter
    equations?: EquationListRelationFilter
    definitions?: DefinitionListRelationFilter
    toDo?: ToDoListRelationFilter
  }, "id" | "rootRelativePath" | "quickLink">

  export type MdxNoteOrderByWithAggregationInput = {
    id?: SortOrder
    isProtected?: SortOrderInput | SortOrder
    dietSummaryKey?: SortOrderInput | SortOrder
    title?: SortOrder
    latexTitle?: SortOrderInput | SortOrder
    rootRelativePath?: SortOrder
    noteType?: SortOrder
    content?: SortOrder
    formatted?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    citationsListOrder?: SortOrder
    importantValues?: SortOrder
    imageSrc?: SortOrderInput | SortOrder
    href?: SortOrder
    sequentialKey?: SortOrderInput | SortOrder
    sequentialIndex?: SortOrderInput | SortOrder
    floatImages?: SortOrder
    remoteUrl?: SortOrderInput | SortOrder
    trackRemote?: SortOrder
    outgoingQuickLinks?: SortOrder
    quickLink?: SortOrderInput | SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
    _count?: MdxNoteCountOrderByAggregateInput
    _avg?: MdxNoteAvgOrderByAggregateInput
    _max?: MdxNoteMaxOrderByAggregateInput
    _min?: MdxNoteMinOrderByAggregateInput
    _sum?: MdxNoteSumOrderByAggregateInput
  }

  export type MdxNoteScalarWhereWithAggregatesInput = {
    AND?: MdxNoteScalarWhereWithAggregatesInput | MdxNoteScalarWhereWithAggregatesInput[]
    OR?: MdxNoteScalarWhereWithAggregatesInput[]
    NOT?: MdxNoteScalarWhereWithAggregatesInput | MdxNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MdxNote"> | number
    isProtected?: BoolNullableWithAggregatesFilter<"MdxNote"> | boolean | null
    dietSummaryKey?: StringNullableWithAggregatesFilter<"MdxNote"> | string | null
    title?: StringWithAggregatesFilter<"MdxNote"> | string
    latexTitle?: StringNullableWithAggregatesFilter<"MdxNote"> | string | null
    rootRelativePath?: StringWithAggregatesFilter<"MdxNote"> | string
    noteType?: StringWithAggregatesFilter<"MdxNote"> | string
    content?: StringWithAggregatesFilter<"MdxNote"> | string
    formatted?: StringNullableWithAggregatesFilter<"MdxNote"> | string | null
    summary?: StringNullableWithAggregatesFilter<"MdxNote"> | string | null
    citationsListOrder?: StringNullableListFilter<"MdxNote">
    importantValues?: FloatNullableListFilter<"MdxNote">
    imageSrc?: StringNullableWithAggregatesFilter<"MdxNote"> | string | null
    href?: StringWithAggregatesFilter<"MdxNote"> | string
    sequentialKey?: StringNullableWithAggregatesFilter<"MdxNote"> | string | null
    sequentialIndex?: FloatNullableWithAggregatesFilter<"MdxNote"> | number | null
    floatImages?: BoolWithAggregatesFilter<"MdxNote"> | boolean
    remoteUrl?: StringNullableWithAggregatesFilter<"MdxNote"> | string | null
    trackRemote?: BoolWithAggregatesFilter<"MdxNote"> | boolean
    outgoingQuickLinks?: StringNullableListFilter<"MdxNote">
    quickLink?: StringNullableWithAggregatesFilter<"MdxNote"> | string | null
    bookmarked?: BoolWithAggregatesFilter<"MdxNote"> | boolean
    firstSync?: DateTimeWithAggregatesFilter<"MdxNote"> | Date | string
    lastSync?: DateTimeWithAggregatesFilter<"MdxNote"> | Date | string
  }

  export type IpynbWhereInput = {
    AND?: IpynbWhereInput | IpynbWhereInput[]
    OR?: IpynbWhereInput[]
    NOT?: IpynbWhereInput | IpynbWhereInput[]
    id?: IntFilter<"Ipynb"> | number
    rootRelativePath?: StringFilter<"Ipynb"> | string
    isProtected?: BoolNullableFilter<"Ipynb"> | boolean | null
    title?: StringFilter<"Ipynb"> | string
    latexTitle?: StringNullableFilter<"Ipynb"> | string | null
    citationsListOrder?: StringNullableListFilter<"Ipynb">
    importantValues?: FloatNullableListFilter<"Ipynb">
    href?: StringFilter<"Ipynb"> | string
    outgoingQuickLinks?: StringNullableListFilter<"Ipynb">
    raw?: BytesFilter<"Ipynb"> | Buffer
    sequentialKey?: StringNullableFilter<"Ipynb"> | string | null
    sequentialIndex?: IntNullableFilter<"Ipynb"> | number | null
    bookmarked?: BoolFilter<"Ipynb"> | boolean
    firstSync?: DateTimeFilter<"Ipynb"> | Date | string
    lastSync?: DateTimeFilter<"Ipynb"> | Date | string
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    citations?: BibEntryListRelationFilter
    sequentialList?: XOR<SequentialNoteListNullableRelationFilter, SequentialNoteListWhereInput> | null
    readingList?: ReadingListListRelationFilter
  }

  export type IpynbOrderByWithRelationInput = {
    id?: SortOrder
    rootRelativePath?: SortOrder
    isProtected?: SortOrderInput | SortOrder
    title?: SortOrder
    latexTitle?: SortOrderInput | SortOrder
    citationsListOrder?: SortOrder
    importantValues?: SortOrder
    href?: SortOrder
    outgoingQuickLinks?: SortOrder
    raw?: SortOrder
    sequentialKey?: SortOrderInput | SortOrder
    sequentialIndex?: SortOrderInput | SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
    tags?: TagOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    citations?: BibEntryOrderByRelationAggregateInput
    sequentialList?: SequentialNoteListOrderByWithRelationInput
    readingList?: ReadingListOrderByRelationAggregateInput
    _relevance?: IpynbOrderByRelevanceInput
  }

  export type IpynbWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rootRelativePath?: string
    AND?: IpynbWhereInput | IpynbWhereInput[]
    OR?: IpynbWhereInput[]
    NOT?: IpynbWhereInput | IpynbWhereInput[]
    isProtected?: BoolNullableFilter<"Ipynb"> | boolean | null
    title?: StringFilter<"Ipynb"> | string
    latexTitle?: StringNullableFilter<"Ipynb"> | string | null
    citationsListOrder?: StringNullableListFilter<"Ipynb">
    importantValues?: FloatNullableListFilter<"Ipynb">
    href?: StringFilter<"Ipynb"> | string
    outgoingQuickLinks?: StringNullableListFilter<"Ipynb">
    raw?: BytesFilter<"Ipynb"> | Buffer
    sequentialKey?: StringNullableFilter<"Ipynb"> | string | null
    sequentialIndex?: IntNullableFilter<"Ipynb"> | number | null
    bookmarked?: BoolFilter<"Ipynb"> | boolean
    firstSync?: DateTimeFilter<"Ipynb"> | Date | string
    lastSync?: DateTimeFilter<"Ipynb"> | Date | string
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    citations?: BibEntryListRelationFilter
    sequentialList?: XOR<SequentialNoteListNullableRelationFilter, SequentialNoteListWhereInput> | null
    readingList?: ReadingListListRelationFilter
  }, "id" | "rootRelativePath">

  export type IpynbOrderByWithAggregationInput = {
    id?: SortOrder
    rootRelativePath?: SortOrder
    isProtected?: SortOrderInput | SortOrder
    title?: SortOrder
    latexTitle?: SortOrderInput | SortOrder
    citationsListOrder?: SortOrder
    importantValues?: SortOrder
    href?: SortOrder
    outgoingQuickLinks?: SortOrder
    raw?: SortOrder
    sequentialKey?: SortOrderInput | SortOrder
    sequentialIndex?: SortOrderInput | SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
    _count?: IpynbCountOrderByAggregateInput
    _avg?: IpynbAvgOrderByAggregateInput
    _max?: IpynbMaxOrderByAggregateInput
    _min?: IpynbMinOrderByAggregateInput
    _sum?: IpynbSumOrderByAggregateInput
  }

  export type IpynbScalarWhereWithAggregatesInput = {
    AND?: IpynbScalarWhereWithAggregatesInput | IpynbScalarWhereWithAggregatesInput[]
    OR?: IpynbScalarWhereWithAggregatesInput[]
    NOT?: IpynbScalarWhereWithAggregatesInput | IpynbScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ipynb"> | number
    rootRelativePath?: StringWithAggregatesFilter<"Ipynb"> | string
    isProtected?: BoolNullableWithAggregatesFilter<"Ipynb"> | boolean | null
    title?: StringWithAggregatesFilter<"Ipynb"> | string
    latexTitle?: StringNullableWithAggregatesFilter<"Ipynb"> | string | null
    citationsListOrder?: StringNullableListFilter<"Ipynb">
    importantValues?: FloatNullableListFilter<"Ipynb">
    href?: StringWithAggregatesFilter<"Ipynb"> | string
    outgoingQuickLinks?: StringNullableListFilter<"Ipynb">
    raw?: BytesWithAggregatesFilter<"Ipynb"> | Buffer
    sequentialKey?: StringNullableWithAggregatesFilter<"Ipynb"> | string | null
    sequentialIndex?: IntNullableWithAggregatesFilter<"Ipynb"> | number | null
    bookmarked?: BoolWithAggregatesFilter<"Ipynb"> | boolean
    firstSync?: DateTimeWithAggregatesFilter<"Ipynb"> | Date | string
    lastSync?: DateTimeWithAggregatesFilter<"Ipynb"> | Date | string
  }

  export type ToDoListWhereInput = {
    AND?: ToDoListWhereInput | ToDoListWhereInput[]
    OR?: ToDoListWhereInput[]
    NOT?: ToDoListWhereInput | ToDoListWhereInput[]
    id?: IntFilter<"ToDoList"> | number
    label?: StringFilter<"ToDoList"> | string
    createdAt?: DateTimeFilter<"ToDoList"> | Date | string
    lastUpdate?: DateTimeFilter<"ToDoList"> | Date | string
    tasks?: ToDoListRelationFilter
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
  }

  export type ToDoListOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
    tasks?: ToDoOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    _relevance?: ToDoListOrderByRelevanceInput
  }

  export type ToDoListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ToDoListWhereInput | ToDoListWhereInput[]
    OR?: ToDoListWhereInput[]
    NOT?: ToDoListWhereInput | ToDoListWhereInput[]
    label?: StringFilter<"ToDoList"> | string
    createdAt?: DateTimeFilter<"ToDoList"> | Date | string
    lastUpdate?: DateTimeFilter<"ToDoList"> | Date | string
    tasks?: ToDoListRelationFilter
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
  }, "id">

  export type ToDoListOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
    _count?: ToDoListCountOrderByAggregateInput
    _avg?: ToDoListAvgOrderByAggregateInput
    _max?: ToDoListMaxOrderByAggregateInput
    _min?: ToDoListMinOrderByAggregateInput
    _sum?: ToDoListSumOrderByAggregateInput
  }

  export type ToDoListScalarWhereWithAggregatesInput = {
    AND?: ToDoListScalarWhereWithAggregatesInput | ToDoListScalarWhereWithAggregatesInput[]
    OR?: ToDoListScalarWhereWithAggregatesInput[]
    NOT?: ToDoListScalarWhereWithAggregatesInput | ToDoListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ToDoList"> | number
    label?: StringWithAggregatesFilter<"ToDoList"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ToDoList"> | Date | string
    lastUpdate?: DateTimeWithAggregatesFilter<"ToDoList"> | Date | string
  }

  export type ToDoWhereInput = {
    AND?: ToDoWhereInput | ToDoWhereInput[]
    OR?: ToDoWhereInput[]
    NOT?: ToDoWhereInput | ToDoWhereInput[]
    id?: IntFilter<"ToDo"> | number
    createdAt?: DateTimeFilter<"ToDo"> | Date | string
    task?: StringFilter<"ToDo"> | string
    dueAt?: DateTimeNullableFilter<"ToDo"> | Date | string | null
    details?: StringNullableFilter<"ToDo"> | string | null
    parentId?: IntNullableFilter<"ToDo"> | number | null
    category?: EnumTaskCategoryNullableFilter<"ToDo"> | $Enums.TaskCategory | null
    bookmarked?: BoolFilter<"ToDo"> | boolean
    status?: EnumToDoListStatusFilter<"ToDo"> | $Enums.ToDoListStatus
    priority?: IntFilter<"ToDo"> | number
    toDoListId?: IntNullableFilter<"ToDo"> | number | null
    associatedNotes?: MdxNoteListRelationFilter
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    parent?: XOR<ToDoNullableRelationFilter, ToDoWhereInput> | null
    child?: ToDoListRelationFilter
    ToDoList?: XOR<ToDoListNullableRelationFilter, ToDoListWhereInput> | null
  }

  export type ToDoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    task?: SortOrder
    dueAt?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    bookmarked?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    toDoListId?: SortOrderInput | SortOrder
    associatedNotes?: MdxNoteOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    parent?: ToDoOrderByWithRelationInput
    child?: ToDoOrderByRelationAggregateInput
    ToDoList?: ToDoListOrderByWithRelationInput
    _relevance?: ToDoOrderByRelevanceInput
  }

  export type ToDoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ToDoWhereInput | ToDoWhereInput[]
    OR?: ToDoWhereInput[]
    NOT?: ToDoWhereInput | ToDoWhereInput[]
    createdAt?: DateTimeFilter<"ToDo"> | Date | string
    task?: StringFilter<"ToDo"> | string
    dueAt?: DateTimeNullableFilter<"ToDo"> | Date | string | null
    details?: StringNullableFilter<"ToDo"> | string | null
    parentId?: IntNullableFilter<"ToDo"> | number | null
    category?: EnumTaskCategoryNullableFilter<"ToDo"> | $Enums.TaskCategory | null
    bookmarked?: BoolFilter<"ToDo"> | boolean
    status?: EnumToDoListStatusFilter<"ToDo"> | $Enums.ToDoListStatus
    priority?: IntFilter<"ToDo"> | number
    toDoListId?: IntNullableFilter<"ToDo"> | number | null
    associatedNotes?: MdxNoteListRelationFilter
    tags?: TagListRelationFilter
    topics?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
    parent?: XOR<ToDoNullableRelationFilter, ToDoWhereInput> | null
    child?: ToDoListRelationFilter
    ToDoList?: XOR<ToDoListNullableRelationFilter, ToDoListWhereInput> | null
  }, "id" | "id">

  export type ToDoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    task?: SortOrder
    dueAt?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    bookmarked?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    toDoListId?: SortOrderInput | SortOrder
    _count?: ToDoCountOrderByAggregateInput
    _avg?: ToDoAvgOrderByAggregateInput
    _max?: ToDoMaxOrderByAggregateInput
    _min?: ToDoMinOrderByAggregateInput
    _sum?: ToDoSumOrderByAggregateInput
  }

  export type ToDoScalarWhereWithAggregatesInput = {
    AND?: ToDoScalarWhereWithAggregatesInput | ToDoScalarWhereWithAggregatesInput[]
    OR?: ToDoScalarWhereWithAggregatesInput[]
    NOT?: ToDoScalarWhereWithAggregatesInput | ToDoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ToDo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ToDo"> | Date | string
    task?: StringWithAggregatesFilter<"ToDo"> | string
    dueAt?: DateTimeNullableWithAggregatesFilter<"ToDo"> | Date | string | null
    details?: StringNullableWithAggregatesFilter<"ToDo"> | string | null
    parentId?: IntNullableWithAggregatesFilter<"ToDo"> | number | null
    category?: EnumTaskCategoryNullableWithAggregatesFilter<"ToDo"> | $Enums.TaskCategory | null
    bookmarked?: BoolWithAggregatesFilter<"ToDo"> | boolean
    status?: EnumToDoListStatusWithAggregatesFilter<"ToDo"> | $Enums.ToDoListStatus
    priority?: IntWithAggregatesFilter<"ToDo"> | number
    toDoListId?: IntNullableWithAggregatesFilter<"ToDo"> | number | null
  }

  export type KanBanCardWhereInput = {
    AND?: KanBanCardWhereInput | KanBanCardWhereInput[]
    OR?: KanBanCardWhereInput[]
    NOT?: KanBanCardWhereInput | KanBanCardWhereInput[]
    id?: IntFilter<"KanBanCard"> | number
    listId?: IntNullableFilter<"KanBanCard"> | number | null
    indexWithinList?: IntFilter<"KanBanCard"> | number
    label?: StringNullableFilter<"KanBanCard"> | string | null
    details?: StringNullableFilter<"KanBanCard"> | string | null
    KanBanList?: XOR<KanBanListNullableRelationFilter, KanBanListWhereInput> | null
  }

  export type KanBanCardOrderByWithRelationInput = {
    id?: SortOrder
    listId?: SortOrderInput | SortOrder
    indexWithinList?: SortOrder
    label?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    KanBanList?: KanBanListOrderByWithRelationInput
    _relevance?: KanBanCardOrderByRelevanceInput
  }

  export type KanBanCardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KanBanCardWhereInput | KanBanCardWhereInput[]
    OR?: KanBanCardWhereInput[]
    NOT?: KanBanCardWhereInput | KanBanCardWhereInput[]
    listId?: IntNullableFilter<"KanBanCard"> | number | null
    indexWithinList?: IntFilter<"KanBanCard"> | number
    label?: StringNullableFilter<"KanBanCard"> | string | null
    details?: StringNullableFilter<"KanBanCard"> | string | null
    KanBanList?: XOR<KanBanListNullableRelationFilter, KanBanListWhereInput> | null
  }, "id">

  export type KanBanCardOrderByWithAggregationInput = {
    id?: SortOrder
    listId?: SortOrderInput | SortOrder
    indexWithinList?: SortOrder
    label?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    _count?: KanBanCardCountOrderByAggregateInput
    _avg?: KanBanCardAvgOrderByAggregateInput
    _max?: KanBanCardMaxOrderByAggregateInput
    _min?: KanBanCardMinOrderByAggregateInput
    _sum?: KanBanCardSumOrderByAggregateInput
  }

  export type KanBanCardScalarWhereWithAggregatesInput = {
    AND?: KanBanCardScalarWhereWithAggregatesInput | KanBanCardScalarWhereWithAggregatesInput[]
    OR?: KanBanCardScalarWhereWithAggregatesInput[]
    NOT?: KanBanCardScalarWhereWithAggregatesInput | KanBanCardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KanBanCard"> | number
    listId?: IntNullableWithAggregatesFilter<"KanBanCard"> | number | null
    indexWithinList?: IntWithAggregatesFilter<"KanBanCard"> | number
    label?: StringNullableWithAggregatesFilter<"KanBanCard"> | string | null
    details?: StringNullableWithAggregatesFilter<"KanBanCard"> | string | null
  }

  export type KanBanListWhereInput = {
    AND?: KanBanListWhereInput | KanBanListWhereInput[]
    OR?: KanBanListWhereInput[]
    NOT?: KanBanListWhereInput | KanBanListWhereInput[]
    id?: IntFilter<"KanBanList"> | number
    indexWithinBoard?: IntFilter<"KanBanList"> | number
    title?: StringNullableFilter<"KanBanList"> | string | null
    boardId?: IntNullableFilter<"KanBanList"> | number | null
    cards?: KanBanCardListRelationFilter
    Kanban?: XOR<KanbanNullableRelationFilter, KanbanWhereInput> | null
  }

  export type KanBanListOrderByWithRelationInput = {
    id?: SortOrder
    indexWithinBoard?: SortOrder
    title?: SortOrderInput | SortOrder
    boardId?: SortOrderInput | SortOrder
    cards?: KanBanCardOrderByRelationAggregateInput
    Kanban?: KanbanOrderByWithRelationInput
    _relevance?: KanBanListOrderByRelevanceInput
  }

  export type KanBanListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KanBanListWhereInput | KanBanListWhereInput[]
    OR?: KanBanListWhereInput[]
    NOT?: KanBanListWhereInput | KanBanListWhereInput[]
    indexWithinBoard?: IntFilter<"KanBanList"> | number
    title?: StringNullableFilter<"KanBanList"> | string | null
    boardId?: IntNullableFilter<"KanBanList"> | number | null
    cards?: KanBanCardListRelationFilter
    Kanban?: XOR<KanbanNullableRelationFilter, KanbanWhereInput> | null
  }, "id">

  export type KanBanListOrderByWithAggregationInput = {
    id?: SortOrder
    indexWithinBoard?: SortOrder
    title?: SortOrderInput | SortOrder
    boardId?: SortOrderInput | SortOrder
    _count?: KanBanListCountOrderByAggregateInput
    _avg?: KanBanListAvgOrderByAggregateInput
    _max?: KanBanListMaxOrderByAggregateInput
    _min?: KanBanListMinOrderByAggregateInput
    _sum?: KanBanListSumOrderByAggregateInput
  }

  export type KanBanListScalarWhereWithAggregatesInput = {
    AND?: KanBanListScalarWhereWithAggregatesInput | KanBanListScalarWhereWithAggregatesInput[]
    OR?: KanBanListScalarWhereWithAggregatesInput[]
    NOT?: KanBanListScalarWhereWithAggregatesInput | KanBanListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KanBanList"> | number
    indexWithinBoard?: IntWithAggregatesFilter<"KanBanList"> | number
    title?: StringNullableWithAggregatesFilter<"KanBanList"> | string | null
    boardId?: IntNullableWithAggregatesFilter<"KanBanList"> | number | null
  }

  export type KanbanWhereInput = {
    AND?: KanbanWhereInput | KanbanWhereInput[]
    OR?: KanbanWhereInput[]
    NOT?: KanbanWhereInput | KanbanWhereInput[]
    id?: IntFilter<"Kanban"> | number
    title?: StringFilter<"Kanban"> | string
    createdAt?: DateTimeFilter<"Kanban"> | Date | string
    lastUpdate?: DateTimeFilter<"Kanban"> | Date | string
    lists?: KanBanListListRelationFilter
    tags?: TagListRelationFilter
    subjects?: SubjectListRelationFilter
    topics?: TopicListRelationFilter
  }

  export type KanbanOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
    lists?: KanBanListOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
    _relevance?: KanbanOrderByRelevanceInput
  }

  export type KanbanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KanbanWhereInput | KanbanWhereInput[]
    OR?: KanbanWhereInput[]
    NOT?: KanbanWhereInput | KanbanWhereInput[]
    title?: StringFilter<"Kanban"> | string
    createdAt?: DateTimeFilter<"Kanban"> | Date | string
    lastUpdate?: DateTimeFilter<"Kanban"> | Date | string
    lists?: KanBanListListRelationFilter
    tags?: TagListRelationFilter
    subjects?: SubjectListRelationFilter
    topics?: TopicListRelationFilter
  }, "id">

  export type KanbanOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
    _count?: KanbanCountOrderByAggregateInput
    _avg?: KanbanAvgOrderByAggregateInput
    _max?: KanbanMaxOrderByAggregateInput
    _min?: KanbanMinOrderByAggregateInput
    _sum?: KanbanSumOrderByAggregateInput
  }

  export type KanbanScalarWhereWithAggregatesInput = {
    AND?: KanbanScalarWhereWithAggregatesInput | KanbanScalarWhereWithAggregatesInput[]
    OR?: KanbanScalarWhereWithAggregatesInput[]
    NOT?: KanbanScalarWhereWithAggregatesInput | KanbanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Kanban"> | number
    title?: StringWithAggregatesFilter<"Kanban"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Kanban"> | Date | string
    lastUpdate?: DateTimeWithAggregatesFilter<"Kanban"> | Date | string
  }

  export type TimePeriodWhereInput = {
    AND?: TimePeriodWhereInput | TimePeriodWhereInput[]
    OR?: TimePeriodWhereInput[]
    NOT?: TimePeriodWhereInput | TimePeriodWhereInput[]
    id?: IntFilter<"TimePeriod"> | number
    start?: DateTimeFilter<"TimePeriod"> | Date | string
    end?: DateTimeNullableFilter<"TimePeriod"> | Date | string | null
    dietId?: StringNullableFilter<"TimePeriod"> | string | null
    Diet?: XOR<DietNullableRelationFilter, DietWhereInput> | null
  }

  export type TimePeriodOrderByWithRelationInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    dietId?: SortOrderInput | SortOrder
    Diet?: DietOrderByWithRelationInput
    _relevance?: TimePeriodOrderByRelevanceInput
  }

  export type TimePeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TimePeriodWhereInput | TimePeriodWhereInput[]
    OR?: TimePeriodWhereInput[]
    NOT?: TimePeriodWhereInput | TimePeriodWhereInput[]
    start?: DateTimeFilter<"TimePeriod"> | Date | string
    end?: DateTimeNullableFilter<"TimePeriod"> | Date | string | null
    dietId?: StringNullableFilter<"TimePeriod"> | string | null
    Diet?: XOR<DietNullableRelationFilter, DietWhereInput> | null
  }, "id">

  export type TimePeriodOrderByWithAggregationInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    dietId?: SortOrderInput | SortOrder
    _count?: TimePeriodCountOrderByAggregateInput
    _avg?: TimePeriodAvgOrderByAggregateInput
    _max?: TimePeriodMaxOrderByAggregateInput
    _min?: TimePeriodMinOrderByAggregateInput
    _sum?: TimePeriodSumOrderByAggregateInput
  }

  export type TimePeriodScalarWhereWithAggregatesInput = {
    AND?: TimePeriodScalarWhereWithAggregatesInput | TimePeriodScalarWhereWithAggregatesInput[]
    OR?: TimePeriodScalarWhereWithAggregatesInput[]
    NOT?: TimePeriodScalarWhereWithAggregatesInput | TimePeriodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TimePeriod"> | number
    start?: DateTimeWithAggregatesFilter<"TimePeriod"> | Date | string
    end?: DateTimeNullableWithAggregatesFilter<"TimePeriod"> | Date | string | null
    dietId?: StringNullableWithAggregatesFilter<"TimePeriod"> | string | null
  }

  export type DietWhereInput = {
    AND?: DietWhereInput | DietWhereInput[]
    OR?: DietWhereInput[]
    NOT?: DietWhereInput | DietWhereInput[]
    name?: StringFilter<"Diet"> | string
    summary?: StringNullableFilter<"Diet"> | string | null
    activelyFollowing?: BoolFilter<"Diet"> | boolean
    gf?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFilter<"Diet"> | boolean
    pescatarian?: BoolFilter<"Diet"> | boolean
    vegetarian?: BoolFilter<"Diet"> | boolean
    fasting?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    carb?: FloatNullableFilter<"Diet"> | number | null
    pro?: FloatNullableFilter<"Diet"> | number | null
    fat?: FloatNullableFilter<"Diet"> | number | null
    goals?: EnumDIETARY_GOALNullableListFilter<"Diet">
    created?: DateTimeFilter<"Diet"> | Date | string
    lastUpdate?: DateTimeFilter<"Diet"> | Date | string
    items?: DietaryItemListRelationFilter
    periodsFollowed?: TimePeriodListRelationFilter
    HealthReport?: HealthReportListRelationFilter
  }

  export type DietOrderByWithRelationInput = {
    name?: SortOrder
    summary?: SortOrderInput | SortOrder
    activelyFollowing?: SortOrder
    gf?: SortOrder
    vegan?: SortOrder
    pescatarian?: SortOrder
    vegetarian?: SortOrder
    fasting?: SortOrder
    cardioTraining?: SortOrder
    weightTraining?: SortOrder
    carb?: SortOrderInput | SortOrder
    pro?: SortOrderInput | SortOrder
    fat?: SortOrderInput | SortOrder
    goals?: SortOrder
    created?: SortOrder
    lastUpdate?: SortOrder
    items?: DietaryItemOrderByRelationAggregateInput
    periodsFollowed?: TimePeriodOrderByRelationAggregateInput
    HealthReport?: HealthReportOrderByRelationAggregateInput
    _relevance?: DietOrderByRelevanceInput
  }

  export type DietWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: DietWhereInput | DietWhereInput[]
    OR?: DietWhereInput[]
    NOT?: DietWhereInput | DietWhereInput[]
    summary?: StringNullableFilter<"Diet"> | string | null
    activelyFollowing?: BoolFilter<"Diet"> | boolean
    gf?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFilter<"Diet"> | boolean
    pescatarian?: BoolFilter<"Diet"> | boolean
    vegetarian?: BoolFilter<"Diet"> | boolean
    fasting?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    carb?: FloatNullableFilter<"Diet"> | number | null
    pro?: FloatNullableFilter<"Diet"> | number | null
    fat?: FloatNullableFilter<"Diet"> | number | null
    goals?: EnumDIETARY_GOALNullableListFilter<"Diet">
    created?: DateTimeFilter<"Diet"> | Date | string
    lastUpdate?: DateTimeFilter<"Diet"> | Date | string
    items?: DietaryItemListRelationFilter
    periodsFollowed?: TimePeriodListRelationFilter
    HealthReport?: HealthReportListRelationFilter
  }, "name" | "name">

  export type DietOrderByWithAggregationInput = {
    name?: SortOrder
    summary?: SortOrderInput | SortOrder
    activelyFollowing?: SortOrder
    gf?: SortOrder
    vegan?: SortOrder
    pescatarian?: SortOrder
    vegetarian?: SortOrder
    fasting?: SortOrder
    cardioTraining?: SortOrder
    weightTraining?: SortOrder
    carb?: SortOrderInput | SortOrder
    pro?: SortOrderInput | SortOrder
    fat?: SortOrderInput | SortOrder
    goals?: SortOrder
    created?: SortOrder
    lastUpdate?: SortOrder
    _count?: DietCountOrderByAggregateInput
    _avg?: DietAvgOrderByAggregateInput
    _max?: DietMaxOrderByAggregateInput
    _min?: DietMinOrderByAggregateInput
    _sum?: DietSumOrderByAggregateInput
  }

  export type DietScalarWhereWithAggregatesInput = {
    AND?: DietScalarWhereWithAggregatesInput | DietScalarWhereWithAggregatesInput[]
    OR?: DietScalarWhereWithAggregatesInput[]
    NOT?: DietScalarWhereWithAggregatesInput | DietScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Diet"> | string
    summary?: StringNullableWithAggregatesFilter<"Diet"> | string | null
    activelyFollowing?: BoolWithAggregatesFilter<"Diet"> | boolean
    gf?: EnumTERTIARY_TOGGLEWithAggregatesFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    vegan?: BoolWithAggregatesFilter<"Diet"> | boolean
    pescatarian?: BoolWithAggregatesFilter<"Diet"> | boolean
    vegetarian?: BoolWithAggregatesFilter<"Diet"> | boolean
    fasting?: EnumTERTIARY_TOGGLEWithAggregatesFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEWithAggregatesFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEWithAggregatesFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    carb?: FloatNullableWithAggregatesFilter<"Diet"> | number | null
    pro?: FloatNullableWithAggregatesFilter<"Diet"> | number | null
    fat?: FloatNullableWithAggregatesFilter<"Diet"> | number | null
    goals?: EnumDIETARY_GOALNullableListFilter<"Diet">
    created?: DateTimeWithAggregatesFilter<"Diet"> | Date | string
    lastUpdate?: DateTimeWithAggregatesFilter<"Diet"> | Date | string
  }

  export type ServingWhereInput = {
    AND?: ServingWhereInput | ServingWhereInput[]
    OR?: ServingWhereInput[]
    NOT?: ServingWhereInput | ServingWhereInput[]
    id?: IntFilter<"Serving"> | number
    dietaryItemId?: IntFilter<"Serving"> | number
    quant_oz?: FloatNullableFilter<"Serving"> | number | null
    quant_guess?: EnumQUANTITY_GUESSNullableFilter<"Serving"> | $Enums.QUANTITY_GUESS | null
    item?: XOR<DietaryItemRelationFilter, DietaryItemWhereInput>
  }

  export type ServingOrderByWithRelationInput = {
    id?: SortOrder
    dietaryItemId?: SortOrder
    quant_oz?: SortOrderInput | SortOrder
    quant_guess?: SortOrderInput | SortOrder
    item?: DietaryItemOrderByWithRelationInput
  }

  export type ServingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServingWhereInput | ServingWhereInput[]
    OR?: ServingWhereInput[]
    NOT?: ServingWhereInput | ServingWhereInput[]
    dietaryItemId?: IntFilter<"Serving"> | number
    quant_oz?: FloatNullableFilter<"Serving"> | number | null
    quant_guess?: EnumQUANTITY_GUESSNullableFilter<"Serving"> | $Enums.QUANTITY_GUESS | null
    item?: XOR<DietaryItemRelationFilter, DietaryItemWhereInput>
  }, "id">

  export type ServingOrderByWithAggregationInput = {
    id?: SortOrder
    dietaryItemId?: SortOrder
    quant_oz?: SortOrderInput | SortOrder
    quant_guess?: SortOrderInput | SortOrder
    _count?: ServingCountOrderByAggregateInput
    _avg?: ServingAvgOrderByAggregateInput
    _max?: ServingMaxOrderByAggregateInput
    _min?: ServingMinOrderByAggregateInput
    _sum?: ServingSumOrderByAggregateInput
  }

  export type ServingScalarWhereWithAggregatesInput = {
    AND?: ServingScalarWhereWithAggregatesInput | ServingScalarWhereWithAggregatesInput[]
    OR?: ServingScalarWhereWithAggregatesInput[]
    NOT?: ServingScalarWhereWithAggregatesInput | ServingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Serving"> | number
    dietaryItemId?: IntWithAggregatesFilter<"Serving"> | number
    quant_oz?: FloatNullableWithAggregatesFilter<"Serving"> | number | null
    quant_guess?: EnumQUANTITY_GUESSNullableWithAggregatesFilter<"Serving"> | $Enums.QUANTITY_GUESS | null
  }

  export type DietaryItemWhereInput = {
    AND?: DietaryItemWhereInput | DietaryItemWhereInput[]
    OR?: DietaryItemWhereInput[]
    NOT?: DietaryItemWhereInput | DietaryItemWhereInput[]
    id?: IntFilter<"DietaryItem"> | number
    name?: StringFilter<"DietaryItem"> | string
    barcode?: StringNullableFilter<"DietaryItem"> | string | null
    gi?: IntNullableFilter<"DietaryItem"> | number | null
    calsPerOz?: FloatNullableFilter<"DietaryItem"> | number | null
    glutenFree?: BoolFilter<"DietaryItem"> | boolean
    minimalFructose?: BoolFilter<"DietaryItem"> | boolean
    natural?: BoolFilter<"DietaryItem"> | boolean
    organic?: BoolFilter<"DietaryItem"> | boolean
    impactScore?: FloatFilter<"DietaryItem"> | number
    Diet?: DietListRelationFilter
    Serving?: ServingListRelationFilter
  }

  export type DietaryItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrderInput | SortOrder
    gi?: SortOrderInput | SortOrder
    calsPerOz?: SortOrderInput | SortOrder
    glutenFree?: SortOrder
    minimalFructose?: SortOrder
    natural?: SortOrder
    organic?: SortOrder
    impactScore?: SortOrder
    Diet?: DietOrderByRelationAggregateInput
    Serving?: ServingOrderByRelationAggregateInput
    _relevance?: DietaryItemOrderByRelevanceInput
  }

  export type DietaryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DietaryItemWhereInput | DietaryItemWhereInput[]
    OR?: DietaryItemWhereInput[]
    NOT?: DietaryItemWhereInput | DietaryItemWhereInput[]
    name?: StringFilter<"DietaryItem"> | string
    barcode?: StringNullableFilter<"DietaryItem"> | string | null
    gi?: IntNullableFilter<"DietaryItem"> | number | null
    calsPerOz?: FloatNullableFilter<"DietaryItem"> | number | null
    glutenFree?: BoolFilter<"DietaryItem"> | boolean
    minimalFructose?: BoolFilter<"DietaryItem"> | boolean
    natural?: BoolFilter<"DietaryItem"> | boolean
    organic?: BoolFilter<"DietaryItem"> | boolean
    impactScore?: FloatFilter<"DietaryItem"> | number
    Diet?: DietListRelationFilter
    Serving?: ServingListRelationFilter
  }, "id">

  export type DietaryItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrderInput | SortOrder
    gi?: SortOrderInput | SortOrder
    calsPerOz?: SortOrderInput | SortOrder
    glutenFree?: SortOrder
    minimalFructose?: SortOrder
    natural?: SortOrder
    organic?: SortOrder
    impactScore?: SortOrder
    _count?: DietaryItemCountOrderByAggregateInput
    _avg?: DietaryItemAvgOrderByAggregateInput
    _max?: DietaryItemMaxOrderByAggregateInput
    _min?: DietaryItemMinOrderByAggregateInput
    _sum?: DietaryItemSumOrderByAggregateInput
  }

  export type DietaryItemScalarWhereWithAggregatesInput = {
    AND?: DietaryItemScalarWhereWithAggregatesInput | DietaryItemScalarWhereWithAggregatesInput[]
    OR?: DietaryItemScalarWhereWithAggregatesInput[]
    NOT?: DietaryItemScalarWhereWithAggregatesInput | DietaryItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DietaryItem"> | number
    name?: StringWithAggregatesFilter<"DietaryItem"> | string
    barcode?: StringNullableWithAggregatesFilter<"DietaryItem"> | string | null
    gi?: IntNullableWithAggregatesFilter<"DietaryItem"> | number | null
    calsPerOz?: FloatNullableWithAggregatesFilter<"DietaryItem"> | number | null
    glutenFree?: BoolWithAggregatesFilter<"DietaryItem"> | boolean
    minimalFructose?: BoolWithAggregatesFilter<"DietaryItem"> | boolean
    natural?: BoolWithAggregatesFilter<"DietaryItem"> | boolean
    organic?: BoolWithAggregatesFilter<"DietaryItem"> | boolean
    impactScore?: FloatWithAggregatesFilter<"DietaryItem"> | number
  }

  export type HealthReportWhereInput = {
    AND?: HealthReportWhereInput | HealthReportWhereInput[]
    OR?: HealthReportWhereInput[]
    NOT?: HealthReportWhereInput | HealthReportWhereInput[]
    id?: IntFilter<"HealthReport"> | number
    title?: StringNullableFilter<"HealthReport"> | string | null
    summary?: StringNullableFilter<"HealthReport"> | string | null
    overall?: FloatFilter<"HealthReport"> | number
    skin?: FloatFilter<"HealthReport"> | number
    bloat?: FloatFilter<"HealthReport"> | number
    weight_feeling?: FloatFilter<"HealthReport"> | number
    fullness?: FloatFilter<"HealthReport"> | number
    weight?: FloatNullableFilter<"HealthReport"> | number | null
    cardiacCapacity?: FloatFilter<"HealthReport"> | number
    jawLine?: FloatFilter<"HealthReport"> | number
    joints?: FloatFilter<"HealthReport"> | number
    flexibility?: FloatFilter<"HealthReport"> | number
    anxiety?: FloatFilter<"HealthReport"> | number
    anxiety_desc?: StringNullableFilter<"HealthReport"> | string | null
    mood_desc?: StringNullableFilter<"HealthReport"> | string | null
    mood?: FloatFilter<"HealthReport"> | number
    sexDrive?: FloatFilter<"HealthReport"> | number
    intruisiveThoughts?: FloatFilter<"HealthReport"> | number
    caffeineIntake?: FloatFilter<"HealthReport"> | number
    glutenIntake?: FloatFilter<"HealthReport"> | number
    sugarIntake?: FloatFilter<"HealthReport"> | number
    artificialSweetenerIntake?: FloatFilter<"HealthReport"> | number
    artificalDyes?: FloatFilter<"HealthReport"> | number
    sleepQuality?: FloatFilter<"HealthReport"> | number
    hydration?: FloatFilter<"HealthReport"> | number
    twitching?: FloatFilter<"HealthReport"> | number
    sleepHours?: FloatNullableFilter<"HealthReport"> | number | null
    calorie_est?: IntNullableFilter<"HealthReport"> | number | null
    times_meals_more_than_gap_apart?: IntNullableFilter<"HealthReport"> | number | null
    estHoursInExcessFast?: FloatNullableFilter<"HealthReport"> | number | null
    dietId?: StringNullableFilter<"HealthReport"> | string | null
    created?: DateTimeFilter<"HealthReport"> | Date | string
    currentDiet?: XOR<DietNullableRelationFilter, DietWhereInput> | null
  }

  export type HealthReportOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    overall?: SortOrder
    skin?: SortOrder
    bloat?: SortOrder
    weight_feeling?: SortOrder
    fullness?: SortOrder
    weight?: SortOrderInput | SortOrder
    cardiacCapacity?: SortOrder
    jawLine?: SortOrder
    joints?: SortOrder
    flexibility?: SortOrder
    anxiety?: SortOrder
    anxiety_desc?: SortOrderInput | SortOrder
    mood_desc?: SortOrderInput | SortOrder
    mood?: SortOrder
    sexDrive?: SortOrder
    intruisiveThoughts?: SortOrder
    caffeineIntake?: SortOrder
    glutenIntake?: SortOrder
    sugarIntake?: SortOrder
    artificialSweetenerIntake?: SortOrder
    artificalDyes?: SortOrder
    sleepQuality?: SortOrder
    hydration?: SortOrder
    twitching?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    calorie_est?: SortOrderInput | SortOrder
    times_meals_more_than_gap_apart?: SortOrderInput | SortOrder
    estHoursInExcessFast?: SortOrderInput | SortOrder
    dietId?: SortOrderInput | SortOrder
    created?: SortOrder
    currentDiet?: DietOrderByWithRelationInput
    _relevance?: HealthReportOrderByRelevanceInput
  }

  export type HealthReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HealthReportWhereInput | HealthReportWhereInput[]
    OR?: HealthReportWhereInput[]
    NOT?: HealthReportWhereInput | HealthReportWhereInput[]
    title?: StringNullableFilter<"HealthReport"> | string | null
    summary?: StringNullableFilter<"HealthReport"> | string | null
    overall?: FloatFilter<"HealthReport"> | number
    skin?: FloatFilter<"HealthReport"> | number
    bloat?: FloatFilter<"HealthReport"> | number
    weight_feeling?: FloatFilter<"HealthReport"> | number
    fullness?: FloatFilter<"HealthReport"> | number
    weight?: FloatNullableFilter<"HealthReport"> | number | null
    cardiacCapacity?: FloatFilter<"HealthReport"> | number
    jawLine?: FloatFilter<"HealthReport"> | number
    joints?: FloatFilter<"HealthReport"> | number
    flexibility?: FloatFilter<"HealthReport"> | number
    anxiety?: FloatFilter<"HealthReport"> | number
    anxiety_desc?: StringNullableFilter<"HealthReport"> | string | null
    mood_desc?: StringNullableFilter<"HealthReport"> | string | null
    mood?: FloatFilter<"HealthReport"> | number
    sexDrive?: FloatFilter<"HealthReport"> | number
    intruisiveThoughts?: FloatFilter<"HealthReport"> | number
    caffeineIntake?: FloatFilter<"HealthReport"> | number
    glutenIntake?: FloatFilter<"HealthReport"> | number
    sugarIntake?: FloatFilter<"HealthReport"> | number
    artificialSweetenerIntake?: FloatFilter<"HealthReport"> | number
    artificalDyes?: FloatFilter<"HealthReport"> | number
    sleepQuality?: FloatFilter<"HealthReport"> | number
    hydration?: FloatFilter<"HealthReport"> | number
    twitching?: FloatFilter<"HealthReport"> | number
    sleepHours?: FloatNullableFilter<"HealthReport"> | number | null
    calorie_est?: IntNullableFilter<"HealthReport"> | number | null
    times_meals_more_than_gap_apart?: IntNullableFilter<"HealthReport"> | number | null
    estHoursInExcessFast?: FloatNullableFilter<"HealthReport"> | number | null
    dietId?: StringNullableFilter<"HealthReport"> | string | null
    created?: DateTimeFilter<"HealthReport"> | Date | string
    currentDiet?: XOR<DietNullableRelationFilter, DietWhereInput> | null
  }, "id">

  export type HealthReportOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    overall?: SortOrder
    skin?: SortOrder
    bloat?: SortOrder
    weight_feeling?: SortOrder
    fullness?: SortOrder
    weight?: SortOrderInput | SortOrder
    cardiacCapacity?: SortOrder
    jawLine?: SortOrder
    joints?: SortOrder
    flexibility?: SortOrder
    anxiety?: SortOrder
    anxiety_desc?: SortOrderInput | SortOrder
    mood_desc?: SortOrderInput | SortOrder
    mood?: SortOrder
    sexDrive?: SortOrder
    intruisiveThoughts?: SortOrder
    caffeineIntake?: SortOrder
    glutenIntake?: SortOrder
    sugarIntake?: SortOrder
    artificialSweetenerIntake?: SortOrder
    artificalDyes?: SortOrder
    sleepQuality?: SortOrder
    hydration?: SortOrder
    twitching?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    calorie_est?: SortOrderInput | SortOrder
    times_meals_more_than_gap_apart?: SortOrderInput | SortOrder
    estHoursInExcessFast?: SortOrderInput | SortOrder
    dietId?: SortOrderInput | SortOrder
    created?: SortOrder
    _count?: HealthReportCountOrderByAggregateInput
    _avg?: HealthReportAvgOrderByAggregateInput
    _max?: HealthReportMaxOrderByAggregateInput
    _min?: HealthReportMinOrderByAggregateInput
    _sum?: HealthReportSumOrderByAggregateInput
  }

  export type HealthReportScalarWhereWithAggregatesInput = {
    AND?: HealthReportScalarWhereWithAggregatesInput | HealthReportScalarWhereWithAggregatesInput[]
    OR?: HealthReportScalarWhereWithAggregatesInput[]
    NOT?: HealthReportScalarWhereWithAggregatesInput | HealthReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HealthReport"> | number
    title?: StringNullableWithAggregatesFilter<"HealthReport"> | string | null
    summary?: StringNullableWithAggregatesFilter<"HealthReport"> | string | null
    overall?: FloatWithAggregatesFilter<"HealthReport"> | number
    skin?: FloatWithAggregatesFilter<"HealthReport"> | number
    bloat?: FloatWithAggregatesFilter<"HealthReport"> | number
    weight_feeling?: FloatWithAggregatesFilter<"HealthReport"> | number
    fullness?: FloatWithAggregatesFilter<"HealthReport"> | number
    weight?: FloatNullableWithAggregatesFilter<"HealthReport"> | number | null
    cardiacCapacity?: FloatWithAggregatesFilter<"HealthReport"> | number
    jawLine?: FloatWithAggregatesFilter<"HealthReport"> | number
    joints?: FloatWithAggregatesFilter<"HealthReport"> | number
    flexibility?: FloatWithAggregatesFilter<"HealthReport"> | number
    anxiety?: FloatWithAggregatesFilter<"HealthReport"> | number
    anxiety_desc?: StringNullableWithAggregatesFilter<"HealthReport"> | string | null
    mood_desc?: StringNullableWithAggregatesFilter<"HealthReport"> | string | null
    mood?: FloatWithAggregatesFilter<"HealthReport"> | number
    sexDrive?: FloatWithAggregatesFilter<"HealthReport"> | number
    intruisiveThoughts?: FloatWithAggregatesFilter<"HealthReport"> | number
    caffeineIntake?: FloatWithAggregatesFilter<"HealthReport"> | number
    glutenIntake?: FloatWithAggregatesFilter<"HealthReport"> | number
    sugarIntake?: FloatWithAggregatesFilter<"HealthReport"> | number
    artificialSweetenerIntake?: FloatWithAggregatesFilter<"HealthReport"> | number
    artificalDyes?: FloatWithAggregatesFilter<"HealthReport"> | number
    sleepQuality?: FloatWithAggregatesFilter<"HealthReport"> | number
    hydration?: FloatWithAggregatesFilter<"HealthReport"> | number
    twitching?: FloatWithAggregatesFilter<"HealthReport"> | number
    sleepHours?: FloatNullableWithAggregatesFilter<"HealthReport"> | number | null
    calorie_est?: IntNullableWithAggregatesFilter<"HealthReport"> | number | null
    times_meals_more_than_gap_apart?: IntNullableWithAggregatesFilter<"HealthReport"> | number | null
    estHoursInExcessFast?: FloatNullableWithAggregatesFilter<"HealthReport"> | number | null
    dietId?: StringNullableWithAggregatesFilter<"HealthReport"> | string | null
    created?: DateTimeWithAggregatesFilter<"HealthReport"> | Date | string
  }

  export type WhiteboardWhereInput = {
    AND?: WhiteboardWhereInput | WhiteboardWhereInput[]
    OR?: WhiteboardWhereInput[]
    NOT?: WhiteboardWhereInput | WhiteboardWhereInput[]
    id?: StringFilter<"Whiteboard"> | string
    data?: BytesFilter<"Whiteboard"> | Buffer
  }

  export type WhiteboardOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    _relevance?: WhiteboardOrderByRelevanceInput
  }

  export type WhiteboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhiteboardWhereInput | WhiteboardWhereInput[]
    OR?: WhiteboardWhereInput[]
    NOT?: WhiteboardWhereInput | WhiteboardWhereInput[]
    data?: BytesFilter<"Whiteboard"> | Buffer
  }, "id" | "id">

  export type WhiteboardOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    _count?: WhiteboardCountOrderByAggregateInput
    _max?: WhiteboardMaxOrderByAggregateInput
    _min?: WhiteboardMinOrderByAggregateInput
  }

  export type WhiteboardScalarWhereWithAggregatesInput = {
    AND?: WhiteboardScalarWhereWithAggregatesInput | WhiteboardScalarWhereWithAggregatesInput[]
    OR?: WhiteboardScalarWhereWithAggregatesInput[]
    NOT?: WhiteboardScalarWhereWithAggregatesInput | WhiteboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Whiteboard"> | string
    data?: BytesWithAggregatesFilter<"Whiteboard"> | Buffer
  }

  export type DJTWhereInput = {
    AND?: DJTWhereInput | DJTWhereInput[]
    OR?: DJTWhereInput[]
    NOT?: DJTWhereInput | DJTWhereInput[]
    id?: IntFilter<"DJT"> | number
    type?: StringFilter<"DJT"> | string
    data?: BytesFilter<"DJT"> | Buffer
  }

  export type DJTOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    _relevance?: DJTOrderByRelevanceInput
  }

  export type DJTWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DJTWhereInput | DJTWhereInput[]
    OR?: DJTWhereInput[]
    NOT?: DJTWhereInput | DJTWhereInput[]
    type?: StringFilter<"DJT"> | string
    data?: BytesFilter<"DJT"> | Buffer
  }, "id">

  export type DJTOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    _count?: DJTCountOrderByAggregateInput
    _avg?: DJTAvgOrderByAggregateInput
    _max?: DJTMaxOrderByAggregateInput
    _min?: DJTMinOrderByAggregateInput
    _sum?: DJTSumOrderByAggregateInput
  }

  export type DJTScalarWhereWithAggregatesInput = {
    AND?: DJTScalarWhereWithAggregatesInput | DJTScalarWhereWithAggregatesInput[]
    OR?: DJTScalarWhereWithAggregatesInput[]
    NOT?: DJTScalarWhereWithAggregatesInput | DJTScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DJT"> | number
    type?: StringWithAggregatesFilter<"DJT"> | string
    data?: BytesWithAggregatesFilter<"DJT"> | Buffer
  }

  export type FeatureRequestCreateInput = {
    email: string
    message: string
    category?: FeatureRequestCreatecategoryInput | string[]
    userBase?: FeatureRequestCreateuserBaseInput | string[]
    receivedOn?: Date | string
  }

  export type FeatureRequestUncheckedCreateInput = {
    id?: number
    email: string
    message: string
    category?: FeatureRequestCreatecategoryInput | string[]
    userBase?: FeatureRequestCreateuserBaseInput | string[]
    receivedOn?: Date | string
  }

  export type FeatureRequestUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: FeatureRequestUpdatecategoryInput | string[]
    userBase?: FeatureRequestUpdateuserBaseInput | string[]
    receivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: FeatureRequestUpdatecategoryInput | string[]
    userBase?: FeatureRequestUpdateuserBaseInput | string[]
    receivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureRequestCreateManyInput = {
    id?: number
    email: string
    message: string
    category?: FeatureRequestCreatecategoryInput | string[]
    userBase?: FeatureRequestCreateuserBaseInput | string[]
    receivedOn?: Date | string
  }

  export type FeatureRequestUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: FeatureRequestUpdatecategoryInput | string[]
    userBase?: FeatureRequestUpdateuserBaseInput | string[]
    receivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: FeatureRequestUpdatecategoryInput | string[]
    userBase?: FeatureRequestUpdateuserBaseInput | string[]
    receivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaitlistRequestCreateInput = {
    email: string
    receivedOn?: Date | string
    emailsSent?: number
  }

  export type WaitlistRequestUncheckedCreateInput = {
    id?: number
    email: string
    receivedOn?: Date | string
    emailsSent?: number
  }

  export type WaitlistRequestUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    receivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
  }

  export type WaitlistRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    receivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
  }

  export type WaitlistRequestCreateManyInput = {
    id?: number
    email: string
    receivedOn?: Date | string
    emailsSent?: number
  }

  export type WaitlistRequestUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    receivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
  }

  export type WaitlistRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    receivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    emailsSent?: IntFieldUpdateOperationsInput | number
  }

  export type SubjectCreateInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectCreateManyInput = {
    value: string
    kanbanId?: number | null
  }

  export type SubjectUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TopicCreateInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicCreateManyInput = {
    value: string
    kanbanId?: number | null
  }

  export type TopicUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateManyInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagCreateInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    value: string
    kanbanId?: number | null
  }

  export type TagUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuoteCreateInput = {
    body: string
    author: string
    source?: string | null
    pinned?: boolean
    createdAt?: Date | string
  }

  export type QuoteUncheckedCreateInput = {
    body: string
    author: string
    source?: string | null
    pinned?: boolean
    createdAt?: Date | string
  }

  export type QuoteUpdateInput = {
    body?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateInput = {
    body?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateManyInput = {
    body: string
    author: string
    source?: string | null
    pinned?: boolean
    createdAt?: Date | string
  }

  export type QuoteUpdateManyMutationInput = {
    body?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyInput = {
    body?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyFocusCreateInput = {
    value: string
    createdAt?: Date | string
  }

  export type DailyFocusUncheckedCreateInput = {
    value: string
    createdAt?: Date | string
  }

  export type DailyFocusUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyFocusUncheckedUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyFocusCreateManyInput = {
    value: string
    createdAt?: Date | string
  }

  export type DailyFocusUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyFocusUncheckedUpdateManyInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoSettingCreateInput = {
    type: $Enums.autoSetting
    glob: string
    value: string
  }

  export type AutoSettingUncheckedCreateInput = {
    id?: number
    type: $Enums.autoSetting
    glob: string
    value: string
  }

  export type AutoSettingUpdateInput = {
    type?: EnumautoSettingFieldUpdateOperationsInput | $Enums.autoSetting
    glob?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type AutoSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumautoSettingFieldUpdateOperationsInput | $Enums.autoSetting
    glob?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type AutoSettingCreateManyInput = {
    id?: number
    type: $Enums.autoSetting
    glob: string
    value: string
  }

  export type AutoSettingUpdateManyMutationInput = {
    type?: EnumautoSettingFieldUpdateOperationsInput | $Enums.autoSetting
    glob?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type AutoSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumautoSettingFieldUpdateOperationsInput | $Enums.autoSetting
    glob?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ReadingListCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
    bibEntries?: BibEntryCreateNestedManyWithoutReadingListInput
    mdxNotes?: MdxNoteCreateNestedManyWithoutReadingListInput
    ipynbNotes?: IpynbCreateNestedManyWithoutReadingListInput
  }

  export type ReadingListUncheckedCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutReadingListInput
    mdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutReadingListInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutReadingListInput
  }

  export type ReadingListUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bibEntries?: BibEntryUpdateManyWithoutReadingListNestedInput
    mdxNotes?: MdxNoteUpdateManyWithoutReadingListNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutReadingListNestedInput
  }

  export type ReadingListUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bibEntries?: BibEntryUncheckedUpdateManyWithoutReadingListNestedInput
    mdxNotes?: MdxNoteUncheckedUpdateManyWithoutReadingListNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutReadingListNestedInput
  }

  export type ReadingListCreateManyInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
  }

  export type ReadingListUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingListUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibEntryCreateInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    Bib?: BibCreateNestedOneWithoutEntriesInput
    citationGroups?: CitationsGroupCreateNestedManyWithoutEntriesInput
    tags?: TagCreateNestedManyWithoutBibEntriesInput
    topics?: TopicCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUncheckedCreateInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput
    tags?: TagUncheckedCreateNestedManyWithoutBibEntriesInput
    topics?: TopicUncheckedCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    Bib?: BibUpdateOneWithoutEntriesNestedInput
    citationGroups?: CitationsGroupUpdateManyWithoutEntriesNestedInput
    tags?: TagUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryCreateManyInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
  }

  export type BibEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationsGroupCreateInput = {
    name: string
    description?: string | null
    entries?: BibEntryCreateNestedManyWithoutCitationGroupsInput
  }

  export type CitationsGroupUncheckedCreateInput = {
    name: string
    description?: string | null
    entries?: BibEntryUncheckedCreateNestedManyWithoutCitationGroupsInput
  }

  export type CitationsGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: BibEntryUpdateManyWithoutCitationGroupsNestedInput
  }

  export type CitationsGroupUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: BibEntryUncheckedUpdateManyWithoutCitationGroupsNestedInput
  }

  export type CitationsGroupCreateManyInput = {
    name: string
    description?: string | null
  }

  export type CitationsGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CitationsGroupUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BibCreateInput = {
    id?: number
    filename: string
    firstSync?: Date | string
    lastSync?: Date | string
    entries?: BibEntryCreateNestedManyWithoutBibInput
  }

  export type BibUncheckedCreateInput = {
    id?: number
    filename: string
    firstSync?: Date | string
    lastSync?: Date | string
    entries?: BibEntryUncheckedCreateNestedManyWithoutBibInput
  }

  export type BibUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: BibEntryUpdateManyWithoutBibNestedInput
  }

  export type BibUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: BibEntryUncheckedUpdateManyWithoutBibNestedInput
  }

  export type BibCreateManyInput = {
    id?: number
    filename: string
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type BibUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleCalendarAuthCreateInput = {
    id?: number
    auth?: string | null
  }

  export type GoogleCalendarAuthUncheckedCreateInput = {
    id?: number
    auth?: string | null
  }

  export type GoogleCalendarAuthUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    auth?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GoogleCalendarAuthUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    auth?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GoogleCalendarAuthCreateManyInput = {
    id?: number
    auth?: string | null
  }

  export type GoogleCalendarAuthUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    auth?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GoogleCalendarAuthUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    auth?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SnippetCreateInput = {
    content: string
    description: string
    keywords?: SnippetCreatekeywordsInput | string[]
    language: $Enums.Technologies
  }

  export type SnippetUncheckedCreateInput = {
    id?: number
    content: string
    description: string
    keywords?: SnippetCreatekeywordsInput | string[]
    language: $Enums.Technologies
  }

  export type SnippetUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: SnippetUpdatekeywordsInput | string[]
    language?: EnumTechnologiesFieldUpdateOperationsInput | $Enums.Technologies
  }

  export type SnippetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: SnippetUpdatekeywordsInput | string[]
    language?: EnumTechnologiesFieldUpdateOperationsInput | $Enums.Technologies
  }

  export type SnippetCreateManyInput = {
    id?: number
    content: string
    description: string
    keywords?: SnippetCreatekeywordsInput | string[]
    language: $Enums.Technologies
  }

  export type SnippetUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: SnippetUpdatekeywordsInput | string[]
    language?: EnumTechnologiesFieldUpdateOperationsInput | $Enums.Technologies
  }

  export type SnippetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: SnippetUpdatekeywordsInput | string[]
    language?: EnumTechnologiesFieldUpdateOperationsInput | $Enums.Technologies
  }

  export type RelatedValuesCreateInput = {
    input: JsonNullValueInput | InputJsonValue
    output: number
    equationId?: RelatedValuesCreateequationIdInput | number[]
    equations?: EquationCreateNestedManyWithoutRelatedValuesInput
  }

  export type RelatedValuesUncheckedCreateInput = {
    id?: number
    input: JsonNullValueInput | InputJsonValue
    output: number
    equationId?: RelatedValuesCreateequationIdInput | number[]
    equations?: EquationUncheckedCreateNestedManyWithoutRelatedValuesInput
  }

  export type RelatedValuesUpdateInput = {
    input?: JsonNullValueInput | InputJsonValue
    output?: FloatFieldUpdateOperationsInput | number
    equationId?: RelatedValuesUpdateequationIdInput | number[]
    equations?: EquationUpdateManyWithoutRelatedValuesNestedInput
  }

  export type RelatedValuesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: FloatFieldUpdateOperationsInput | number
    equationId?: RelatedValuesUpdateequationIdInput | number[]
    equations?: EquationUncheckedUpdateManyWithoutRelatedValuesNestedInput
  }

  export type RelatedValuesCreateManyInput = {
    id?: number
    input: JsonNullValueInput | InputJsonValue
    output: number
    equationId?: RelatedValuesCreateequationIdInput | number[]
  }

  export type RelatedValuesUpdateManyMutationInput = {
    input?: JsonNullValueInput | InputJsonValue
    output?: FloatFieldUpdateOperationsInput | number
    equationId?: RelatedValuesUpdateequationIdInput | number[]
  }

  export type RelatedValuesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: FloatFieldUpdateOperationsInput | number
    equationId?: RelatedValuesUpdateequationIdInput | number[]
  }

  export type EquationCreateInput = {
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesCreateNestedManyWithoutEquationsInput
    tags?: TagCreateNestedManyWithoutEquationsInput
    topics?: TopicCreateNestedManyWithoutEquationsInput
    subjects?: SubjectCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteCreateNestedManyWithoutEquationsInput
  }

  export type EquationUncheckedCreateInput = {
    id?: number
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesUncheckedCreateNestedManyWithoutEquationsInput
    tags?: TagUncheckedCreateNestedManyWithoutEquationsInput
    topics?: TopicUncheckedCreateNestedManyWithoutEquationsInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutEquationsInput
  }

  export type EquationUpdateInput = {
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUpdateManyWithoutEquationsNestedInput
    tags?: TagUpdateManyWithoutEquationsNestedInput
    topics?: TopicUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUncheckedUpdateManyWithoutEquationsNestedInput
    tags?: TagUncheckedUpdateManyWithoutEquationsNestedInput
    topics?: TopicUncheckedUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUncheckedUpdateManyWithoutEquationsNestedInput
  }

  export type EquationCreateManyInput = {
    id?: number
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
  }

  export type EquationUpdateManyMutationInput = {
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefinitionCreateInput = {
    id: string
    label?: string | null
    content?: string | null
    alphabeticalLabel?: string | null
    mdxNote?: MdxNoteCreateNestedOneWithoutDefinitionsInput
  }

  export type DefinitionUncheckedCreateInput = {
    id: string
    label?: string | null
    content?: string | null
    alphabeticalLabel?: string | null
    mdxNoteId?: number | null
  }

  export type DefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    alphabeticalLabel?: NullableStringFieldUpdateOperationsInput | string | null
    mdxNote?: MdxNoteUpdateOneWithoutDefinitionsNestedInput
  }

  export type DefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    alphabeticalLabel?: NullableStringFieldUpdateOperationsInput | string | null
    mdxNoteId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DefinitionCreateManyInput = {
    id: string
    label?: string | null
    content?: string | null
    alphabeticalLabel?: string | null
    mdxNoteId?: number | null
  }

  export type DefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    alphabeticalLabel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    alphabeticalLabel?: NullableStringFieldUpdateOperationsInput | string | null
    mdxNoteId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingsCreateInput = {
    id?: number
    tooltips?: boolean
    title?: string
    summary_showCitations?: boolean
    summary_showTags?: boolean
    landingImageAlign?: $Enums.ImageAlignment
    lockedLandingImage?: string | null
    cleanOnSync?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type SettingsUncheckedCreateInput = {
    id?: number
    tooltips?: boolean
    title?: string
    summary_showCitations?: boolean
    summary_showTags?: boolean
    landingImageAlign?: $Enums.ImageAlignment
    lockedLandingImage?: string | null
    cleanOnSync?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tooltips?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    summary_showCitations?: BoolFieldUpdateOperationsInput | boolean
    summary_showTags?: BoolFieldUpdateOperationsInput | boolean
    landingImageAlign?: EnumImageAlignmentFieldUpdateOperationsInput | $Enums.ImageAlignment
    lockedLandingImage?: NullableStringFieldUpdateOperationsInput | string | null
    cleanOnSync?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tooltips?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    summary_showCitations?: BoolFieldUpdateOperationsInput | boolean
    summary_showTags?: BoolFieldUpdateOperationsInput | boolean
    landingImageAlign?: EnumImageAlignmentFieldUpdateOperationsInput | $Enums.ImageAlignment
    lockedLandingImage?: NullableStringFieldUpdateOperationsInput | string | null
    cleanOnSync?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: number
    tooltips?: boolean
    title?: string
    summary_showCitations?: boolean
    summary_showTags?: boolean
    landingImageAlign?: $Enums.ImageAlignment
    lockedLandingImage?: string | null
    cleanOnSync?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    tooltips?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    summary_showCitations?: BoolFieldUpdateOperationsInput | boolean
    summary_showTags?: BoolFieldUpdateOperationsInput | boolean
    landingImageAlign?: EnumImageAlignmentFieldUpdateOperationsInput | $Enums.ImageAlignment
    lockedLandingImage?: NullableStringFieldUpdateOperationsInput | string | null
    cleanOnSync?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tooltips?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    summary_showCitations?: BoolFieldUpdateOperationsInput | boolean
    summary_showTags?: BoolFieldUpdateOperationsInput | boolean
    landingImageAlign?: EnumImageAlignmentFieldUpdateOperationsInput | $Enums.ImageAlignment
    lockedLandingImage?: NullableStringFieldUpdateOperationsInput | string | null
    cleanOnSync?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsAppendixCreateInput = {
    id: string
    data: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsAppendixUncheckedCreateInput = {
    id: string
    data: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsAppendixUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsAppendixUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsAppendixCreateManyInput = {
    id: string
    data: Buffer
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsAppendixUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsAppendixUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RandomImageCreateInput = {
    path: string
    createdAt?: Date | string
  }

  export type RandomImageUncheckedCreateInput = {
    path: string
    createdAt?: Date | string
  }

  export type RandomImageUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RandomImageUncheckedUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RandomImageCreateManyInput = {
    path: string
    createdAt?: Date | string
  }

  export type RandomImageUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RandomImageUncheckedUpdateManyInput = {
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteTypeCreateInput = {
    name: string
  }

  export type NoteTypeUncheckedCreateInput = {
    name: string
  }

  export type NoteTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NoteTypeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NoteTypeCreateManyInput = {
    name: string
  }

  export type NoteTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NoteTypeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type QAPairCreateInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    tags?: TagCreateNestedManyWithoutQAPairInput
    topics?: TopicCreateNestedManyWithoutQAPairInput
    subjects?: SubjectCreateNestedManyWithoutQaPairInput
    practiceExam?: PracticeExamCreateNestedManyWithoutQuestionsInput
  }

  export type QAPairUncheckedCreateInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    tags?: TagUncheckedCreateNestedManyWithoutQAPairInput
    topics?: TopicUncheckedCreateNestedManyWithoutQAPairInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutQaPairInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QAPairUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    tags?: TagUpdateManyWithoutQAPairNestedInput
    topics?: TopicUpdateManyWithoutQAPairNestedInput
    subjects?: SubjectUpdateManyWithoutQaPairNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutQuestionsNestedInput
  }

  export type QAPairUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutQAPairNestedInput
    topics?: TopicUncheckedUpdateManyWithoutQAPairNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutQaPairNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QAPairCreateManyInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
  }

  export type QAPairUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
  }

  export type QAPairUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
  }

  export type PracticeExamCreateInput = {
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    topics?: TopicCreateNestedManyWithoutPracticeExamInput
    tags?: TagCreateNestedManyWithoutPracticeExamInput
    subjects?: SubjectCreateNestedManyWithoutPracticeExamInput
    questions?: QAPairCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamUncheckedCreateInput = {
    id?: number
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutPracticeExamInput
    tags?: TagUncheckedCreateNestedManyWithoutPracticeExamInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutPracticeExamInput
    questions?: QAPairUncheckedCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamUpdateInput = {
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutPracticeExamNestedInput
    tags?: TagUpdateManyWithoutPracticeExamNestedInput
    subjects?: SubjectUpdateManyWithoutPracticeExamNestedInput
    questions?: QAPairUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutPracticeExamNestedInput
    tags?: TagUncheckedUpdateManyWithoutPracticeExamNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutPracticeExamNestedInput
    questions?: QAPairUncheckedUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamCreateManyInput = {
    id?: number
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
  }

  export type PracticeExamUpdateManyMutationInput = {
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PracticeExamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SequentialNoteListCreateInput = {
    sequentialKey: string
    MdxNote?: MdxNoteCreateNestedManyWithoutSequentialListInput
    Ipynb?: IpynbCreateNestedManyWithoutSequentialListInput
  }

  export type SequentialNoteListUncheckedCreateInput = {
    sequentialKey: string
    MdxNote?: MdxNoteUncheckedCreateNestedManyWithoutSequentialListInput
    Ipynb?: IpynbUncheckedCreateNestedManyWithoutSequentialListInput
  }

  export type SequentialNoteListUpdateInput = {
    sequentialKey?: StringFieldUpdateOperationsInput | string
    MdxNote?: MdxNoteUpdateManyWithoutSequentialListNestedInput
    Ipynb?: IpynbUpdateManyWithoutSequentialListNestedInput
  }

  export type SequentialNoteListUncheckedUpdateInput = {
    sequentialKey?: StringFieldUpdateOperationsInput | string
    MdxNote?: MdxNoteUncheckedUpdateManyWithoutSequentialListNestedInput
    Ipynb?: IpynbUncheckedUpdateManyWithoutSequentialListNestedInput
  }

  export type SequentialNoteListCreateManyInput = {
    sequentialKey: string
  }

  export type SequentialNoteListUpdateManyMutationInput = {
    sequentialKey?: StringFieldUpdateOperationsInput | string
  }

  export type SequentialNoteListUncheckedUpdateManyInput = {
    sequentialKey?: StringFieldUpdateOperationsInput | string
  }

  export type MdxNoteCreateInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUpdateInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteCreateManyInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type MdxNoteUpdateManyMutationInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MdxNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpynbCreateInput = {
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryCreateNestedManyWithoutIpynbNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutIpynbInput
    readingList?: ReadingListCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbUncheckedCreateInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialKey?: string | null
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicUncheckedCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutIpynbNotesInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbUpdateInput = {
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUpdateManyWithoutIpynbNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutIpynbNestedInput
    readingList?: ReadingListUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutIpynbNotesNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbCreateManyInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialKey?: string | null
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type IpynbUpdateManyMutationInput = {
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpynbUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToDoListCreateInput = {
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tasks?: ToDoCreateNestedManyWithoutToDoListInput
    tags?: TagCreateNestedManyWithoutTodoListInput
    topics?: TopicCreateNestedManyWithoutTodoListInput
    subjects?: SubjectCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListUncheckedCreateInput = {
    id?: number
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tasks?: ToDoUncheckedCreateNestedManyWithoutToDoListInput
    tags?: TagUncheckedCreateNestedManyWithoutTodoListInput
    topics?: TopicUncheckedCreateNestedManyWithoutTodoListInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ToDoUpdateManyWithoutToDoListNestedInput
    tags?: TagUpdateManyWithoutTodoListNestedInput
    topics?: TopicUpdateManyWithoutTodoListNestedInput
    subjects?: SubjectUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ToDoUncheckedUpdateManyWithoutToDoListNestedInput
    tags?: TagUncheckedUpdateManyWithoutTodoListNestedInput
    topics?: TopicUncheckedUpdateManyWithoutTodoListNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListCreateManyInput = {
    id?: number
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
  }

  export type ToDoListUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToDoListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToDoCreateInput = {
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    associatedNotes?: MdxNoteCreateNestedManyWithoutToDoInput
    tags?: TagCreateNestedManyWithoutToDoInput
    topics?: TopicCreateNestedManyWithoutToDoInput
    subjects?: SubjectCreateNestedManyWithoutToDoInput
    parent?: ToDoCreateNestedOneWithoutChildInput
    child?: ToDoCreateNestedManyWithoutParentInput
    ToDoList?: ToDoListCreateNestedOneWithoutTasksInput
  }

  export type ToDoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
    associatedNotes?: MdxNoteUncheckedCreateNestedManyWithoutToDoInput
    tags?: TagUncheckedCreateNestedManyWithoutToDoInput
    topics?: TopicUncheckedCreateNestedManyWithoutToDoInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutToDoInput
    child?: ToDoUncheckedCreateNestedManyWithoutParentInput
  }

  export type ToDoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    associatedNotes?: MdxNoteUpdateManyWithoutToDoNestedInput
    tags?: TagUpdateManyWithoutToDoNestedInput
    topics?: TopicUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUpdateManyWithoutToDoNestedInput
    parent?: ToDoUpdateOneWithoutChildNestedInput
    child?: ToDoUpdateManyWithoutParentNestedInput
    ToDoList?: ToDoListUpdateOneWithoutTasksNestedInput
  }

  export type ToDoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
    associatedNotes?: MdxNoteUncheckedUpdateManyWithoutToDoNestedInput
    tags?: TagUncheckedUpdateManyWithoutToDoNestedInput
    topics?: TopicUncheckedUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutToDoNestedInput
    child?: ToDoUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ToDoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
  }

  export type ToDoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type ToDoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KanBanCardCreateInput = {
    indexWithinList: number
    label?: string | null
    details?: string | null
    KanBanList?: KanBanListCreateNestedOneWithoutCardsInput
  }

  export type KanBanCardUncheckedCreateInput = {
    id?: number
    listId?: number | null
    indexWithinList: number
    label?: string | null
    details?: string | null
  }

  export type KanBanCardUpdateInput = {
    indexWithinList?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    KanBanList?: KanBanListUpdateOneWithoutCardsNestedInput
  }

  export type KanBanCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    listId?: NullableIntFieldUpdateOperationsInput | number | null
    indexWithinList?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KanBanCardCreateManyInput = {
    id?: number
    listId?: number | null
    indexWithinList: number
    label?: string | null
    details?: string | null
  }

  export type KanBanCardUpdateManyMutationInput = {
    indexWithinList?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KanBanCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    listId?: NullableIntFieldUpdateOperationsInput | number | null
    indexWithinList?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KanBanListCreateInput = {
    indexWithinBoard: number
    title?: string | null
    cards?: KanBanCardCreateNestedManyWithoutKanBanListInput
    Kanban?: KanbanCreateNestedOneWithoutListsInput
  }

  export type KanBanListUncheckedCreateInput = {
    id?: number
    indexWithinBoard: number
    title?: string | null
    boardId?: number | null
    cards?: KanBanCardUncheckedCreateNestedManyWithoutKanBanListInput
  }

  export type KanBanListUpdateInput = {
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    cards?: KanBanCardUpdateManyWithoutKanBanListNestedInput
    Kanban?: KanbanUpdateOneWithoutListsNestedInput
  }

  export type KanBanListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    boardId?: NullableIntFieldUpdateOperationsInput | number | null
    cards?: KanBanCardUncheckedUpdateManyWithoutKanBanListNestedInput
  }

  export type KanBanListCreateManyInput = {
    id?: number
    indexWithinBoard: number
    title?: string | null
    boardId?: number | null
  }

  export type KanBanListUpdateManyMutationInput = {
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KanBanListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    boardId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KanbanCreateInput = {
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    lists?: KanBanListCreateNestedManyWithoutKanbanInput
    tags?: TagCreateNestedManyWithoutKanbanInput
    subjects?: SubjectCreateNestedManyWithoutKanbanInput
    topics?: TopicCreateNestedManyWithoutKanbanInput
  }

  export type KanbanUncheckedCreateInput = {
    id?: number
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    lists?: KanBanListUncheckedCreateNestedManyWithoutKanbanInput
    tags?: TagUncheckedCreateNestedManyWithoutKanbanInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutKanbanInput
    topics?: TopicUncheckedCreateNestedManyWithoutKanbanInput
  }

  export type KanbanUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: KanBanListUpdateManyWithoutKanbanNestedInput
    tags?: TagUpdateManyWithoutKanbanNestedInput
    subjects?: SubjectUpdateManyWithoutKanbanNestedInput
    topics?: TopicUpdateManyWithoutKanbanNestedInput
  }

  export type KanbanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: KanBanListUncheckedUpdateManyWithoutKanbanNestedInput
    tags?: TagUncheckedUpdateManyWithoutKanbanNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutKanbanNestedInput
    topics?: TopicUncheckedUpdateManyWithoutKanbanNestedInput
  }

  export type KanbanCreateManyInput = {
    id?: number
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
  }

  export type KanbanUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KanbanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimePeriodCreateInput = {
    start?: Date | string
    end?: Date | string | null
    Diet?: DietCreateNestedOneWithoutPeriodsFollowedInput
  }

  export type TimePeriodUncheckedCreateInput = {
    id?: number
    start?: Date | string
    end?: Date | string | null
    dietId?: string | null
  }

  export type TimePeriodUpdateInput = {
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Diet?: DietUpdateOneWithoutPeriodsFollowedNestedInput
  }

  export type TimePeriodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimePeriodCreateManyInput = {
    id?: number
    start?: Date | string
    end?: Date | string | null
    dietId?: string | null
  }

  export type TimePeriodUpdateManyMutationInput = {
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimePeriodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DietCreateInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
    items?: DietaryItemCreateNestedManyWithoutDietInput
    periodsFollowed?: TimePeriodCreateNestedManyWithoutDietInput
    HealthReport?: HealthReportCreateNestedManyWithoutCurrentDietInput
  }

  export type DietUncheckedCreateInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
    items?: DietaryItemUncheckedCreateNestedManyWithoutDietInput
    periodsFollowed?: TimePeriodUncheckedCreateNestedManyWithoutDietInput
    HealthReport?: HealthReportUncheckedCreateNestedManyWithoutCurrentDietInput
  }

  export type DietUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DietaryItemUpdateManyWithoutDietNestedInput
    periodsFollowed?: TimePeriodUpdateManyWithoutDietNestedInput
    HealthReport?: HealthReportUpdateManyWithoutCurrentDietNestedInput
  }

  export type DietUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DietaryItemUncheckedUpdateManyWithoutDietNestedInput
    periodsFollowed?: TimePeriodUncheckedUpdateManyWithoutDietNestedInput
    HealthReport?: HealthReportUncheckedUpdateManyWithoutCurrentDietNestedInput
  }

  export type DietCreateManyInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
  }

  export type DietUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DietUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServingCreateInput = {
    quant_oz?: number | null
    quant_guess?: $Enums.QUANTITY_GUESS | null
    item: DietaryItemCreateNestedOneWithoutServingInput
  }

  export type ServingUncheckedCreateInput = {
    id?: number
    dietaryItemId: number
    quant_oz?: number | null
    quant_guess?: $Enums.QUANTITY_GUESS | null
  }

  export type ServingUpdateInput = {
    quant_oz?: NullableFloatFieldUpdateOperationsInput | number | null
    quant_guess?: NullableEnumQUANTITY_GUESSFieldUpdateOperationsInput | $Enums.QUANTITY_GUESS | null
    item?: DietaryItemUpdateOneRequiredWithoutServingNestedInput
  }

  export type ServingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dietaryItemId?: IntFieldUpdateOperationsInput | number
    quant_oz?: NullableFloatFieldUpdateOperationsInput | number | null
    quant_guess?: NullableEnumQUANTITY_GUESSFieldUpdateOperationsInput | $Enums.QUANTITY_GUESS | null
  }

  export type ServingCreateManyInput = {
    id?: number
    dietaryItemId: number
    quant_oz?: number | null
    quant_guess?: $Enums.QUANTITY_GUESS | null
  }

  export type ServingUpdateManyMutationInput = {
    quant_oz?: NullableFloatFieldUpdateOperationsInput | number | null
    quant_guess?: NullableEnumQUANTITY_GUESSFieldUpdateOperationsInput | $Enums.QUANTITY_GUESS | null
  }

  export type ServingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dietaryItemId?: IntFieldUpdateOperationsInput | number
    quant_oz?: NullableFloatFieldUpdateOperationsInput | number | null
    quant_guess?: NullableEnumQUANTITY_GUESSFieldUpdateOperationsInput | $Enums.QUANTITY_GUESS | null
  }

  export type DietaryItemCreateInput = {
    name: string
    barcode?: string | null
    gi?: number | null
    calsPerOz?: number | null
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: number
    Diet?: DietCreateNestedManyWithoutItemsInput
    Serving?: ServingCreateNestedManyWithoutItemInput
  }

  export type DietaryItemUncheckedCreateInput = {
    id?: number
    name: string
    barcode?: string | null
    gi?: number | null
    calsPerOz?: number | null
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: number
    Diet?: DietUncheckedCreateNestedManyWithoutItemsInput
    Serving?: ServingUncheckedCreateNestedManyWithoutItemInput
  }

  export type DietaryItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
    Diet?: DietUpdateManyWithoutItemsNestedInput
    Serving?: ServingUpdateManyWithoutItemNestedInput
  }

  export type DietaryItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
    Diet?: DietUncheckedUpdateManyWithoutItemsNestedInput
    Serving?: ServingUncheckedUpdateManyWithoutItemNestedInput
  }

  export type DietaryItemCreateManyInput = {
    id?: number
    name: string
    barcode?: string | null
    gi?: number | null
    calsPerOz?: number | null
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: number
  }

  export type DietaryItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
  }

  export type DietaryItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
  }

  export type HealthReportCreateInput = {
    title?: string | null
    summary?: string | null
    overall?: number
    skin?: number
    bloat?: number
    weight_feeling?: number
    fullness?: number
    weight?: number | null
    cardiacCapacity?: number
    jawLine?: number
    joints?: number
    flexibility?: number
    anxiety?: number
    anxiety_desc?: string | null
    mood_desc?: string | null
    mood?: number
    sexDrive?: number
    intruisiveThoughts?: number
    caffeineIntake?: number
    glutenIntake?: number
    sugarIntake?: number
    artificialSweetenerIntake?: number
    artificalDyes?: number
    sleepQuality?: number
    hydration?: number
    twitching?: number
    sleepHours?: number | null
    calorie_est?: number | null
    times_meals_more_than_gap_apart?: number | null
    estHoursInExcessFast?: number | null
    created?: Date | string
    currentDiet?: DietCreateNestedOneWithoutHealthReportInput
  }

  export type HealthReportUncheckedCreateInput = {
    id?: number
    title?: string | null
    summary?: string | null
    overall?: number
    skin?: number
    bloat?: number
    weight_feeling?: number
    fullness?: number
    weight?: number | null
    cardiacCapacity?: number
    jawLine?: number
    joints?: number
    flexibility?: number
    anxiety?: number
    anxiety_desc?: string | null
    mood_desc?: string | null
    mood?: number
    sexDrive?: number
    intruisiveThoughts?: number
    caffeineIntake?: number
    glutenIntake?: number
    sugarIntake?: number
    artificialSweetenerIntake?: number
    artificalDyes?: number
    sleepQuality?: number
    hydration?: number
    twitching?: number
    sleepHours?: number | null
    calorie_est?: number | null
    times_meals_more_than_gap_apart?: number | null
    estHoursInExcessFast?: number | null
    dietId?: string | null
    created?: Date | string
  }

  export type HealthReportUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    overall?: FloatFieldUpdateOperationsInput | number
    skin?: FloatFieldUpdateOperationsInput | number
    bloat?: FloatFieldUpdateOperationsInput | number
    weight_feeling?: FloatFieldUpdateOperationsInput | number
    fullness?: FloatFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cardiacCapacity?: FloatFieldUpdateOperationsInput | number
    jawLine?: FloatFieldUpdateOperationsInput | number
    joints?: FloatFieldUpdateOperationsInput | number
    flexibility?: FloatFieldUpdateOperationsInput | number
    anxiety?: FloatFieldUpdateOperationsInput | number
    anxiety_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: FloatFieldUpdateOperationsInput | number
    sexDrive?: FloatFieldUpdateOperationsInput | number
    intruisiveThoughts?: FloatFieldUpdateOperationsInput | number
    caffeineIntake?: FloatFieldUpdateOperationsInput | number
    glutenIntake?: FloatFieldUpdateOperationsInput | number
    sugarIntake?: FloatFieldUpdateOperationsInput | number
    artificialSweetenerIntake?: FloatFieldUpdateOperationsInput | number
    artificalDyes?: FloatFieldUpdateOperationsInput | number
    sleepQuality?: FloatFieldUpdateOperationsInput | number
    hydration?: FloatFieldUpdateOperationsInput | number
    twitching?: FloatFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    calorie_est?: NullableIntFieldUpdateOperationsInput | number | null
    times_meals_more_than_gap_apart?: NullableIntFieldUpdateOperationsInput | number | null
    estHoursInExcessFast?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDiet?: DietUpdateOneWithoutHealthReportNestedInput
  }

  export type HealthReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    overall?: FloatFieldUpdateOperationsInput | number
    skin?: FloatFieldUpdateOperationsInput | number
    bloat?: FloatFieldUpdateOperationsInput | number
    weight_feeling?: FloatFieldUpdateOperationsInput | number
    fullness?: FloatFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cardiacCapacity?: FloatFieldUpdateOperationsInput | number
    jawLine?: FloatFieldUpdateOperationsInput | number
    joints?: FloatFieldUpdateOperationsInput | number
    flexibility?: FloatFieldUpdateOperationsInput | number
    anxiety?: FloatFieldUpdateOperationsInput | number
    anxiety_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: FloatFieldUpdateOperationsInput | number
    sexDrive?: FloatFieldUpdateOperationsInput | number
    intruisiveThoughts?: FloatFieldUpdateOperationsInput | number
    caffeineIntake?: FloatFieldUpdateOperationsInput | number
    glutenIntake?: FloatFieldUpdateOperationsInput | number
    sugarIntake?: FloatFieldUpdateOperationsInput | number
    artificialSweetenerIntake?: FloatFieldUpdateOperationsInput | number
    artificalDyes?: FloatFieldUpdateOperationsInput | number
    sleepQuality?: FloatFieldUpdateOperationsInput | number
    hydration?: FloatFieldUpdateOperationsInput | number
    twitching?: FloatFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    calorie_est?: NullableIntFieldUpdateOperationsInput | number | null
    times_meals_more_than_gap_apart?: NullableIntFieldUpdateOperationsInput | number | null
    estHoursInExcessFast?: NullableFloatFieldUpdateOperationsInput | number | null
    dietId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthReportCreateManyInput = {
    id?: number
    title?: string | null
    summary?: string | null
    overall?: number
    skin?: number
    bloat?: number
    weight_feeling?: number
    fullness?: number
    weight?: number | null
    cardiacCapacity?: number
    jawLine?: number
    joints?: number
    flexibility?: number
    anxiety?: number
    anxiety_desc?: string | null
    mood_desc?: string | null
    mood?: number
    sexDrive?: number
    intruisiveThoughts?: number
    caffeineIntake?: number
    glutenIntake?: number
    sugarIntake?: number
    artificialSweetenerIntake?: number
    artificalDyes?: number
    sleepQuality?: number
    hydration?: number
    twitching?: number
    sleepHours?: number | null
    calorie_est?: number | null
    times_meals_more_than_gap_apart?: number | null
    estHoursInExcessFast?: number | null
    dietId?: string | null
    created?: Date | string
  }

  export type HealthReportUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    overall?: FloatFieldUpdateOperationsInput | number
    skin?: FloatFieldUpdateOperationsInput | number
    bloat?: FloatFieldUpdateOperationsInput | number
    weight_feeling?: FloatFieldUpdateOperationsInput | number
    fullness?: FloatFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cardiacCapacity?: FloatFieldUpdateOperationsInput | number
    jawLine?: FloatFieldUpdateOperationsInput | number
    joints?: FloatFieldUpdateOperationsInput | number
    flexibility?: FloatFieldUpdateOperationsInput | number
    anxiety?: FloatFieldUpdateOperationsInput | number
    anxiety_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: FloatFieldUpdateOperationsInput | number
    sexDrive?: FloatFieldUpdateOperationsInput | number
    intruisiveThoughts?: FloatFieldUpdateOperationsInput | number
    caffeineIntake?: FloatFieldUpdateOperationsInput | number
    glutenIntake?: FloatFieldUpdateOperationsInput | number
    sugarIntake?: FloatFieldUpdateOperationsInput | number
    artificialSweetenerIntake?: FloatFieldUpdateOperationsInput | number
    artificalDyes?: FloatFieldUpdateOperationsInput | number
    sleepQuality?: FloatFieldUpdateOperationsInput | number
    hydration?: FloatFieldUpdateOperationsInput | number
    twitching?: FloatFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    calorie_est?: NullableIntFieldUpdateOperationsInput | number | null
    times_meals_more_than_gap_apart?: NullableIntFieldUpdateOperationsInput | number | null
    estHoursInExcessFast?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    overall?: FloatFieldUpdateOperationsInput | number
    skin?: FloatFieldUpdateOperationsInput | number
    bloat?: FloatFieldUpdateOperationsInput | number
    weight_feeling?: FloatFieldUpdateOperationsInput | number
    fullness?: FloatFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cardiacCapacity?: FloatFieldUpdateOperationsInput | number
    jawLine?: FloatFieldUpdateOperationsInput | number
    joints?: FloatFieldUpdateOperationsInput | number
    flexibility?: FloatFieldUpdateOperationsInput | number
    anxiety?: FloatFieldUpdateOperationsInput | number
    anxiety_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: FloatFieldUpdateOperationsInput | number
    sexDrive?: FloatFieldUpdateOperationsInput | number
    intruisiveThoughts?: FloatFieldUpdateOperationsInput | number
    caffeineIntake?: FloatFieldUpdateOperationsInput | number
    glutenIntake?: FloatFieldUpdateOperationsInput | number
    sugarIntake?: FloatFieldUpdateOperationsInput | number
    artificialSweetenerIntake?: FloatFieldUpdateOperationsInput | number
    artificalDyes?: FloatFieldUpdateOperationsInput | number
    sleepQuality?: FloatFieldUpdateOperationsInput | number
    hydration?: FloatFieldUpdateOperationsInput | number
    twitching?: FloatFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    calorie_est?: NullableIntFieldUpdateOperationsInput | number | null
    times_meals_more_than_gap_apart?: NullableIntFieldUpdateOperationsInput | number | null
    estHoursInExcessFast?: NullableFloatFieldUpdateOperationsInput | number | null
    dietId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhiteboardCreateInput = {
    id: string
    data: Buffer
  }

  export type WhiteboardUncheckedCreateInput = {
    id: string
    data: Buffer
  }

  export type WhiteboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type WhiteboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type WhiteboardCreateManyInput = {
    id: string
    data: Buffer
  }

  export type WhiteboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type WhiteboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type DJTCreateInput = {
    type: string
    data: Buffer
  }

  export type DJTUncheckedCreateInput = {
    id?: number
    type: string
    data: Buffer
  }

  export type DJTUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type DJTUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type DJTCreateManyInput = {
    id?: number
    type: string
    data: Buffer
  }

  export type DJTUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type DJTUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FeatureRequestOrderByRelevanceInput = {
    fields: FeatureRequestOrderByRelevanceFieldEnum | FeatureRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FeatureRequestCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    message?: SortOrder
    category?: SortOrder
    userBase?: SortOrder
    receivedOn?: SortOrder
  }

  export type FeatureRequestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FeatureRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    message?: SortOrder
    receivedOn?: SortOrder
  }

  export type FeatureRequestMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    message?: SortOrder
    receivedOn?: SortOrder
  }

  export type FeatureRequestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type WaitlistRequestOrderByRelevanceInput = {
    fields: WaitlistRequestOrderByRelevanceFieldEnum | WaitlistRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WaitlistRequestCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    receivedOn?: SortOrder
    emailsSent?: SortOrder
  }

  export type WaitlistRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    emailsSent?: SortOrder
  }

  export type WaitlistRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    receivedOn?: SortOrder
    emailsSent?: SortOrder
  }

  export type WaitlistRequestMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    receivedOn?: SortOrder
    emailsSent?: SortOrder
  }

  export type WaitlistRequestSumOrderByAggregateInput = {
    id?: SortOrder
    emailsSent?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MdxNoteListRelationFilter = {
    every?: MdxNoteWhereInput
    some?: MdxNoteWhereInput
    none?: MdxNoteWhereInput
  }

  export type IpynbListRelationFilter = {
    every?: IpynbWhereInput
    some?: IpynbWhereInput
    none?: IpynbWhereInput
  }

  export type QAPairListRelationFilter = {
    every?: QAPairWhereInput
    some?: QAPairWhereInput
    none?: QAPairWhereInput
  }

  export type PracticeExamListRelationFilter = {
    every?: PracticeExamWhereInput
    some?: PracticeExamWhereInput
    none?: PracticeExamWhereInput
  }

  export type KanbanNullableRelationFilter = {
    is?: KanbanWhereInput | null
    isNot?: KanbanWhereInput | null
  }

  export type ToDoListListRelationFilter = {
    every?: ToDoListWhereInput
    some?: ToDoListWhereInput
    none?: ToDoListWhereInput
  }

  export type ToDoListRelationFilter = {
    every?: ToDoWhereInput
    some?: ToDoWhereInput
    none?: ToDoWhereInput
  }

  export type BibEntryListRelationFilter = {
    every?: BibEntryWhereInput
    some?: BibEntryWhereInput
    none?: BibEntryWhereInput
  }

  export type EquationListRelationFilter = {
    every?: EquationWhereInput
    some?: EquationWhereInput
    none?: EquationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MdxNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IpynbOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QAPairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PracticeExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ToDoListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ToDoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BibEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelevanceInput = {
    fields: SubjectOrderByRelevanceFieldEnum | SubjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubjectCountOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    kanbanId?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    kanbanId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TopicOrderByRelevanceInput = {
    fields: TopicOrderByRelevanceFieldEnum | TopicOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TopicCountOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type TopicAvgOrderByAggregateInput = {
    kanbanId?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type TopicSumOrderByAggregateInput = {
    kanbanId?: SortOrder
  }

  export type TagOrderByRelevanceInput = {
    fields: TagOrderByRelevanceFieldEnum | TagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagCountOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    kanbanId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    value?: SortOrder
    kanbanId?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    kanbanId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QuoteOrderByRelevanceInput = {
    fields: QuoteOrderByRelevanceFieldEnum | QuoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QuoteCountOrderByAggregateInput = {
    body?: SortOrder
    author?: SortOrder
    source?: SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    body?: SortOrder
    author?: SortOrder
    source?: SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    body?: SortOrder
    author?: SortOrder
    source?: SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DailyFocusOrderByRelevanceInput = {
    fields: DailyFocusOrderByRelevanceFieldEnum | DailyFocusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DailyFocusCountOrderByAggregateInput = {
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyFocusMaxOrderByAggregateInput = {
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyFocusMinOrderByAggregateInput = {
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumautoSettingFilter<$PrismaModel = never> = {
    equals?: $Enums.autoSetting | EnumautoSettingFieldRefInput<$PrismaModel>
    in?: $Enums.autoSetting[] | ListEnumautoSettingFieldRefInput<$PrismaModel>
    notIn?: $Enums.autoSetting[] | ListEnumautoSettingFieldRefInput<$PrismaModel>
    not?: NestedEnumautoSettingFilter<$PrismaModel> | $Enums.autoSetting
  }

  export type AutoSettingOrderByRelevanceInput = {
    fields: AutoSettingOrderByRelevanceFieldEnum | AutoSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AutoSettingCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    glob?: SortOrder
    value?: SortOrder
  }

  export type AutoSettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AutoSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    glob?: SortOrder
    value?: SortOrder
  }

  export type AutoSettingMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    glob?: SortOrder
    value?: SortOrder
  }

  export type AutoSettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumautoSettingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.autoSetting | EnumautoSettingFieldRefInput<$PrismaModel>
    in?: $Enums.autoSetting[] | ListEnumautoSettingFieldRefInput<$PrismaModel>
    notIn?: $Enums.autoSetting[] | ListEnumautoSettingFieldRefInput<$PrismaModel>
    not?: NestedEnumautoSettingWithAggregatesFilter<$PrismaModel> | $Enums.autoSetting
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumautoSettingFilter<$PrismaModel>
    _max?: NestedEnumautoSettingFilter<$PrismaModel>
  }

  export type ReadingListOrderByRelevanceInput = {
    fields: ReadingListOrderByRelevanceFieldEnum | ReadingListOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReadingListCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type ReadingListMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type ReadingListMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type BibNullableRelationFilter = {
    is?: BibWhereInput | null
    isNot?: BibWhereInput | null
  }

  export type CitationsGroupListRelationFilter = {
    every?: CitationsGroupWhereInput
    some?: CitationsGroupWhereInput
    none?: CitationsGroupWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type ReadingListListRelationFilter = {
    every?: ReadingListWhereInput
    some?: ReadingListWhereInput
    none?: ReadingListWhereInput
  }

  export type CitationsGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReadingListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BibEntryOrderByRelevanceInput = {
    fields: BibEntryOrderByRelevanceFieldEnum | BibEntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BibEntryCountOrderByAggregateInput = {
    id?: SortOrder
    BibId?: SortOrder
    OwnWork?: SortOrder
    ColleaguesWork?: SortOrder
    read?: SortOrder
    htmlCitation?: SortOrder
    PdfPath?: SortOrder
    address?: SortOrder
    annote?: SortOrder
    author?: SortOrder
    booktitle?: SortOrder
    chapter?: SortOrder
    crossref?: SortOrder
    doi?: SortOrder
    edition?: SortOrder
    editor?: SortOrder
    email?: SortOrder
    howpublished?: SortOrder
    institution?: SortOrder
    journal?: SortOrder
    month?: SortOrder
    note?: SortOrder
    number?: SortOrder
    organization?: SortOrder
    pages?: SortOrder
    publisher?: SortOrder
    school?: SortOrder
    series?: SortOrder
    title?: SortOrder
    volume?: SortOrder
    type?: SortOrder
    year?: SortOrder
    numpages?: SortOrder
    url?: SortOrder
    issue?: SortOrder
    issn?: SortOrder
    abstract?: SortOrder
    urldate?: SortOrder
    keywords?: SortOrder
    copyright?: SortOrder
    added?: SortOrder
  }

  export type BibEntryAvgOrderByAggregateInput = {
    BibId?: SortOrder
  }

  export type BibEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    BibId?: SortOrder
    OwnWork?: SortOrder
    ColleaguesWork?: SortOrder
    read?: SortOrder
    htmlCitation?: SortOrder
    PdfPath?: SortOrder
    address?: SortOrder
    annote?: SortOrder
    author?: SortOrder
    booktitle?: SortOrder
    chapter?: SortOrder
    crossref?: SortOrder
    doi?: SortOrder
    edition?: SortOrder
    editor?: SortOrder
    email?: SortOrder
    howpublished?: SortOrder
    institution?: SortOrder
    journal?: SortOrder
    month?: SortOrder
    note?: SortOrder
    number?: SortOrder
    organization?: SortOrder
    pages?: SortOrder
    publisher?: SortOrder
    school?: SortOrder
    series?: SortOrder
    title?: SortOrder
    volume?: SortOrder
    type?: SortOrder
    year?: SortOrder
    numpages?: SortOrder
    url?: SortOrder
    issue?: SortOrder
    issn?: SortOrder
    abstract?: SortOrder
    urldate?: SortOrder
    keywords?: SortOrder
    copyright?: SortOrder
    added?: SortOrder
  }

  export type BibEntryMinOrderByAggregateInput = {
    id?: SortOrder
    BibId?: SortOrder
    OwnWork?: SortOrder
    ColleaguesWork?: SortOrder
    read?: SortOrder
    htmlCitation?: SortOrder
    PdfPath?: SortOrder
    address?: SortOrder
    annote?: SortOrder
    author?: SortOrder
    booktitle?: SortOrder
    chapter?: SortOrder
    crossref?: SortOrder
    doi?: SortOrder
    edition?: SortOrder
    editor?: SortOrder
    email?: SortOrder
    howpublished?: SortOrder
    institution?: SortOrder
    journal?: SortOrder
    month?: SortOrder
    note?: SortOrder
    number?: SortOrder
    organization?: SortOrder
    pages?: SortOrder
    publisher?: SortOrder
    school?: SortOrder
    series?: SortOrder
    title?: SortOrder
    volume?: SortOrder
    type?: SortOrder
    year?: SortOrder
    numpages?: SortOrder
    url?: SortOrder
    issue?: SortOrder
    issn?: SortOrder
    abstract?: SortOrder
    urldate?: SortOrder
    keywords?: SortOrder
    copyright?: SortOrder
    added?: SortOrder
  }

  export type BibEntrySumOrderByAggregateInput = {
    BibId?: SortOrder
  }

  export type CitationsGroupOrderByRelevanceInput = {
    fields: CitationsGroupOrderByRelevanceFieldEnum | CitationsGroupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CitationsGroupCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
  }

  export type CitationsGroupMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
  }

  export type CitationsGroupMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
  }

  export type BibOrderByRelevanceInput = {
    fields: BibOrderByRelevanceFieldEnum | BibOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BibCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type BibAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BibMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type BibMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type BibSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GoogleCalendarAuthOrderByRelevanceInput = {
    fields: GoogleCalendarAuthOrderByRelevanceFieldEnum | GoogleCalendarAuthOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GoogleCalendarAuthCountOrderByAggregateInput = {
    id?: SortOrder
    auth?: SortOrder
  }

  export type GoogleCalendarAuthAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GoogleCalendarAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    auth?: SortOrder
  }

  export type GoogleCalendarAuthMinOrderByAggregateInput = {
    id?: SortOrder
    auth?: SortOrder
  }

  export type GoogleCalendarAuthSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTechnologiesFilter<$PrismaModel = never> = {
    equals?: $Enums.Technologies | EnumTechnologiesFieldRefInput<$PrismaModel>
    in?: $Enums.Technologies[] | ListEnumTechnologiesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Technologies[] | ListEnumTechnologiesFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnologiesFilter<$PrismaModel> | $Enums.Technologies
  }

  export type SnippetOrderByRelevanceInput = {
    fields: SnippetOrderByRelevanceFieldEnum | SnippetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SnippetCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    language?: SortOrder
  }

  export type SnippetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SnippetMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    description?: SortOrder
    language?: SortOrder
  }

  export type SnippetMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    description?: SortOrder
    language?: SortOrder
  }

  export type SnippetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTechnologiesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Technologies | EnumTechnologiesFieldRefInput<$PrismaModel>
    in?: $Enums.Technologies[] | ListEnumTechnologiesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Technologies[] | ListEnumTechnologiesFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnologiesWithAggregatesFilter<$PrismaModel> | $Enums.Technologies
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechnologiesFilter<$PrismaModel>
    _max?: NestedEnumTechnologiesFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type RelatedValuesCountOrderByAggregateInput = {
    id?: SortOrder
    input?: SortOrder
    output?: SortOrder
    equationId?: SortOrder
  }

  export type RelatedValuesAvgOrderByAggregateInput = {
    id?: SortOrder
    output?: SortOrder
    equationId?: SortOrder
  }

  export type RelatedValuesMaxOrderByAggregateInput = {
    id?: SortOrder
    output?: SortOrder
  }

  export type RelatedValuesMinOrderByAggregateInput = {
    id?: SortOrder
    output?: SortOrder
  }

  export type RelatedValuesSumOrderByAggregateInput = {
    id?: SortOrder
    output?: SortOrder
    equationId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RelatedValuesListRelationFilter = {
    every?: RelatedValuesWhereInput
    some?: RelatedValuesWhereInput
    none?: RelatedValuesWhereInput
  }

  export type RelatedValuesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquationOrderByRelevanceInput = {
    fields: EquationOrderByRelevanceFieldEnum | EquationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EquationCountOrderByAggregateInput = {
    id?: SortOrder
    equationId?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    content?: SortOrder
    asPython?: SortOrder
    variableLegend?: SortOrder
    variables?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
  }

  export type EquationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EquationMaxOrderByAggregateInput = {
    id?: SortOrder
    equationId?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    content?: SortOrder
    asPython?: SortOrder
    createdAt?: SortOrder
  }

  export type EquationMinOrderByAggregateInput = {
    id?: SortOrder
    equationId?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    content?: SortOrder
    asPython?: SortOrder
    createdAt?: SortOrder
  }

  export type EquationSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MdxNoteNullableRelationFilter = {
    is?: MdxNoteWhereInput | null
    isNot?: MdxNoteWhereInput | null
  }

  export type DefinitionOrderByRelevanceInput = {
    fields: DefinitionOrderByRelevanceFieldEnum | DefinitionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    content?: SortOrder
    alphabeticalLabel?: SortOrder
    mdxNoteId?: SortOrder
  }

  export type DefinitionAvgOrderByAggregateInput = {
    mdxNoteId?: SortOrder
  }

  export type DefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    content?: SortOrder
    alphabeticalLabel?: SortOrder
    mdxNoteId?: SortOrder
  }

  export type DefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    content?: SortOrder
    alphabeticalLabel?: SortOrder
    mdxNoteId?: SortOrder
  }

  export type DefinitionSumOrderByAggregateInput = {
    mdxNoteId?: SortOrder
  }

  export type EnumImageAlignmentFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageAlignment | EnumImageAlignmentFieldRefInput<$PrismaModel>
    in?: $Enums.ImageAlignment[] | ListEnumImageAlignmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageAlignment[] | ListEnumImageAlignmentFieldRefInput<$PrismaModel>
    not?: NestedEnumImageAlignmentFilter<$PrismaModel> | $Enums.ImageAlignment
  }

  export type SettingsOrderByRelevanceInput = {
    fields: SettingsOrderByRelevanceFieldEnum | SettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    tooltips?: SortOrder
    title?: SortOrder
    summary_showCitations?: SortOrder
    summary_showTags?: SortOrder
    landingImageAlign?: SortOrder
    lockedLandingImage?: SortOrder
    cleanOnSync?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    tooltips?: SortOrder
    title?: SortOrder
    summary_showCitations?: SortOrder
    summary_showTags?: SortOrder
    landingImageAlign?: SortOrder
    lockedLandingImage?: SortOrder
    cleanOnSync?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    tooltips?: SortOrder
    title?: SortOrder
    summary_showCitations?: SortOrder
    summary_showTags?: SortOrder
    landingImageAlign?: SortOrder
    lockedLandingImage?: SortOrder
    cleanOnSync?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumImageAlignmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageAlignment | EnumImageAlignmentFieldRefInput<$PrismaModel>
    in?: $Enums.ImageAlignment[] | ListEnumImageAlignmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageAlignment[] | ListEnumImageAlignmentFieldRefInput<$PrismaModel>
    not?: NestedEnumImageAlignmentWithAggregatesFilter<$PrismaModel> | $Enums.ImageAlignment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageAlignmentFilter<$PrismaModel>
    _max?: NestedEnumImageAlignmentFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type SettingsAppendixOrderByRelevanceInput = {
    fields: SettingsAppendixOrderByRelevanceFieldEnum | SettingsAppendixOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SettingsAppendixCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsAppendixMaxOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsAppendixMinOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type RandomImageOrderByRelevanceInput = {
    fields: RandomImageOrderByRelevanceFieldEnum | RandomImageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RandomImageCountOrderByAggregateInput = {
    path?: SortOrder
    createdAt?: SortOrder
  }

  export type RandomImageMaxOrderByAggregateInput = {
    path?: SortOrder
    createdAt?: SortOrder
  }

  export type RandomImageMinOrderByAggregateInput = {
    path?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteTypeOrderByRelevanceInput = {
    fields: NoteTypeOrderByRelevanceFieldEnum | NoteTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NoteTypeCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type NoteTypeMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type NoteTypeMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type QAPairOrderByRelevanceInput = {
    fields: QAPairOrderByRelevanceFieldEnum | QAPairOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QAPairCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    description?: SortOrder
    secondaryLabel?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
  }

  export type QAPairAvgOrderByAggregateInput = {
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
  }

  export type QAPairMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    description?: SortOrder
    secondaryLabel?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
  }

  export type QAPairMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    description?: SortOrder
    secondaryLabel?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
  }

  export type QAPairSumOrderByAggregateInput = {
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
  }

  export type PracticeExamCountOrderByAggregateInput = {
    id?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    timeLimitInSeconds?: SortOrder
    timeCompletedInSeconds?: SortOrder
    date?: SortOrder
  }

  export type PracticeExamAvgOrderByAggregateInput = {
    id?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    timeLimitInSeconds?: SortOrder
    timeCompletedInSeconds?: SortOrder
  }

  export type PracticeExamMaxOrderByAggregateInput = {
    id?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    timeLimitInSeconds?: SortOrder
    timeCompletedInSeconds?: SortOrder
    date?: SortOrder
  }

  export type PracticeExamMinOrderByAggregateInput = {
    id?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    timeLimitInSeconds?: SortOrder
    timeCompletedInSeconds?: SortOrder
    date?: SortOrder
  }

  export type PracticeExamSumOrderByAggregateInput = {
    id?: SortOrder
    correctCount?: SortOrder
    inCorrectCount?: SortOrder
    timeLimitInSeconds?: SortOrder
    timeCompletedInSeconds?: SortOrder
  }

  export type SequentialNoteListOrderByRelevanceInput = {
    fields: SequentialNoteListOrderByRelevanceFieldEnum | SequentialNoteListOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SequentialNoteListCountOrderByAggregateInput = {
    sequentialKey?: SortOrder
  }

  export type SequentialNoteListMaxOrderByAggregateInput = {
    sequentialKey?: SortOrder
  }

  export type SequentialNoteListMinOrderByAggregateInput = {
    sequentialKey?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    has?: number | FloatFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListFloatFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListFloatFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SequentialNoteListNullableRelationFilter = {
    is?: SequentialNoteListWhereInput | null
    isNot?: SequentialNoteListWhereInput | null
  }

  export type DefinitionListRelationFilter = {
    every?: DefinitionWhereInput
    some?: DefinitionWhereInput
    none?: DefinitionWhereInput
  }

  export type DefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MdxNoteOrderByRelevanceInput = {
    fields: MdxNoteOrderByRelevanceFieldEnum | MdxNoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MdxNoteCountOrderByAggregateInput = {
    id?: SortOrder
    isProtected?: SortOrder
    dietSummaryKey?: SortOrder
    title?: SortOrder
    latexTitle?: SortOrder
    rootRelativePath?: SortOrder
    noteType?: SortOrder
    content?: SortOrder
    formatted?: SortOrder
    summary?: SortOrder
    citationsListOrder?: SortOrder
    importantValues?: SortOrder
    imageSrc?: SortOrder
    href?: SortOrder
    sequentialKey?: SortOrder
    sequentialIndex?: SortOrder
    floatImages?: SortOrder
    remoteUrl?: SortOrder
    trackRemote?: SortOrder
    outgoingQuickLinks?: SortOrder
    quickLink?: SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type MdxNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    importantValues?: SortOrder
    sequentialIndex?: SortOrder
  }

  export type MdxNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    isProtected?: SortOrder
    dietSummaryKey?: SortOrder
    title?: SortOrder
    latexTitle?: SortOrder
    rootRelativePath?: SortOrder
    noteType?: SortOrder
    content?: SortOrder
    formatted?: SortOrder
    summary?: SortOrder
    imageSrc?: SortOrder
    href?: SortOrder
    sequentialKey?: SortOrder
    sequentialIndex?: SortOrder
    floatImages?: SortOrder
    remoteUrl?: SortOrder
    trackRemote?: SortOrder
    quickLink?: SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type MdxNoteMinOrderByAggregateInput = {
    id?: SortOrder
    isProtected?: SortOrder
    dietSummaryKey?: SortOrder
    title?: SortOrder
    latexTitle?: SortOrder
    rootRelativePath?: SortOrder
    noteType?: SortOrder
    content?: SortOrder
    formatted?: SortOrder
    summary?: SortOrder
    imageSrc?: SortOrder
    href?: SortOrder
    sequentialKey?: SortOrder
    sequentialIndex?: SortOrder
    floatImages?: SortOrder
    remoteUrl?: SortOrder
    trackRemote?: SortOrder
    quickLink?: SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type MdxNoteSumOrderByAggregateInput = {
    id?: SortOrder
    importantValues?: SortOrder
    sequentialIndex?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IpynbOrderByRelevanceInput = {
    fields: IpynbOrderByRelevanceFieldEnum | IpynbOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type IpynbCountOrderByAggregateInput = {
    id?: SortOrder
    rootRelativePath?: SortOrder
    isProtected?: SortOrder
    title?: SortOrder
    latexTitle?: SortOrder
    citationsListOrder?: SortOrder
    importantValues?: SortOrder
    href?: SortOrder
    outgoingQuickLinks?: SortOrder
    raw?: SortOrder
    sequentialKey?: SortOrder
    sequentialIndex?: SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type IpynbAvgOrderByAggregateInput = {
    id?: SortOrder
    importantValues?: SortOrder
    sequentialIndex?: SortOrder
  }

  export type IpynbMaxOrderByAggregateInput = {
    id?: SortOrder
    rootRelativePath?: SortOrder
    isProtected?: SortOrder
    title?: SortOrder
    latexTitle?: SortOrder
    href?: SortOrder
    raw?: SortOrder
    sequentialKey?: SortOrder
    sequentialIndex?: SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type IpynbMinOrderByAggregateInput = {
    id?: SortOrder
    rootRelativePath?: SortOrder
    isProtected?: SortOrder
    title?: SortOrder
    latexTitle?: SortOrder
    href?: SortOrder
    raw?: SortOrder
    sequentialKey?: SortOrder
    sequentialIndex?: SortOrder
    bookmarked?: SortOrder
    firstSync?: SortOrder
    lastSync?: SortOrder
  }

  export type IpynbSumOrderByAggregateInput = {
    id?: SortOrder
    importantValues?: SortOrder
    sequentialIndex?: SortOrder
  }

  export type ToDoListOrderByRelevanceInput = {
    fields: ToDoListOrderByRelevanceFieldEnum | ToDoListOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ToDoListCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type ToDoListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ToDoListMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type ToDoListMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type ToDoListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumTaskCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCategory | EnumTaskCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskCategoryNullableFilter<$PrismaModel> | $Enums.TaskCategory | null
  }

  export type EnumToDoListStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ToDoListStatus | EnumToDoListStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ToDoListStatus[] | ListEnumToDoListStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ToDoListStatus[] | ListEnumToDoListStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumToDoListStatusFilter<$PrismaModel> | $Enums.ToDoListStatus
  }

  export type ToDoNullableRelationFilter = {
    is?: ToDoWhereInput | null
    isNot?: ToDoWhereInput | null
  }

  export type ToDoListNullableRelationFilter = {
    is?: ToDoListWhereInput | null
    isNot?: ToDoListWhereInput | null
  }

  export type ToDoOrderByRelevanceInput = {
    fields: ToDoOrderByRelevanceFieldEnum | ToDoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ToDoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    task?: SortOrder
    dueAt?: SortOrder
    details?: SortOrder
    parentId?: SortOrder
    category?: SortOrder
    bookmarked?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    toDoListId?: SortOrder
  }

  export type ToDoAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    priority?: SortOrder
    toDoListId?: SortOrder
  }

  export type ToDoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    task?: SortOrder
    dueAt?: SortOrder
    details?: SortOrder
    parentId?: SortOrder
    category?: SortOrder
    bookmarked?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    toDoListId?: SortOrder
  }

  export type ToDoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    task?: SortOrder
    dueAt?: SortOrder
    details?: SortOrder
    parentId?: SortOrder
    category?: SortOrder
    bookmarked?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    toDoListId?: SortOrder
  }

  export type ToDoSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    priority?: SortOrder
    toDoListId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTaskCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCategory | EnumTaskCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskCategoryNullableFilter<$PrismaModel>
  }

  export type EnumToDoListStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ToDoListStatus | EnumToDoListStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ToDoListStatus[] | ListEnumToDoListStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ToDoListStatus[] | ListEnumToDoListStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumToDoListStatusWithAggregatesFilter<$PrismaModel> | $Enums.ToDoListStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumToDoListStatusFilter<$PrismaModel>
    _max?: NestedEnumToDoListStatusFilter<$PrismaModel>
  }

  export type KanBanListNullableRelationFilter = {
    is?: KanBanListWhereInput | null
    isNot?: KanBanListWhereInput | null
  }

  export type KanBanCardOrderByRelevanceInput = {
    fields: KanBanCardOrderByRelevanceFieldEnum | KanBanCardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type KanBanCardCountOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    indexWithinList?: SortOrder
    label?: SortOrder
    details?: SortOrder
  }

  export type KanBanCardAvgOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    indexWithinList?: SortOrder
  }

  export type KanBanCardMaxOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    indexWithinList?: SortOrder
    label?: SortOrder
    details?: SortOrder
  }

  export type KanBanCardMinOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    indexWithinList?: SortOrder
    label?: SortOrder
    details?: SortOrder
  }

  export type KanBanCardSumOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    indexWithinList?: SortOrder
  }

  export type KanBanCardListRelationFilter = {
    every?: KanBanCardWhereInput
    some?: KanBanCardWhereInput
    none?: KanBanCardWhereInput
  }

  export type KanBanCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KanBanListOrderByRelevanceInput = {
    fields: KanBanListOrderByRelevanceFieldEnum | KanBanListOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type KanBanListCountOrderByAggregateInput = {
    id?: SortOrder
    indexWithinBoard?: SortOrder
    title?: SortOrder
    boardId?: SortOrder
  }

  export type KanBanListAvgOrderByAggregateInput = {
    id?: SortOrder
    indexWithinBoard?: SortOrder
    boardId?: SortOrder
  }

  export type KanBanListMaxOrderByAggregateInput = {
    id?: SortOrder
    indexWithinBoard?: SortOrder
    title?: SortOrder
    boardId?: SortOrder
  }

  export type KanBanListMinOrderByAggregateInput = {
    id?: SortOrder
    indexWithinBoard?: SortOrder
    title?: SortOrder
    boardId?: SortOrder
  }

  export type KanBanListSumOrderByAggregateInput = {
    id?: SortOrder
    indexWithinBoard?: SortOrder
    boardId?: SortOrder
  }

  export type KanBanListListRelationFilter = {
    every?: KanBanListWhereInput
    some?: KanBanListWhereInput
    none?: KanBanListWhereInput
  }

  export type KanBanListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KanbanOrderByRelevanceInput = {
    fields: KanbanOrderByRelevanceFieldEnum | KanbanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type KanbanCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type KanbanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KanbanMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type KanbanMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    lastUpdate?: SortOrder
  }

  export type KanbanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DietNullableRelationFilter = {
    is?: DietWhereInput | null
    isNot?: DietWhereInput | null
  }

  export type TimePeriodOrderByRelevanceInput = {
    fields: TimePeriodOrderByRelevanceFieldEnum | TimePeriodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TimePeriodCountOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    dietId?: SortOrder
  }

  export type TimePeriodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TimePeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    dietId?: SortOrder
  }

  export type TimePeriodMinOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    dietId?: SortOrder
  }

  export type TimePeriodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTERTIARY_TOGGLEFilter<$PrismaModel = never> = {
    equals?: $Enums.TERTIARY_TOGGLE | EnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    in?: $Enums.TERTIARY_TOGGLE[] | ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    notIn?: $Enums.TERTIARY_TOGGLE[] | ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    not?: NestedEnumTERTIARY_TOGGLEFilter<$PrismaModel> | $Enums.TERTIARY_TOGGLE
  }

  export type EnumDIETARY_GOALNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.DIETARY_GOAL[] | ListEnumDIETARY_GOALFieldRefInput<$PrismaModel> | null
    has?: $Enums.DIETARY_GOAL | EnumDIETARY_GOALFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.DIETARY_GOAL[] | ListEnumDIETARY_GOALFieldRefInput<$PrismaModel>
    hasSome?: $Enums.DIETARY_GOAL[] | ListEnumDIETARY_GOALFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DietaryItemListRelationFilter = {
    every?: DietaryItemWhereInput
    some?: DietaryItemWhereInput
    none?: DietaryItemWhereInput
  }

  export type TimePeriodListRelationFilter = {
    every?: TimePeriodWhereInput
    some?: TimePeriodWhereInput
    none?: TimePeriodWhereInput
  }

  export type HealthReportListRelationFilter = {
    every?: HealthReportWhereInput
    some?: HealthReportWhereInput
    none?: HealthReportWhereInput
  }

  export type DietaryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimePeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DietOrderByRelevanceInput = {
    fields: DietOrderByRelevanceFieldEnum | DietOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DietCountOrderByAggregateInput = {
    name?: SortOrder
    summary?: SortOrder
    activelyFollowing?: SortOrder
    gf?: SortOrder
    vegan?: SortOrder
    pescatarian?: SortOrder
    vegetarian?: SortOrder
    fasting?: SortOrder
    cardioTraining?: SortOrder
    weightTraining?: SortOrder
    carb?: SortOrder
    pro?: SortOrder
    fat?: SortOrder
    goals?: SortOrder
    created?: SortOrder
    lastUpdate?: SortOrder
  }

  export type DietAvgOrderByAggregateInput = {
    carb?: SortOrder
    pro?: SortOrder
    fat?: SortOrder
  }

  export type DietMaxOrderByAggregateInput = {
    name?: SortOrder
    summary?: SortOrder
    activelyFollowing?: SortOrder
    gf?: SortOrder
    vegan?: SortOrder
    pescatarian?: SortOrder
    vegetarian?: SortOrder
    fasting?: SortOrder
    cardioTraining?: SortOrder
    weightTraining?: SortOrder
    carb?: SortOrder
    pro?: SortOrder
    fat?: SortOrder
    created?: SortOrder
    lastUpdate?: SortOrder
  }

  export type DietMinOrderByAggregateInput = {
    name?: SortOrder
    summary?: SortOrder
    activelyFollowing?: SortOrder
    gf?: SortOrder
    vegan?: SortOrder
    pescatarian?: SortOrder
    vegetarian?: SortOrder
    fasting?: SortOrder
    cardioTraining?: SortOrder
    weightTraining?: SortOrder
    carb?: SortOrder
    pro?: SortOrder
    fat?: SortOrder
    created?: SortOrder
    lastUpdate?: SortOrder
  }

  export type DietSumOrderByAggregateInput = {
    carb?: SortOrder
    pro?: SortOrder
    fat?: SortOrder
  }

  export type EnumTERTIARY_TOGGLEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TERTIARY_TOGGLE | EnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    in?: $Enums.TERTIARY_TOGGLE[] | ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    notIn?: $Enums.TERTIARY_TOGGLE[] | ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    not?: NestedEnumTERTIARY_TOGGLEWithAggregatesFilter<$PrismaModel> | $Enums.TERTIARY_TOGGLE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTERTIARY_TOGGLEFilter<$PrismaModel>
    _max?: NestedEnumTERTIARY_TOGGLEFilter<$PrismaModel>
  }

  export type EnumQUANTITY_GUESSNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.QUANTITY_GUESS | EnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    in?: $Enums.QUANTITY_GUESS[] | ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QUANTITY_GUESS[] | ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQUANTITY_GUESSNullableFilter<$PrismaModel> | $Enums.QUANTITY_GUESS | null
  }

  export type DietaryItemRelationFilter = {
    is?: DietaryItemWhereInput
    isNot?: DietaryItemWhereInput
  }

  export type ServingCountOrderByAggregateInput = {
    id?: SortOrder
    dietaryItemId?: SortOrder
    quant_oz?: SortOrder
    quant_guess?: SortOrder
  }

  export type ServingAvgOrderByAggregateInput = {
    id?: SortOrder
    dietaryItemId?: SortOrder
    quant_oz?: SortOrder
  }

  export type ServingMaxOrderByAggregateInput = {
    id?: SortOrder
    dietaryItemId?: SortOrder
    quant_oz?: SortOrder
    quant_guess?: SortOrder
  }

  export type ServingMinOrderByAggregateInput = {
    id?: SortOrder
    dietaryItemId?: SortOrder
    quant_oz?: SortOrder
    quant_guess?: SortOrder
  }

  export type ServingSumOrderByAggregateInput = {
    id?: SortOrder
    dietaryItemId?: SortOrder
    quant_oz?: SortOrder
  }

  export type EnumQUANTITY_GUESSNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QUANTITY_GUESS | EnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    in?: $Enums.QUANTITY_GUESS[] | ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QUANTITY_GUESS[] | ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQUANTITY_GUESSNullableWithAggregatesFilter<$PrismaModel> | $Enums.QUANTITY_GUESS | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumQUANTITY_GUESSNullableFilter<$PrismaModel>
    _max?: NestedEnumQUANTITY_GUESSNullableFilter<$PrismaModel>
  }

  export type DietListRelationFilter = {
    every?: DietWhereInput
    some?: DietWhereInput
    none?: DietWhereInput
  }

  export type ServingListRelationFilter = {
    every?: ServingWhereInput
    some?: ServingWhereInput
    none?: ServingWhereInput
  }

  export type DietOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DietaryItemOrderByRelevanceInput = {
    fields: DietaryItemOrderByRelevanceFieldEnum | DietaryItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DietaryItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    gi?: SortOrder
    calsPerOz?: SortOrder
    glutenFree?: SortOrder
    minimalFructose?: SortOrder
    natural?: SortOrder
    organic?: SortOrder
    impactScore?: SortOrder
  }

  export type DietaryItemAvgOrderByAggregateInput = {
    id?: SortOrder
    gi?: SortOrder
    calsPerOz?: SortOrder
    impactScore?: SortOrder
  }

  export type DietaryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    gi?: SortOrder
    calsPerOz?: SortOrder
    glutenFree?: SortOrder
    minimalFructose?: SortOrder
    natural?: SortOrder
    organic?: SortOrder
    impactScore?: SortOrder
  }

  export type DietaryItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    gi?: SortOrder
    calsPerOz?: SortOrder
    glutenFree?: SortOrder
    minimalFructose?: SortOrder
    natural?: SortOrder
    organic?: SortOrder
    impactScore?: SortOrder
  }

  export type DietaryItemSumOrderByAggregateInput = {
    id?: SortOrder
    gi?: SortOrder
    calsPerOz?: SortOrder
    impactScore?: SortOrder
  }

  export type HealthReportOrderByRelevanceInput = {
    fields: HealthReportOrderByRelevanceFieldEnum | HealthReportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HealthReportCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    overall?: SortOrder
    skin?: SortOrder
    bloat?: SortOrder
    weight_feeling?: SortOrder
    fullness?: SortOrder
    weight?: SortOrder
    cardiacCapacity?: SortOrder
    jawLine?: SortOrder
    joints?: SortOrder
    flexibility?: SortOrder
    anxiety?: SortOrder
    anxiety_desc?: SortOrder
    mood_desc?: SortOrder
    mood?: SortOrder
    sexDrive?: SortOrder
    intruisiveThoughts?: SortOrder
    caffeineIntake?: SortOrder
    glutenIntake?: SortOrder
    sugarIntake?: SortOrder
    artificialSweetenerIntake?: SortOrder
    artificalDyes?: SortOrder
    sleepQuality?: SortOrder
    hydration?: SortOrder
    twitching?: SortOrder
    sleepHours?: SortOrder
    calorie_est?: SortOrder
    times_meals_more_than_gap_apart?: SortOrder
    estHoursInExcessFast?: SortOrder
    dietId?: SortOrder
    created?: SortOrder
  }

  export type HealthReportAvgOrderByAggregateInput = {
    id?: SortOrder
    overall?: SortOrder
    skin?: SortOrder
    bloat?: SortOrder
    weight_feeling?: SortOrder
    fullness?: SortOrder
    weight?: SortOrder
    cardiacCapacity?: SortOrder
    jawLine?: SortOrder
    joints?: SortOrder
    flexibility?: SortOrder
    anxiety?: SortOrder
    mood?: SortOrder
    sexDrive?: SortOrder
    intruisiveThoughts?: SortOrder
    caffeineIntake?: SortOrder
    glutenIntake?: SortOrder
    sugarIntake?: SortOrder
    artificialSweetenerIntake?: SortOrder
    artificalDyes?: SortOrder
    sleepQuality?: SortOrder
    hydration?: SortOrder
    twitching?: SortOrder
    sleepHours?: SortOrder
    calorie_est?: SortOrder
    times_meals_more_than_gap_apart?: SortOrder
    estHoursInExcessFast?: SortOrder
  }

  export type HealthReportMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    overall?: SortOrder
    skin?: SortOrder
    bloat?: SortOrder
    weight_feeling?: SortOrder
    fullness?: SortOrder
    weight?: SortOrder
    cardiacCapacity?: SortOrder
    jawLine?: SortOrder
    joints?: SortOrder
    flexibility?: SortOrder
    anxiety?: SortOrder
    anxiety_desc?: SortOrder
    mood_desc?: SortOrder
    mood?: SortOrder
    sexDrive?: SortOrder
    intruisiveThoughts?: SortOrder
    caffeineIntake?: SortOrder
    glutenIntake?: SortOrder
    sugarIntake?: SortOrder
    artificialSweetenerIntake?: SortOrder
    artificalDyes?: SortOrder
    sleepQuality?: SortOrder
    hydration?: SortOrder
    twitching?: SortOrder
    sleepHours?: SortOrder
    calorie_est?: SortOrder
    times_meals_more_than_gap_apart?: SortOrder
    estHoursInExcessFast?: SortOrder
    dietId?: SortOrder
    created?: SortOrder
  }

  export type HealthReportMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    overall?: SortOrder
    skin?: SortOrder
    bloat?: SortOrder
    weight_feeling?: SortOrder
    fullness?: SortOrder
    weight?: SortOrder
    cardiacCapacity?: SortOrder
    jawLine?: SortOrder
    joints?: SortOrder
    flexibility?: SortOrder
    anxiety?: SortOrder
    anxiety_desc?: SortOrder
    mood_desc?: SortOrder
    mood?: SortOrder
    sexDrive?: SortOrder
    intruisiveThoughts?: SortOrder
    caffeineIntake?: SortOrder
    glutenIntake?: SortOrder
    sugarIntake?: SortOrder
    artificialSweetenerIntake?: SortOrder
    artificalDyes?: SortOrder
    sleepQuality?: SortOrder
    hydration?: SortOrder
    twitching?: SortOrder
    sleepHours?: SortOrder
    calorie_est?: SortOrder
    times_meals_more_than_gap_apart?: SortOrder
    estHoursInExcessFast?: SortOrder
    dietId?: SortOrder
    created?: SortOrder
  }

  export type HealthReportSumOrderByAggregateInput = {
    id?: SortOrder
    overall?: SortOrder
    skin?: SortOrder
    bloat?: SortOrder
    weight_feeling?: SortOrder
    fullness?: SortOrder
    weight?: SortOrder
    cardiacCapacity?: SortOrder
    jawLine?: SortOrder
    joints?: SortOrder
    flexibility?: SortOrder
    anxiety?: SortOrder
    mood?: SortOrder
    sexDrive?: SortOrder
    intruisiveThoughts?: SortOrder
    caffeineIntake?: SortOrder
    glutenIntake?: SortOrder
    sugarIntake?: SortOrder
    artificialSweetenerIntake?: SortOrder
    artificalDyes?: SortOrder
    sleepQuality?: SortOrder
    hydration?: SortOrder
    twitching?: SortOrder
    sleepHours?: SortOrder
    calorie_est?: SortOrder
    times_meals_more_than_gap_apart?: SortOrder
    estHoursInExcessFast?: SortOrder
  }

  export type WhiteboardOrderByRelevanceInput = {
    fields: WhiteboardOrderByRelevanceFieldEnum | WhiteboardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WhiteboardCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
  }

  export type WhiteboardMaxOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
  }

  export type WhiteboardMinOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
  }

  export type DJTOrderByRelevanceInput = {
    fields: DJTOrderByRelevanceFieldEnum | DJTOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DJTCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
  }

  export type DJTAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DJTMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
  }

  export type DJTMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
  }

  export type DJTSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FeatureRequestCreatecategoryInput = {
    set: string[]
  }

  export type FeatureRequestCreateuserBaseInput = {
    set: string[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FeatureRequestUpdatecategoryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FeatureRequestUpdateuserBaseInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MdxNoteCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<MdxNoteCreateWithoutSubjectsInput, MdxNoteUncheckedCreateWithoutSubjectsInput> | MdxNoteCreateWithoutSubjectsInput[] | MdxNoteUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutSubjectsInput | MdxNoteCreateOrConnectWithoutSubjectsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<IpynbCreateWithoutSubjectsInput, IpynbUncheckedCreateWithoutSubjectsInput> | IpynbCreateWithoutSubjectsInput[] | IpynbUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutSubjectsInput | IpynbCreateOrConnectWithoutSubjectsInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type QAPairCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<QAPairCreateWithoutSubjectsInput, QAPairUncheckedCreateWithoutSubjectsInput> | QAPairCreateWithoutSubjectsInput[] | QAPairUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutSubjectsInput | QAPairCreateOrConnectWithoutSubjectsInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type PracticeExamCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<PracticeExamCreateWithoutSubjectsInput, PracticeExamUncheckedCreateWithoutSubjectsInput> | PracticeExamCreateWithoutSubjectsInput[] | PracticeExamUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutSubjectsInput | PracticeExamCreateOrConnectWithoutSubjectsInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
  }

  export type KanbanCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<KanbanCreateWithoutSubjectsInput, KanbanUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: KanbanCreateOrConnectWithoutSubjectsInput
    connect?: KanbanWhereUniqueInput
  }

  export type ToDoListCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<ToDoListCreateWithoutSubjectsInput, ToDoListUncheckedCreateWithoutSubjectsInput> | ToDoListCreateWithoutSubjectsInput[] | ToDoListUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutSubjectsInput | ToDoListCreateOrConnectWithoutSubjectsInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
  }

  export type ToDoCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<ToDoCreateWithoutSubjectsInput, ToDoUncheckedCreateWithoutSubjectsInput> | ToDoCreateWithoutSubjectsInput[] | ToDoUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutSubjectsInput | ToDoCreateOrConnectWithoutSubjectsInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type BibEntryCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<BibEntryCreateWithoutSubjectsInput, BibEntryUncheckedCreateWithoutSubjectsInput> | BibEntryCreateWithoutSubjectsInput[] | BibEntryUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutSubjectsInput | BibEntryCreateOrConnectWithoutSubjectsInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type EquationCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<EquationCreateWithoutSubjectsInput, EquationUncheckedCreateWithoutSubjectsInput> | EquationCreateWithoutSubjectsInput[] | EquationUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutSubjectsInput | EquationCreateOrConnectWithoutSubjectsInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<MdxNoteCreateWithoutSubjectsInput, MdxNoteUncheckedCreateWithoutSubjectsInput> | MdxNoteCreateWithoutSubjectsInput[] | MdxNoteUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutSubjectsInput | MdxNoteCreateOrConnectWithoutSubjectsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<IpynbCreateWithoutSubjectsInput, IpynbUncheckedCreateWithoutSubjectsInput> | IpynbCreateWithoutSubjectsInput[] | IpynbUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutSubjectsInput | IpynbCreateOrConnectWithoutSubjectsInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type QAPairUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<QAPairCreateWithoutSubjectsInput, QAPairUncheckedCreateWithoutSubjectsInput> | QAPairCreateWithoutSubjectsInput[] | QAPairUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutSubjectsInput | QAPairCreateOrConnectWithoutSubjectsInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<PracticeExamCreateWithoutSubjectsInput, PracticeExamUncheckedCreateWithoutSubjectsInput> | PracticeExamCreateWithoutSubjectsInput[] | PracticeExamUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutSubjectsInput | PracticeExamCreateOrConnectWithoutSubjectsInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
  }

  export type ToDoListUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<ToDoListCreateWithoutSubjectsInput, ToDoListUncheckedCreateWithoutSubjectsInput> | ToDoListCreateWithoutSubjectsInput[] | ToDoListUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutSubjectsInput | ToDoListCreateOrConnectWithoutSubjectsInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
  }

  export type ToDoUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<ToDoCreateWithoutSubjectsInput, ToDoUncheckedCreateWithoutSubjectsInput> | ToDoCreateWithoutSubjectsInput[] | ToDoUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutSubjectsInput | ToDoCreateOrConnectWithoutSubjectsInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type BibEntryUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<BibEntryCreateWithoutSubjectsInput, BibEntryUncheckedCreateWithoutSubjectsInput> | BibEntryCreateWithoutSubjectsInput[] | BibEntryUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutSubjectsInput | BibEntryCreateOrConnectWithoutSubjectsInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type EquationUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<EquationCreateWithoutSubjectsInput, EquationUncheckedCreateWithoutSubjectsInput> | EquationCreateWithoutSubjectsInput[] | EquationUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutSubjectsInput | EquationCreateOrConnectWithoutSubjectsInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type MdxNoteUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutSubjectsInput, MdxNoteUncheckedCreateWithoutSubjectsInput> | MdxNoteCreateWithoutSubjectsInput[] | MdxNoteUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutSubjectsInput | MdxNoteCreateOrConnectWithoutSubjectsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutSubjectsInput | MdxNoteUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutSubjectsInput | MdxNoteUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutSubjectsInput | MdxNoteUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<IpynbCreateWithoutSubjectsInput, IpynbUncheckedCreateWithoutSubjectsInput> | IpynbCreateWithoutSubjectsInput[] | IpynbUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutSubjectsInput | IpynbCreateOrConnectWithoutSubjectsInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutSubjectsInput | IpynbUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutSubjectsInput | IpynbUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutSubjectsInput | IpynbUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type QAPairUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<QAPairCreateWithoutSubjectsInput, QAPairUncheckedCreateWithoutSubjectsInput> | QAPairCreateWithoutSubjectsInput[] | QAPairUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutSubjectsInput | QAPairCreateOrConnectWithoutSubjectsInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutSubjectsInput | QAPairUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutSubjectsInput | QAPairUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutSubjectsInput | QAPairUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type PracticeExamUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<PracticeExamCreateWithoutSubjectsInput, PracticeExamUncheckedCreateWithoutSubjectsInput> | PracticeExamCreateWithoutSubjectsInput[] | PracticeExamUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutSubjectsInput | PracticeExamCreateOrConnectWithoutSubjectsInput[]
    upsert?: PracticeExamUpsertWithWhereUniqueWithoutSubjectsInput | PracticeExamUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    disconnect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    delete?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    update?: PracticeExamUpdateWithWhereUniqueWithoutSubjectsInput | PracticeExamUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: PracticeExamUpdateManyWithWhereWithoutSubjectsInput | PracticeExamUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
  }

  export type KanbanUpdateOneWithoutSubjectsNestedInput = {
    create?: XOR<KanbanCreateWithoutSubjectsInput, KanbanUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: KanbanCreateOrConnectWithoutSubjectsInput
    upsert?: KanbanUpsertWithoutSubjectsInput
    disconnect?: KanbanWhereInput | boolean
    delete?: KanbanWhereInput | boolean
    connect?: KanbanWhereUniqueInput
    update?: XOR<XOR<KanbanUpdateToOneWithWhereWithoutSubjectsInput, KanbanUpdateWithoutSubjectsInput>, KanbanUncheckedUpdateWithoutSubjectsInput>
  }

  export type ToDoListUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<ToDoListCreateWithoutSubjectsInput, ToDoListUncheckedCreateWithoutSubjectsInput> | ToDoListCreateWithoutSubjectsInput[] | ToDoListUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutSubjectsInput | ToDoListCreateOrConnectWithoutSubjectsInput[]
    upsert?: ToDoListUpsertWithWhereUniqueWithoutSubjectsInput | ToDoListUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    disconnect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    delete?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    update?: ToDoListUpdateWithWhereUniqueWithoutSubjectsInput | ToDoListUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: ToDoListUpdateManyWithWhereWithoutSubjectsInput | ToDoListUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: ToDoListScalarWhereInput | ToDoListScalarWhereInput[]
  }

  export type ToDoUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<ToDoCreateWithoutSubjectsInput, ToDoUncheckedCreateWithoutSubjectsInput> | ToDoCreateWithoutSubjectsInput[] | ToDoUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutSubjectsInput | ToDoCreateOrConnectWithoutSubjectsInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutSubjectsInput | ToDoUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutSubjectsInput | ToDoUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutSubjectsInput | ToDoUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type BibEntryUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<BibEntryCreateWithoutSubjectsInput, BibEntryUncheckedCreateWithoutSubjectsInput> | BibEntryCreateWithoutSubjectsInput[] | BibEntryUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutSubjectsInput | BibEntryCreateOrConnectWithoutSubjectsInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutSubjectsInput | BibEntryUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutSubjectsInput | BibEntryUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutSubjectsInput | BibEntryUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type EquationUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<EquationCreateWithoutSubjectsInput, EquationUncheckedCreateWithoutSubjectsInput> | EquationCreateWithoutSubjectsInput[] | EquationUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutSubjectsInput | EquationCreateOrConnectWithoutSubjectsInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutSubjectsInput | EquationUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutSubjectsInput | EquationUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutSubjectsInput | EquationUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutSubjectsInput, MdxNoteUncheckedCreateWithoutSubjectsInput> | MdxNoteCreateWithoutSubjectsInput[] | MdxNoteUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutSubjectsInput | MdxNoteCreateOrConnectWithoutSubjectsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutSubjectsInput | MdxNoteUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutSubjectsInput | MdxNoteUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutSubjectsInput | MdxNoteUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<IpynbCreateWithoutSubjectsInput, IpynbUncheckedCreateWithoutSubjectsInput> | IpynbCreateWithoutSubjectsInput[] | IpynbUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutSubjectsInput | IpynbCreateOrConnectWithoutSubjectsInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutSubjectsInput | IpynbUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutSubjectsInput | IpynbUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutSubjectsInput | IpynbUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type QAPairUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<QAPairCreateWithoutSubjectsInput, QAPairUncheckedCreateWithoutSubjectsInput> | QAPairCreateWithoutSubjectsInput[] | QAPairUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutSubjectsInput | QAPairCreateOrConnectWithoutSubjectsInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutSubjectsInput | QAPairUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutSubjectsInput | QAPairUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutSubjectsInput | QAPairUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<PracticeExamCreateWithoutSubjectsInput, PracticeExamUncheckedCreateWithoutSubjectsInput> | PracticeExamCreateWithoutSubjectsInput[] | PracticeExamUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutSubjectsInput | PracticeExamCreateOrConnectWithoutSubjectsInput[]
    upsert?: PracticeExamUpsertWithWhereUniqueWithoutSubjectsInput | PracticeExamUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    disconnect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    delete?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    update?: PracticeExamUpdateWithWhereUniqueWithoutSubjectsInput | PracticeExamUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: PracticeExamUpdateManyWithWhereWithoutSubjectsInput | PracticeExamUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
  }

  export type ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<ToDoListCreateWithoutSubjectsInput, ToDoListUncheckedCreateWithoutSubjectsInput> | ToDoListCreateWithoutSubjectsInput[] | ToDoListUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutSubjectsInput | ToDoListCreateOrConnectWithoutSubjectsInput[]
    upsert?: ToDoListUpsertWithWhereUniqueWithoutSubjectsInput | ToDoListUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    disconnect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    delete?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    update?: ToDoListUpdateWithWhereUniqueWithoutSubjectsInput | ToDoListUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: ToDoListUpdateManyWithWhereWithoutSubjectsInput | ToDoListUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: ToDoListScalarWhereInput | ToDoListScalarWhereInput[]
  }

  export type ToDoUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<ToDoCreateWithoutSubjectsInput, ToDoUncheckedCreateWithoutSubjectsInput> | ToDoCreateWithoutSubjectsInput[] | ToDoUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutSubjectsInput | ToDoCreateOrConnectWithoutSubjectsInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutSubjectsInput | ToDoUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutSubjectsInput | ToDoUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutSubjectsInput | ToDoUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<BibEntryCreateWithoutSubjectsInput, BibEntryUncheckedCreateWithoutSubjectsInput> | BibEntryCreateWithoutSubjectsInput[] | BibEntryUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutSubjectsInput | BibEntryCreateOrConnectWithoutSubjectsInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutSubjectsInput | BibEntryUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutSubjectsInput | BibEntryUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutSubjectsInput | BibEntryUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type EquationUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<EquationCreateWithoutSubjectsInput, EquationUncheckedCreateWithoutSubjectsInput> | EquationCreateWithoutSubjectsInput[] | EquationUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutSubjectsInput | EquationCreateOrConnectWithoutSubjectsInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutSubjectsInput | EquationUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutSubjectsInput | EquationUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutSubjectsInput | EquationUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type MdxNoteCreateNestedManyWithoutTopicsInput = {
    create?: XOR<MdxNoteCreateWithoutTopicsInput, MdxNoteUncheckedCreateWithoutTopicsInput> | MdxNoteCreateWithoutTopicsInput[] | MdxNoteUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutTopicsInput | MdxNoteCreateOrConnectWithoutTopicsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbCreateNestedManyWithoutTopicsInput = {
    create?: XOR<IpynbCreateWithoutTopicsInput, IpynbUncheckedCreateWithoutTopicsInput> | IpynbCreateWithoutTopicsInput[] | IpynbUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutTopicsInput | IpynbCreateOrConnectWithoutTopicsInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type QAPairCreateNestedManyWithoutTopicsInput = {
    create?: XOR<QAPairCreateWithoutTopicsInput, QAPairUncheckedCreateWithoutTopicsInput> | QAPairCreateWithoutTopicsInput[] | QAPairUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutTopicsInput | QAPairCreateOrConnectWithoutTopicsInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type PracticeExamCreateNestedManyWithoutTopicsInput = {
    create?: XOR<PracticeExamCreateWithoutTopicsInput, PracticeExamUncheckedCreateWithoutTopicsInput> | PracticeExamCreateWithoutTopicsInput[] | PracticeExamUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutTopicsInput | PracticeExamCreateOrConnectWithoutTopicsInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
  }

  export type ToDoCreateNestedManyWithoutTopicsInput = {
    create?: XOR<ToDoCreateWithoutTopicsInput, ToDoUncheckedCreateWithoutTopicsInput> | ToDoCreateWithoutTopicsInput[] | ToDoUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutTopicsInput | ToDoCreateOrConnectWithoutTopicsInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type KanbanCreateNestedOneWithoutTopicsInput = {
    create?: XOR<KanbanCreateWithoutTopicsInput, KanbanUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: KanbanCreateOrConnectWithoutTopicsInput
    connect?: KanbanWhereUniqueInput
  }

  export type ToDoListCreateNestedManyWithoutTopicsInput = {
    create?: XOR<ToDoListCreateWithoutTopicsInput, ToDoListUncheckedCreateWithoutTopicsInput> | ToDoListCreateWithoutTopicsInput[] | ToDoListUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutTopicsInput | ToDoListCreateOrConnectWithoutTopicsInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
  }

  export type BibEntryCreateNestedManyWithoutTopicsInput = {
    create?: XOR<BibEntryCreateWithoutTopicsInput, BibEntryUncheckedCreateWithoutTopicsInput> | BibEntryCreateWithoutTopicsInput[] | BibEntryUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutTopicsInput | BibEntryCreateOrConnectWithoutTopicsInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type EquationCreateNestedManyWithoutTopicsInput = {
    create?: XOR<EquationCreateWithoutTopicsInput, EquationUncheckedCreateWithoutTopicsInput> | EquationCreateWithoutTopicsInput[] | EquationUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutTopicsInput | EquationCreateOrConnectWithoutTopicsInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type MdxNoteUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<MdxNoteCreateWithoutTopicsInput, MdxNoteUncheckedCreateWithoutTopicsInput> | MdxNoteCreateWithoutTopicsInput[] | MdxNoteUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutTopicsInput | MdxNoteCreateOrConnectWithoutTopicsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<IpynbCreateWithoutTopicsInput, IpynbUncheckedCreateWithoutTopicsInput> | IpynbCreateWithoutTopicsInput[] | IpynbUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutTopicsInput | IpynbCreateOrConnectWithoutTopicsInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type QAPairUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<QAPairCreateWithoutTopicsInput, QAPairUncheckedCreateWithoutTopicsInput> | QAPairCreateWithoutTopicsInput[] | QAPairUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutTopicsInput | QAPairCreateOrConnectWithoutTopicsInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type PracticeExamUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<PracticeExamCreateWithoutTopicsInput, PracticeExamUncheckedCreateWithoutTopicsInput> | PracticeExamCreateWithoutTopicsInput[] | PracticeExamUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutTopicsInput | PracticeExamCreateOrConnectWithoutTopicsInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
  }

  export type ToDoUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<ToDoCreateWithoutTopicsInput, ToDoUncheckedCreateWithoutTopicsInput> | ToDoCreateWithoutTopicsInput[] | ToDoUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutTopicsInput | ToDoCreateOrConnectWithoutTopicsInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type ToDoListUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<ToDoListCreateWithoutTopicsInput, ToDoListUncheckedCreateWithoutTopicsInput> | ToDoListCreateWithoutTopicsInput[] | ToDoListUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutTopicsInput | ToDoListCreateOrConnectWithoutTopicsInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
  }

  export type BibEntryUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<BibEntryCreateWithoutTopicsInput, BibEntryUncheckedCreateWithoutTopicsInput> | BibEntryCreateWithoutTopicsInput[] | BibEntryUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutTopicsInput | BibEntryCreateOrConnectWithoutTopicsInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type EquationUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<EquationCreateWithoutTopicsInput, EquationUncheckedCreateWithoutTopicsInput> | EquationCreateWithoutTopicsInput[] | EquationUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutTopicsInput | EquationCreateOrConnectWithoutTopicsInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type MdxNoteUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutTopicsInput, MdxNoteUncheckedCreateWithoutTopicsInput> | MdxNoteCreateWithoutTopicsInput[] | MdxNoteUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutTopicsInput | MdxNoteCreateOrConnectWithoutTopicsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutTopicsInput | MdxNoteUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutTopicsInput | MdxNoteUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutTopicsInput | MdxNoteUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<IpynbCreateWithoutTopicsInput, IpynbUncheckedCreateWithoutTopicsInput> | IpynbCreateWithoutTopicsInput[] | IpynbUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutTopicsInput | IpynbCreateOrConnectWithoutTopicsInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutTopicsInput | IpynbUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutTopicsInput | IpynbUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutTopicsInput | IpynbUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type QAPairUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<QAPairCreateWithoutTopicsInput, QAPairUncheckedCreateWithoutTopicsInput> | QAPairCreateWithoutTopicsInput[] | QAPairUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutTopicsInput | QAPairCreateOrConnectWithoutTopicsInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutTopicsInput | QAPairUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutTopicsInput | QAPairUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutTopicsInput | QAPairUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type PracticeExamUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<PracticeExamCreateWithoutTopicsInput, PracticeExamUncheckedCreateWithoutTopicsInput> | PracticeExamCreateWithoutTopicsInput[] | PracticeExamUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutTopicsInput | PracticeExamCreateOrConnectWithoutTopicsInput[]
    upsert?: PracticeExamUpsertWithWhereUniqueWithoutTopicsInput | PracticeExamUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    disconnect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    delete?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    update?: PracticeExamUpdateWithWhereUniqueWithoutTopicsInput | PracticeExamUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: PracticeExamUpdateManyWithWhereWithoutTopicsInput | PracticeExamUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
  }

  export type ToDoUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<ToDoCreateWithoutTopicsInput, ToDoUncheckedCreateWithoutTopicsInput> | ToDoCreateWithoutTopicsInput[] | ToDoUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutTopicsInput | ToDoCreateOrConnectWithoutTopicsInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutTopicsInput | ToDoUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutTopicsInput | ToDoUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutTopicsInput | ToDoUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type KanbanUpdateOneWithoutTopicsNestedInput = {
    create?: XOR<KanbanCreateWithoutTopicsInput, KanbanUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: KanbanCreateOrConnectWithoutTopicsInput
    upsert?: KanbanUpsertWithoutTopicsInput
    disconnect?: KanbanWhereInput | boolean
    delete?: KanbanWhereInput | boolean
    connect?: KanbanWhereUniqueInput
    update?: XOR<XOR<KanbanUpdateToOneWithWhereWithoutTopicsInput, KanbanUpdateWithoutTopicsInput>, KanbanUncheckedUpdateWithoutTopicsInput>
  }

  export type ToDoListUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<ToDoListCreateWithoutTopicsInput, ToDoListUncheckedCreateWithoutTopicsInput> | ToDoListCreateWithoutTopicsInput[] | ToDoListUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutTopicsInput | ToDoListCreateOrConnectWithoutTopicsInput[]
    upsert?: ToDoListUpsertWithWhereUniqueWithoutTopicsInput | ToDoListUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    disconnect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    delete?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    update?: ToDoListUpdateWithWhereUniqueWithoutTopicsInput | ToDoListUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: ToDoListUpdateManyWithWhereWithoutTopicsInput | ToDoListUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: ToDoListScalarWhereInput | ToDoListScalarWhereInput[]
  }

  export type BibEntryUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<BibEntryCreateWithoutTopicsInput, BibEntryUncheckedCreateWithoutTopicsInput> | BibEntryCreateWithoutTopicsInput[] | BibEntryUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutTopicsInput | BibEntryCreateOrConnectWithoutTopicsInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutTopicsInput | BibEntryUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutTopicsInput | BibEntryUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutTopicsInput | BibEntryUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type EquationUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<EquationCreateWithoutTopicsInput, EquationUncheckedCreateWithoutTopicsInput> | EquationCreateWithoutTopicsInput[] | EquationUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutTopicsInput | EquationCreateOrConnectWithoutTopicsInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutTopicsInput | EquationUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutTopicsInput | EquationUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutTopicsInput | EquationUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutTopicsInput, MdxNoteUncheckedCreateWithoutTopicsInput> | MdxNoteCreateWithoutTopicsInput[] | MdxNoteUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutTopicsInput | MdxNoteCreateOrConnectWithoutTopicsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutTopicsInput | MdxNoteUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutTopicsInput | MdxNoteUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutTopicsInput | MdxNoteUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<IpynbCreateWithoutTopicsInput, IpynbUncheckedCreateWithoutTopicsInput> | IpynbCreateWithoutTopicsInput[] | IpynbUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutTopicsInput | IpynbCreateOrConnectWithoutTopicsInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutTopicsInput | IpynbUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutTopicsInput | IpynbUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutTopicsInput | IpynbUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type QAPairUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<QAPairCreateWithoutTopicsInput, QAPairUncheckedCreateWithoutTopicsInput> | QAPairCreateWithoutTopicsInput[] | QAPairUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutTopicsInput | QAPairCreateOrConnectWithoutTopicsInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutTopicsInput | QAPairUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutTopicsInput | QAPairUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutTopicsInput | QAPairUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<PracticeExamCreateWithoutTopicsInput, PracticeExamUncheckedCreateWithoutTopicsInput> | PracticeExamCreateWithoutTopicsInput[] | PracticeExamUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutTopicsInput | PracticeExamCreateOrConnectWithoutTopicsInput[]
    upsert?: PracticeExamUpsertWithWhereUniqueWithoutTopicsInput | PracticeExamUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    disconnect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    delete?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    update?: PracticeExamUpdateWithWhereUniqueWithoutTopicsInput | PracticeExamUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: PracticeExamUpdateManyWithWhereWithoutTopicsInput | PracticeExamUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
  }

  export type ToDoUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<ToDoCreateWithoutTopicsInput, ToDoUncheckedCreateWithoutTopicsInput> | ToDoCreateWithoutTopicsInput[] | ToDoUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutTopicsInput | ToDoCreateOrConnectWithoutTopicsInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutTopicsInput | ToDoUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutTopicsInput | ToDoUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutTopicsInput | ToDoUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type ToDoListUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<ToDoListCreateWithoutTopicsInput, ToDoListUncheckedCreateWithoutTopicsInput> | ToDoListCreateWithoutTopicsInput[] | ToDoListUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutTopicsInput | ToDoListCreateOrConnectWithoutTopicsInput[]
    upsert?: ToDoListUpsertWithWhereUniqueWithoutTopicsInput | ToDoListUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    disconnect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    delete?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    update?: ToDoListUpdateWithWhereUniqueWithoutTopicsInput | ToDoListUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: ToDoListUpdateManyWithWhereWithoutTopicsInput | ToDoListUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: ToDoListScalarWhereInput | ToDoListScalarWhereInput[]
  }

  export type BibEntryUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<BibEntryCreateWithoutTopicsInput, BibEntryUncheckedCreateWithoutTopicsInput> | BibEntryCreateWithoutTopicsInput[] | BibEntryUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutTopicsInput | BibEntryCreateOrConnectWithoutTopicsInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutTopicsInput | BibEntryUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutTopicsInput | BibEntryUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutTopicsInput | BibEntryUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type EquationUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<EquationCreateWithoutTopicsInput, EquationUncheckedCreateWithoutTopicsInput> | EquationCreateWithoutTopicsInput[] | EquationUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutTopicsInput | EquationCreateOrConnectWithoutTopicsInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutTopicsInput | EquationUpsertWithWhereUniqueWithoutTopicsInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutTopicsInput | EquationUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutTopicsInput | EquationUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type MdxNoteCreateNestedManyWithoutTagsInput = {
    create?: XOR<MdxNoteCreateWithoutTagsInput, MdxNoteUncheckedCreateWithoutTagsInput> | MdxNoteCreateWithoutTagsInput[] | MdxNoteUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutTagsInput | MdxNoteCreateOrConnectWithoutTagsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type BibEntryCreateNestedManyWithoutTagsInput = {
    create?: XOR<BibEntryCreateWithoutTagsInput, BibEntryUncheckedCreateWithoutTagsInput> | BibEntryCreateWithoutTagsInput[] | BibEntryUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutTagsInput | BibEntryCreateOrConnectWithoutTagsInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type IpynbCreateNestedManyWithoutTagsInput = {
    create?: XOR<IpynbCreateWithoutTagsInput, IpynbUncheckedCreateWithoutTagsInput> | IpynbCreateWithoutTagsInput[] | IpynbUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutTagsInput | IpynbCreateOrConnectWithoutTagsInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type QAPairCreateNestedManyWithoutTagsInput = {
    create?: XOR<QAPairCreateWithoutTagsInput, QAPairUncheckedCreateWithoutTagsInput> | QAPairCreateWithoutTagsInput[] | QAPairUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutTagsInput | QAPairCreateOrConnectWithoutTagsInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type PracticeExamCreateNestedManyWithoutTagsInput = {
    create?: XOR<PracticeExamCreateWithoutTagsInput, PracticeExamUncheckedCreateWithoutTagsInput> | PracticeExamCreateWithoutTagsInput[] | PracticeExamUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutTagsInput | PracticeExamCreateOrConnectWithoutTagsInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
  }

  export type EquationCreateNestedManyWithoutTagsInput = {
    create?: XOR<EquationCreateWithoutTagsInput, EquationUncheckedCreateWithoutTagsInput> | EquationCreateWithoutTagsInput[] | EquationUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutTagsInput | EquationCreateOrConnectWithoutTagsInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type ToDoCreateNestedManyWithoutTagsInput = {
    create?: XOR<ToDoCreateWithoutTagsInput, ToDoUncheckedCreateWithoutTagsInput> | ToDoCreateWithoutTagsInput[] | ToDoUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutTagsInput | ToDoCreateOrConnectWithoutTagsInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type KanbanCreateNestedOneWithoutTagsInput = {
    create?: XOR<KanbanCreateWithoutTagsInput, KanbanUncheckedCreateWithoutTagsInput>
    connectOrCreate?: KanbanCreateOrConnectWithoutTagsInput
    connect?: KanbanWhereUniqueInput
  }

  export type ToDoListCreateNestedManyWithoutTagsInput = {
    create?: XOR<ToDoListCreateWithoutTagsInput, ToDoListUncheckedCreateWithoutTagsInput> | ToDoListCreateWithoutTagsInput[] | ToDoListUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutTagsInput | ToDoListCreateOrConnectWithoutTagsInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
  }

  export type MdxNoteUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<MdxNoteCreateWithoutTagsInput, MdxNoteUncheckedCreateWithoutTagsInput> | MdxNoteCreateWithoutTagsInput[] | MdxNoteUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutTagsInput | MdxNoteCreateOrConnectWithoutTagsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type BibEntryUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<BibEntryCreateWithoutTagsInput, BibEntryUncheckedCreateWithoutTagsInput> | BibEntryCreateWithoutTagsInput[] | BibEntryUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutTagsInput | BibEntryCreateOrConnectWithoutTagsInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type IpynbUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<IpynbCreateWithoutTagsInput, IpynbUncheckedCreateWithoutTagsInput> | IpynbCreateWithoutTagsInput[] | IpynbUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutTagsInput | IpynbCreateOrConnectWithoutTagsInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type QAPairUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<QAPairCreateWithoutTagsInput, QAPairUncheckedCreateWithoutTagsInput> | QAPairCreateWithoutTagsInput[] | QAPairUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutTagsInput | QAPairCreateOrConnectWithoutTagsInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type PracticeExamUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<PracticeExamCreateWithoutTagsInput, PracticeExamUncheckedCreateWithoutTagsInput> | PracticeExamCreateWithoutTagsInput[] | PracticeExamUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutTagsInput | PracticeExamCreateOrConnectWithoutTagsInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
  }

  export type EquationUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<EquationCreateWithoutTagsInput, EquationUncheckedCreateWithoutTagsInput> | EquationCreateWithoutTagsInput[] | EquationUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutTagsInput | EquationCreateOrConnectWithoutTagsInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type ToDoUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ToDoCreateWithoutTagsInput, ToDoUncheckedCreateWithoutTagsInput> | ToDoCreateWithoutTagsInput[] | ToDoUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutTagsInput | ToDoCreateOrConnectWithoutTagsInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type ToDoListUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ToDoListCreateWithoutTagsInput, ToDoListUncheckedCreateWithoutTagsInput> | ToDoListCreateWithoutTagsInput[] | ToDoListUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutTagsInput | ToDoListCreateOrConnectWithoutTagsInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
  }

  export type MdxNoteUpdateManyWithoutTagsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutTagsInput, MdxNoteUncheckedCreateWithoutTagsInput> | MdxNoteCreateWithoutTagsInput[] | MdxNoteUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutTagsInput | MdxNoteCreateOrConnectWithoutTagsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutTagsInput | MdxNoteUpsertWithWhereUniqueWithoutTagsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutTagsInput | MdxNoteUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutTagsInput | MdxNoteUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type BibEntryUpdateManyWithoutTagsNestedInput = {
    create?: XOR<BibEntryCreateWithoutTagsInput, BibEntryUncheckedCreateWithoutTagsInput> | BibEntryCreateWithoutTagsInput[] | BibEntryUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutTagsInput | BibEntryCreateOrConnectWithoutTagsInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutTagsInput | BibEntryUpsertWithWhereUniqueWithoutTagsInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutTagsInput | BibEntryUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutTagsInput | BibEntryUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type IpynbUpdateManyWithoutTagsNestedInput = {
    create?: XOR<IpynbCreateWithoutTagsInput, IpynbUncheckedCreateWithoutTagsInput> | IpynbCreateWithoutTagsInput[] | IpynbUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutTagsInput | IpynbCreateOrConnectWithoutTagsInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutTagsInput | IpynbUpsertWithWhereUniqueWithoutTagsInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutTagsInput | IpynbUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutTagsInput | IpynbUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type QAPairUpdateManyWithoutTagsNestedInput = {
    create?: XOR<QAPairCreateWithoutTagsInput, QAPairUncheckedCreateWithoutTagsInput> | QAPairCreateWithoutTagsInput[] | QAPairUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutTagsInput | QAPairCreateOrConnectWithoutTagsInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutTagsInput | QAPairUpsertWithWhereUniqueWithoutTagsInput[]
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutTagsInput | QAPairUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutTagsInput | QAPairUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type PracticeExamUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PracticeExamCreateWithoutTagsInput, PracticeExamUncheckedCreateWithoutTagsInput> | PracticeExamCreateWithoutTagsInput[] | PracticeExamUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutTagsInput | PracticeExamCreateOrConnectWithoutTagsInput[]
    upsert?: PracticeExamUpsertWithWhereUniqueWithoutTagsInput | PracticeExamUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    disconnect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    delete?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    update?: PracticeExamUpdateWithWhereUniqueWithoutTagsInput | PracticeExamUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PracticeExamUpdateManyWithWhereWithoutTagsInput | PracticeExamUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
  }

  export type EquationUpdateManyWithoutTagsNestedInput = {
    create?: XOR<EquationCreateWithoutTagsInput, EquationUncheckedCreateWithoutTagsInput> | EquationCreateWithoutTagsInput[] | EquationUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutTagsInput | EquationCreateOrConnectWithoutTagsInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutTagsInput | EquationUpsertWithWhereUniqueWithoutTagsInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutTagsInput | EquationUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutTagsInput | EquationUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type ToDoUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ToDoCreateWithoutTagsInput, ToDoUncheckedCreateWithoutTagsInput> | ToDoCreateWithoutTagsInput[] | ToDoUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutTagsInput | ToDoCreateOrConnectWithoutTagsInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutTagsInput | ToDoUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutTagsInput | ToDoUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutTagsInput | ToDoUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type KanbanUpdateOneWithoutTagsNestedInput = {
    create?: XOR<KanbanCreateWithoutTagsInput, KanbanUncheckedCreateWithoutTagsInput>
    connectOrCreate?: KanbanCreateOrConnectWithoutTagsInput
    upsert?: KanbanUpsertWithoutTagsInput
    disconnect?: KanbanWhereInput | boolean
    delete?: KanbanWhereInput | boolean
    connect?: KanbanWhereUniqueInput
    update?: XOR<XOR<KanbanUpdateToOneWithWhereWithoutTagsInput, KanbanUpdateWithoutTagsInput>, KanbanUncheckedUpdateWithoutTagsInput>
  }

  export type ToDoListUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ToDoListCreateWithoutTagsInput, ToDoListUncheckedCreateWithoutTagsInput> | ToDoListCreateWithoutTagsInput[] | ToDoListUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutTagsInput | ToDoListCreateOrConnectWithoutTagsInput[]
    upsert?: ToDoListUpsertWithWhereUniqueWithoutTagsInput | ToDoListUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    disconnect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    delete?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    update?: ToDoListUpdateWithWhereUniqueWithoutTagsInput | ToDoListUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ToDoListUpdateManyWithWhereWithoutTagsInput | ToDoListUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ToDoListScalarWhereInput | ToDoListScalarWhereInput[]
  }

  export type MdxNoteUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutTagsInput, MdxNoteUncheckedCreateWithoutTagsInput> | MdxNoteCreateWithoutTagsInput[] | MdxNoteUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutTagsInput | MdxNoteCreateOrConnectWithoutTagsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutTagsInput | MdxNoteUpsertWithWhereUniqueWithoutTagsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutTagsInput | MdxNoteUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutTagsInput | MdxNoteUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type BibEntryUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<BibEntryCreateWithoutTagsInput, BibEntryUncheckedCreateWithoutTagsInput> | BibEntryCreateWithoutTagsInput[] | BibEntryUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutTagsInput | BibEntryCreateOrConnectWithoutTagsInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutTagsInput | BibEntryUpsertWithWhereUniqueWithoutTagsInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutTagsInput | BibEntryUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutTagsInput | BibEntryUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type IpynbUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<IpynbCreateWithoutTagsInput, IpynbUncheckedCreateWithoutTagsInput> | IpynbCreateWithoutTagsInput[] | IpynbUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutTagsInput | IpynbCreateOrConnectWithoutTagsInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutTagsInput | IpynbUpsertWithWhereUniqueWithoutTagsInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutTagsInput | IpynbUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutTagsInput | IpynbUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type QAPairUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<QAPairCreateWithoutTagsInput, QAPairUncheckedCreateWithoutTagsInput> | QAPairCreateWithoutTagsInput[] | QAPairUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutTagsInput | QAPairCreateOrConnectWithoutTagsInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutTagsInput | QAPairUpsertWithWhereUniqueWithoutTagsInput[]
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutTagsInput | QAPairUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutTagsInput | QAPairUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type PracticeExamUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PracticeExamCreateWithoutTagsInput, PracticeExamUncheckedCreateWithoutTagsInput> | PracticeExamCreateWithoutTagsInput[] | PracticeExamUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutTagsInput | PracticeExamCreateOrConnectWithoutTagsInput[]
    upsert?: PracticeExamUpsertWithWhereUniqueWithoutTagsInput | PracticeExamUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    disconnect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    delete?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    update?: PracticeExamUpdateWithWhereUniqueWithoutTagsInput | PracticeExamUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PracticeExamUpdateManyWithWhereWithoutTagsInput | PracticeExamUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
  }

  export type EquationUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<EquationCreateWithoutTagsInput, EquationUncheckedCreateWithoutTagsInput> | EquationCreateWithoutTagsInput[] | EquationUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutTagsInput | EquationCreateOrConnectWithoutTagsInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutTagsInput | EquationUpsertWithWhereUniqueWithoutTagsInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutTagsInput | EquationUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutTagsInput | EquationUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type ToDoUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ToDoCreateWithoutTagsInput, ToDoUncheckedCreateWithoutTagsInput> | ToDoCreateWithoutTagsInput[] | ToDoUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutTagsInput | ToDoCreateOrConnectWithoutTagsInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutTagsInput | ToDoUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutTagsInput | ToDoUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutTagsInput | ToDoUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type ToDoListUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ToDoListCreateWithoutTagsInput, ToDoListUncheckedCreateWithoutTagsInput> | ToDoListCreateWithoutTagsInput[] | ToDoListUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ToDoListCreateOrConnectWithoutTagsInput | ToDoListCreateOrConnectWithoutTagsInput[]
    upsert?: ToDoListUpsertWithWhereUniqueWithoutTagsInput | ToDoListUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    disconnect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    delete?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    connect?: ToDoListWhereUniqueInput | ToDoListWhereUniqueInput[]
    update?: ToDoListUpdateWithWhereUniqueWithoutTagsInput | ToDoListUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ToDoListUpdateManyWithWhereWithoutTagsInput | ToDoListUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ToDoListScalarWhereInput | ToDoListScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumautoSettingFieldUpdateOperationsInput = {
    set?: $Enums.autoSetting
  }

  export type BibEntryCreateNestedManyWithoutReadingListInput = {
    create?: XOR<BibEntryCreateWithoutReadingListInput, BibEntryUncheckedCreateWithoutReadingListInput> | BibEntryCreateWithoutReadingListInput[] | BibEntryUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutReadingListInput | BibEntryCreateOrConnectWithoutReadingListInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type MdxNoteCreateNestedManyWithoutReadingListInput = {
    create?: XOR<MdxNoteCreateWithoutReadingListInput, MdxNoteUncheckedCreateWithoutReadingListInput> | MdxNoteCreateWithoutReadingListInput[] | MdxNoteUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutReadingListInput | MdxNoteCreateOrConnectWithoutReadingListInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbCreateNestedManyWithoutReadingListInput = {
    create?: XOR<IpynbCreateWithoutReadingListInput, IpynbUncheckedCreateWithoutReadingListInput> | IpynbCreateWithoutReadingListInput[] | IpynbUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutReadingListInput | IpynbCreateOrConnectWithoutReadingListInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type BibEntryUncheckedCreateNestedManyWithoutReadingListInput = {
    create?: XOR<BibEntryCreateWithoutReadingListInput, BibEntryUncheckedCreateWithoutReadingListInput> | BibEntryCreateWithoutReadingListInput[] | BibEntryUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutReadingListInput | BibEntryCreateOrConnectWithoutReadingListInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type MdxNoteUncheckedCreateNestedManyWithoutReadingListInput = {
    create?: XOR<MdxNoteCreateWithoutReadingListInput, MdxNoteUncheckedCreateWithoutReadingListInput> | MdxNoteCreateWithoutReadingListInput[] | MdxNoteUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutReadingListInput | MdxNoteCreateOrConnectWithoutReadingListInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbUncheckedCreateNestedManyWithoutReadingListInput = {
    create?: XOR<IpynbCreateWithoutReadingListInput, IpynbUncheckedCreateWithoutReadingListInput> | IpynbCreateWithoutReadingListInput[] | IpynbUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutReadingListInput | IpynbCreateOrConnectWithoutReadingListInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type BibEntryUpdateManyWithoutReadingListNestedInput = {
    create?: XOR<BibEntryCreateWithoutReadingListInput, BibEntryUncheckedCreateWithoutReadingListInput> | BibEntryCreateWithoutReadingListInput[] | BibEntryUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutReadingListInput | BibEntryCreateOrConnectWithoutReadingListInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutReadingListInput | BibEntryUpsertWithWhereUniqueWithoutReadingListInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutReadingListInput | BibEntryUpdateWithWhereUniqueWithoutReadingListInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutReadingListInput | BibEntryUpdateManyWithWhereWithoutReadingListInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type MdxNoteUpdateManyWithoutReadingListNestedInput = {
    create?: XOR<MdxNoteCreateWithoutReadingListInput, MdxNoteUncheckedCreateWithoutReadingListInput> | MdxNoteCreateWithoutReadingListInput[] | MdxNoteUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutReadingListInput | MdxNoteCreateOrConnectWithoutReadingListInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutReadingListInput | MdxNoteUpsertWithWhereUniqueWithoutReadingListInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutReadingListInput | MdxNoteUpdateWithWhereUniqueWithoutReadingListInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutReadingListInput | MdxNoteUpdateManyWithWhereWithoutReadingListInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUpdateManyWithoutReadingListNestedInput = {
    create?: XOR<IpynbCreateWithoutReadingListInput, IpynbUncheckedCreateWithoutReadingListInput> | IpynbCreateWithoutReadingListInput[] | IpynbUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutReadingListInput | IpynbCreateOrConnectWithoutReadingListInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutReadingListInput | IpynbUpsertWithWhereUniqueWithoutReadingListInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutReadingListInput | IpynbUpdateWithWhereUniqueWithoutReadingListInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutReadingListInput | IpynbUpdateManyWithWhereWithoutReadingListInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type BibEntryUncheckedUpdateManyWithoutReadingListNestedInput = {
    create?: XOR<BibEntryCreateWithoutReadingListInput, BibEntryUncheckedCreateWithoutReadingListInput> | BibEntryCreateWithoutReadingListInput[] | BibEntryUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutReadingListInput | BibEntryCreateOrConnectWithoutReadingListInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutReadingListInput | BibEntryUpsertWithWhereUniqueWithoutReadingListInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutReadingListInput | BibEntryUpdateWithWhereUniqueWithoutReadingListInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutReadingListInput | BibEntryUpdateManyWithWhereWithoutReadingListInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type MdxNoteUncheckedUpdateManyWithoutReadingListNestedInput = {
    create?: XOR<MdxNoteCreateWithoutReadingListInput, MdxNoteUncheckedCreateWithoutReadingListInput> | MdxNoteCreateWithoutReadingListInput[] | MdxNoteUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutReadingListInput | MdxNoteCreateOrConnectWithoutReadingListInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutReadingListInput | MdxNoteUpsertWithWhereUniqueWithoutReadingListInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutReadingListInput | MdxNoteUpdateWithWhereUniqueWithoutReadingListInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutReadingListInput | MdxNoteUpdateManyWithWhereWithoutReadingListInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUncheckedUpdateManyWithoutReadingListNestedInput = {
    create?: XOR<IpynbCreateWithoutReadingListInput, IpynbUncheckedCreateWithoutReadingListInput> | IpynbCreateWithoutReadingListInput[] | IpynbUncheckedCreateWithoutReadingListInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutReadingListInput | IpynbCreateOrConnectWithoutReadingListInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutReadingListInput | IpynbUpsertWithWhereUniqueWithoutReadingListInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutReadingListInput | IpynbUpdateWithWhereUniqueWithoutReadingListInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutReadingListInput | IpynbUpdateManyWithWhereWithoutReadingListInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type BibCreateNestedOneWithoutEntriesInput = {
    create?: XOR<BibCreateWithoutEntriesInput, BibUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: BibCreateOrConnectWithoutEntriesInput
    connect?: BibWhereUniqueInput
  }

  export type CitationsGroupCreateNestedManyWithoutEntriesInput = {
    create?: XOR<CitationsGroupCreateWithoutEntriesInput, CitationsGroupUncheckedCreateWithoutEntriesInput> | CitationsGroupCreateWithoutEntriesInput[] | CitationsGroupUncheckedCreateWithoutEntriesInput[]
    connectOrCreate?: CitationsGroupCreateOrConnectWithoutEntriesInput | CitationsGroupCreateOrConnectWithoutEntriesInput[]
    connect?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutBibEntriesInput = {
    create?: XOR<TagCreateWithoutBibEntriesInput, TagUncheckedCreateWithoutBibEntriesInput> | TagCreateWithoutBibEntriesInput[] | TagUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutBibEntriesInput | TagCreateOrConnectWithoutBibEntriesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutBibEntriesInput = {
    create?: XOR<TopicCreateWithoutBibEntriesInput, TopicUncheckedCreateWithoutBibEntriesInput> | TopicCreateWithoutBibEntriesInput[] | TopicUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBibEntriesInput | TopicCreateOrConnectWithoutBibEntriesInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutBibEntriesInput = {
    create?: XOR<SubjectCreateWithoutBibEntriesInput, SubjectUncheckedCreateWithoutBibEntriesInput> | SubjectCreateWithoutBibEntriesInput[] | SubjectUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBibEntriesInput | SubjectCreateOrConnectWithoutBibEntriesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type MdxNoteCreateNestedManyWithoutCitationsInput = {
    create?: XOR<MdxNoteCreateWithoutCitationsInput, MdxNoteUncheckedCreateWithoutCitationsInput> | MdxNoteCreateWithoutCitationsInput[] | MdxNoteUncheckedCreateWithoutCitationsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutCitationsInput | MdxNoteCreateOrConnectWithoutCitationsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbCreateNestedManyWithoutCitationsInput = {
    create?: XOR<IpynbCreateWithoutCitationsInput, IpynbUncheckedCreateWithoutCitationsInput> | IpynbCreateWithoutCitationsInput[] | IpynbUncheckedCreateWithoutCitationsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutCitationsInput | IpynbCreateOrConnectWithoutCitationsInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type ReadingListCreateNestedManyWithoutBibEntriesInput = {
    create?: XOR<ReadingListCreateWithoutBibEntriesInput, ReadingListUncheckedCreateWithoutBibEntriesInput> | ReadingListCreateWithoutBibEntriesInput[] | ReadingListUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutBibEntriesInput | ReadingListCreateOrConnectWithoutBibEntriesInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
  }

  export type CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput = {
    create?: XOR<CitationsGroupCreateWithoutEntriesInput, CitationsGroupUncheckedCreateWithoutEntriesInput> | CitationsGroupCreateWithoutEntriesInput[] | CitationsGroupUncheckedCreateWithoutEntriesInput[]
    connectOrCreate?: CitationsGroupCreateOrConnectWithoutEntriesInput | CitationsGroupCreateOrConnectWithoutEntriesInput[]
    connect?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutBibEntriesInput = {
    create?: XOR<TagCreateWithoutBibEntriesInput, TagUncheckedCreateWithoutBibEntriesInput> | TagCreateWithoutBibEntriesInput[] | TagUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutBibEntriesInput | TagCreateOrConnectWithoutBibEntriesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutBibEntriesInput = {
    create?: XOR<TopicCreateWithoutBibEntriesInput, TopicUncheckedCreateWithoutBibEntriesInput> | TopicCreateWithoutBibEntriesInput[] | TopicUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBibEntriesInput | TopicCreateOrConnectWithoutBibEntriesInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutBibEntriesInput = {
    create?: XOR<SubjectCreateWithoutBibEntriesInput, SubjectUncheckedCreateWithoutBibEntriesInput> | SubjectCreateWithoutBibEntriesInput[] | SubjectUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBibEntriesInput | SubjectCreateOrConnectWithoutBibEntriesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type MdxNoteUncheckedCreateNestedManyWithoutCitationsInput = {
    create?: XOR<MdxNoteCreateWithoutCitationsInput, MdxNoteUncheckedCreateWithoutCitationsInput> | MdxNoteCreateWithoutCitationsInput[] | MdxNoteUncheckedCreateWithoutCitationsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutCitationsInput | MdxNoteCreateOrConnectWithoutCitationsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbUncheckedCreateNestedManyWithoutCitationsInput = {
    create?: XOR<IpynbCreateWithoutCitationsInput, IpynbUncheckedCreateWithoutCitationsInput> | IpynbCreateWithoutCitationsInput[] | IpynbUncheckedCreateWithoutCitationsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutCitationsInput | IpynbCreateOrConnectWithoutCitationsInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput = {
    create?: XOR<ReadingListCreateWithoutBibEntriesInput, ReadingListUncheckedCreateWithoutBibEntriesInput> | ReadingListCreateWithoutBibEntriesInput[] | ReadingListUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutBibEntriesInput | ReadingListCreateOrConnectWithoutBibEntriesInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
  }

  export type BibUpdateOneWithoutEntriesNestedInput = {
    create?: XOR<BibCreateWithoutEntriesInput, BibUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: BibCreateOrConnectWithoutEntriesInput
    upsert?: BibUpsertWithoutEntriesInput
    disconnect?: BibWhereInput | boolean
    delete?: BibWhereInput | boolean
    connect?: BibWhereUniqueInput
    update?: XOR<XOR<BibUpdateToOneWithWhereWithoutEntriesInput, BibUpdateWithoutEntriesInput>, BibUncheckedUpdateWithoutEntriesInput>
  }

  export type CitationsGroupUpdateManyWithoutEntriesNestedInput = {
    create?: XOR<CitationsGroupCreateWithoutEntriesInput, CitationsGroupUncheckedCreateWithoutEntriesInput> | CitationsGroupCreateWithoutEntriesInput[] | CitationsGroupUncheckedCreateWithoutEntriesInput[]
    connectOrCreate?: CitationsGroupCreateOrConnectWithoutEntriesInput | CitationsGroupCreateOrConnectWithoutEntriesInput[]
    upsert?: CitationsGroupUpsertWithWhereUniqueWithoutEntriesInput | CitationsGroupUpsertWithWhereUniqueWithoutEntriesInput[]
    set?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
    disconnect?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
    delete?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
    connect?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
    update?: CitationsGroupUpdateWithWhereUniqueWithoutEntriesInput | CitationsGroupUpdateWithWhereUniqueWithoutEntriesInput[]
    updateMany?: CitationsGroupUpdateManyWithWhereWithoutEntriesInput | CitationsGroupUpdateManyWithWhereWithoutEntriesInput[]
    deleteMany?: CitationsGroupScalarWhereInput | CitationsGroupScalarWhereInput[]
  }

  export type TagUpdateManyWithoutBibEntriesNestedInput = {
    create?: XOR<TagCreateWithoutBibEntriesInput, TagUncheckedCreateWithoutBibEntriesInput> | TagCreateWithoutBibEntriesInput[] | TagUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutBibEntriesInput | TagCreateOrConnectWithoutBibEntriesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutBibEntriesInput | TagUpsertWithWhereUniqueWithoutBibEntriesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutBibEntriesInput | TagUpdateWithWhereUniqueWithoutBibEntriesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutBibEntriesInput | TagUpdateManyWithWhereWithoutBibEntriesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutBibEntriesNestedInput = {
    create?: XOR<TopicCreateWithoutBibEntriesInput, TopicUncheckedCreateWithoutBibEntriesInput> | TopicCreateWithoutBibEntriesInput[] | TopicUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBibEntriesInput | TopicCreateOrConnectWithoutBibEntriesInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutBibEntriesInput | TopicUpsertWithWhereUniqueWithoutBibEntriesInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutBibEntriesInput | TopicUpdateWithWhereUniqueWithoutBibEntriesInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutBibEntriesInput | TopicUpdateManyWithWhereWithoutBibEntriesInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutBibEntriesNestedInput = {
    create?: XOR<SubjectCreateWithoutBibEntriesInput, SubjectUncheckedCreateWithoutBibEntriesInput> | SubjectCreateWithoutBibEntriesInput[] | SubjectUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBibEntriesInput | SubjectCreateOrConnectWithoutBibEntriesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutBibEntriesInput | SubjectUpsertWithWhereUniqueWithoutBibEntriesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutBibEntriesInput | SubjectUpdateWithWhereUniqueWithoutBibEntriesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutBibEntriesInput | SubjectUpdateManyWithWhereWithoutBibEntriesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type MdxNoteUpdateManyWithoutCitationsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutCitationsInput, MdxNoteUncheckedCreateWithoutCitationsInput> | MdxNoteCreateWithoutCitationsInput[] | MdxNoteUncheckedCreateWithoutCitationsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutCitationsInput | MdxNoteCreateOrConnectWithoutCitationsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutCitationsInput | MdxNoteUpsertWithWhereUniqueWithoutCitationsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutCitationsInput | MdxNoteUpdateWithWhereUniqueWithoutCitationsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutCitationsInput | MdxNoteUpdateManyWithWhereWithoutCitationsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUpdateManyWithoutCitationsNestedInput = {
    create?: XOR<IpynbCreateWithoutCitationsInput, IpynbUncheckedCreateWithoutCitationsInput> | IpynbCreateWithoutCitationsInput[] | IpynbUncheckedCreateWithoutCitationsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutCitationsInput | IpynbCreateOrConnectWithoutCitationsInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutCitationsInput | IpynbUpsertWithWhereUniqueWithoutCitationsInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutCitationsInput | IpynbUpdateWithWhereUniqueWithoutCitationsInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutCitationsInput | IpynbUpdateManyWithWhereWithoutCitationsInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type ReadingListUpdateManyWithoutBibEntriesNestedInput = {
    create?: XOR<ReadingListCreateWithoutBibEntriesInput, ReadingListUncheckedCreateWithoutBibEntriesInput> | ReadingListCreateWithoutBibEntriesInput[] | ReadingListUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutBibEntriesInput | ReadingListCreateOrConnectWithoutBibEntriesInput[]
    upsert?: ReadingListUpsertWithWhereUniqueWithoutBibEntriesInput | ReadingListUpsertWithWhereUniqueWithoutBibEntriesInput[]
    set?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    disconnect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    delete?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    update?: ReadingListUpdateWithWhereUniqueWithoutBibEntriesInput | ReadingListUpdateWithWhereUniqueWithoutBibEntriesInput[]
    updateMany?: ReadingListUpdateManyWithWhereWithoutBibEntriesInput | ReadingListUpdateManyWithWhereWithoutBibEntriesInput[]
    deleteMany?: ReadingListScalarWhereInput | ReadingListScalarWhereInput[]
  }

  export type CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput = {
    create?: XOR<CitationsGroupCreateWithoutEntriesInput, CitationsGroupUncheckedCreateWithoutEntriesInput> | CitationsGroupCreateWithoutEntriesInput[] | CitationsGroupUncheckedCreateWithoutEntriesInput[]
    connectOrCreate?: CitationsGroupCreateOrConnectWithoutEntriesInput | CitationsGroupCreateOrConnectWithoutEntriesInput[]
    upsert?: CitationsGroupUpsertWithWhereUniqueWithoutEntriesInput | CitationsGroupUpsertWithWhereUniqueWithoutEntriesInput[]
    set?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
    disconnect?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
    delete?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
    connect?: CitationsGroupWhereUniqueInput | CitationsGroupWhereUniqueInput[]
    update?: CitationsGroupUpdateWithWhereUniqueWithoutEntriesInput | CitationsGroupUpdateWithWhereUniqueWithoutEntriesInput[]
    updateMany?: CitationsGroupUpdateManyWithWhereWithoutEntriesInput | CitationsGroupUpdateManyWithWhereWithoutEntriesInput[]
    deleteMany?: CitationsGroupScalarWhereInput | CitationsGroupScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutBibEntriesNestedInput = {
    create?: XOR<TagCreateWithoutBibEntriesInput, TagUncheckedCreateWithoutBibEntriesInput> | TagCreateWithoutBibEntriesInput[] | TagUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutBibEntriesInput | TagCreateOrConnectWithoutBibEntriesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutBibEntriesInput | TagUpsertWithWhereUniqueWithoutBibEntriesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutBibEntriesInput | TagUpdateWithWhereUniqueWithoutBibEntriesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutBibEntriesInput | TagUpdateManyWithWhereWithoutBibEntriesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutBibEntriesNestedInput = {
    create?: XOR<TopicCreateWithoutBibEntriesInput, TopicUncheckedCreateWithoutBibEntriesInput> | TopicCreateWithoutBibEntriesInput[] | TopicUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBibEntriesInput | TopicCreateOrConnectWithoutBibEntriesInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutBibEntriesInput | TopicUpsertWithWhereUniqueWithoutBibEntriesInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutBibEntriesInput | TopicUpdateWithWhereUniqueWithoutBibEntriesInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutBibEntriesInput | TopicUpdateManyWithWhereWithoutBibEntriesInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput = {
    create?: XOR<SubjectCreateWithoutBibEntriesInput, SubjectUncheckedCreateWithoutBibEntriesInput> | SubjectCreateWithoutBibEntriesInput[] | SubjectUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBibEntriesInput | SubjectCreateOrConnectWithoutBibEntriesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutBibEntriesInput | SubjectUpsertWithWhereUniqueWithoutBibEntriesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutBibEntriesInput | SubjectUpdateWithWhereUniqueWithoutBibEntriesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutBibEntriesInput | SubjectUpdateManyWithWhereWithoutBibEntriesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutCitationsInput, MdxNoteUncheckedCreateWithoutCitationsInput> | MdxNoteCreateWithoutCitationsInput[] | MdxNoteUncheckedCreateWithoutCitationsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutCitationsInput | MdxNoteCreateOrConnectWithoutCitationsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutCitationsInput | MdxNoteUpsertWithWhereUniqueWithoutCitationsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutCitationsInput | MdxNoteUpdateWithWhereUniqueWithoutCitationsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutCitationsInput | MdxNoteUpdateManyWithWhereWithoutCitationsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUncheckedUpdateManyWithoutCitationsNestedInput = {
    create?: XOR<IpynbCreateWithoutCitationsInput, IpynbUncheckedCreateWithoutCitationsInput> | IpynbCreateWithoutCitationsInput[] | IpynbUncheckedCreateWithoutCitationsInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutCitationsInput | IpynbCreateOrConnectWithoutCitationsInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutCitationsInput | IpynbUpsertWithWhereUniqueWithoutCitationsInput[]
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutCitationsInput | IpynbUpdateWithWhereUniqueWithoutCitationsInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutCitationsInput | IpynbUpdateManyWithWhereWithoutCitationsInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput = {
    create?: XOR<ReadingListCreateWithoutBibEntriesInput, ReadingListUncheckedCreateWithoutBibEntriesInput> | ReadingListCreateWithoutBibEntriesInput[] | ReadingListUncheckedCreateWithoutBibEntriesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutBibEntriesInput | ReadingListCreateOrConnectWithoutBibEntriesInput[]
    upsert?: ReadingListUpsertWithWhereUniqueWithoutBibEntriesInput | ReadingListUpsertWithWhereUniqueWithoutBibEntriesInput[]
    set?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    disconnect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    delete?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    update?: ReadingListUpdateWithWhereUniqueWithoutBibEntriesInput | ReadingListUpdateWithWhereUniqueWithoutBibEntriesInput[]
    updateMany?: ReadingListUpdateManyWithWhereWithoutBibEntriesInput | ReadingListUpdateManyWithWhereWithoutBibEntriesInput[]
    deleteMany?: ReadingListScalarWhereInput | ReadingListScalarWhereInput[]
  }

  export type BibEntryCreateNestedManyWithoutCitationGroupsInput = {
    create?: XOR<BibEntryCreateWithoutCitationGroupsInput, BibEntryUncheckedCreateWithoutCitationGroupsInput> | BibEntryCreateWithoutCitationGroupsInput[] | BibEntryUncheckedCreateWithoutCitationGroupsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutCitationGroupsInput | BibEntryCreateOrConnectWithoutCitationGroupsInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type BibEntryUncheckedCreateNestedManyWithoutCitationGroupsInput = {
    create?: XOR<BibEntryCreateWithoutCitationGroupsInput, BibEntryUncheckedCreateWithoutCitationGroupsInput> | BibEntryCreateWithoutCitationGroupsInput[] | BibEntryUncheckedCreateWithoutCitationGroupsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutCitationGroupsInput | BibEntryCreateOrConnectWithoutCitationGroupsInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type BibEntryUpdateManyWithoutCitationGroupsNestedInput = {
    create?: XOR<BibEntryCreateWithoutCitationGroupsInput, BibEntryUncheckedCreateWithoutCitationGroupsInput> | BibEntryCreateWithoutCitationGroupsInput[] | BibEntryUncheckedCreateWithoutCitationGroupsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutCitationGroupsInput | BibEntryCreateOrConnectWithoutCitationGroupsInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutCitationGroupsInput | BibEntryUpsertWithWhereUniqueWithoutCitationGroupsInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutCitationGroupsInput | BibEntryUpdateWithWhereUniqueWithoutCitationGroupsInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutCitationGroupsInput | BibEntryUpdateManyWithWhereWithoutCitationGroupsInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type BibEntryUncheckedUpdateManyWithoutCitationGroupsNestedInput = {
    create?: XOR<BibEntryCreateWithoutCitationGroupsInput, BibEntryUncheckedCreateWithoutCitationGroupsInput> | BibEntryCreateWithoutCitationGroupsInput[] | BibEntryUncheckedCreateWithoutCitationGroupsInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutCitationGroupsInput | BibEntryCreateOrConnectWithoutCitationGroupsInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutCitationGroupsInput | BibEntryUpsertWithWhereUniqueWithoutCitationGroupsInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutCitationGroupsInput | BibEntryUpdateWithWhereUniqueWithoutCitationGroupsInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutCitationGroupsInput | BibEntryUpdateManyWithWhereWithoutCitationGroupsInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type BibEntryCreateNestedManyWithoutBibInput = {
    create?: XOR<BibEntryCreateWithoutBibInput, BibEntryUncheckedCreateWithoutBibInput> | BibEntryCreateWithoutBibInput[] | BibEntryUncheckedCreateWithoutBibInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutBibInput | BibEntryCreateOrConnectWithoutBibInput[]
    createMany?: BibEntryCreateManyBibInputEnvelope
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type BibEntryUncheckedCreateNestedManyWithoutBibInput = {
    create?: XOR<BibEntryCreateWithoutBibInput, BibEntryUncheckedCreateWithoutBibInput> | BibEntryCreateWithoutBibInput[] | BibEntryUncheckedCreateWithoutBibInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutBibInput | BibEntryCreateOrConnectWithoutBibInput[]
    createMany?: BibEntryCreateManyBibInputEnvelope
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type BibEntryUpdateManyWithoutBibNestedInput = {
    create?: XOR<BibEntryCreateWithoutBibInput, BibEntryUncheckedCreateWithoutBibInput> | BibEntryCreateWithoutBibInput[] | BibEntryUncheckedCreateWithoutBibInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutBibInput | BibEntryCreateOrConnectWithoutBibInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutBibInput | BibEntryUpsertWithWhereUniqueWithoutBibInput[]
    createMany?: BibEntryCreateManyBibInputEnvelope
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutBibInput | BibEntryUpdateWithWhereUniqueWithoutBibInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutBibInput | BibEntryUpdateManyWithWhereWithoutBibInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type BibEntryUncheckedUpdateManyWithoutBibNestedInput = {
    create?: XOR<BibEntryCreateWithoutBibInput, BibEntryUncheckedCreateWithoutBibInput> | BibEntryCreateWithoutBibInput[] | BibEntryUncheckedCreateWithoutBibInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutBibInput | BibEntryCreateOrConnectWithoutBibInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutBibInput | BibEntryUpsertWithWhereUniqueWithoutBibInput[]
    createMany?: BibEntryCreateManyBibInputEnvelope
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutBibInput | BibEntryUpdateWithWhereUniqueWithoutBibInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutBibInput | BibEntryUpdateManyWithWhereWithoutBibInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type SnippetCreatekeywordsInput = {
    set: string[]
  }

  export type SnippetUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumTechnologiesFieldUpdateOperationsInput = {
    set?: $Enums.Technologies
  }

  export type RelatedValuesCreateequationIdInput = {
    set: number[]
  }

  export type EquationCreateNestedManyWithoutRelatedValuesInput = {
    create?: XOR<EquationCreateWithoutRelatedValuesInput, EquationUncheckedCreateWithoutRelatedValuesInput> | EquationCreateWithoutRelatedValuesInput[] | EquationUncheckedCreateWithoutRelatedValuesInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutRelatedValuesInput | EquationCreateOrConnectWithoutRelatedValuesInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type EquationUncheckedCreateNestedManyWithoutRelatedValuesInput = {
    create?: XOR<EquationCreateWithoutRelatedValuesInput, EquationUncheckedCreateWithoutRelatedValuesInput> | EquationCreateWithoutRelatedValuesInput[] | EquationUncheckedCreateWithoutRelatedValuesInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutRelatedValuesInput | EquationCreateOrConnectWithoutRelatedValuesInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RelatedValuesUpdateequationIdInput = {
    set?: number[]
    push?: number | number[]
  }

  export type EquationUpdateManyWithoutRelatedValuesNestedInput = {
    create?: XOR<EquationCreateWithoutRelatedValuesInput, EquationUncheckedCreateWithoutRelatedValuesInput> | EquationCreateWithoutRelatedValuesInput[] | EquationUncheckedCreateWithoutRelatedValuesInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutRelatedValuesInput | EquationCreateOrConnectWithoutRelatedValuesInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutRelatedValuesInput | EquationUpsertWithWhereUniqueWithoutRelatedValuesInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutRelatedValuesInput | EquationUpdateWithWhereUniqueWithoutRelatedValuesInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutRelatedValuesInput | EquationUpdateManyWithWhereWithoutRelatedValuesInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type EquationUncheckedUpdateManyWithoutRelatedValuesNestedInput = {
    create?: XOR<EquationCreateWithoutRelatedValuesInput, EquationUncheckedCreateWithoutRelatedValuesInput> | EquationCreateWithoutRelatedValuesInput[] | EquationUncheckedCreateWithoutRelatedValuesInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutRelatedValuesInput | EquationCreateOrConnectWithoutRelatedValuesInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutRelatedValuesInput | EquationUpsertWithWhereUniqueWithoutRelatedValuesInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutRelatedValuesInput | EquationUpdateWithWhereUniqueWithoutRelatedValuesInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutRelatedValuesInput | EquationUpdateManyWithWhereWithoutRelatedValuesInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type EquationCreatevariablesInput = {
    set: string[]
  }

  export type EquationCreatekeywordsInput = {
    set: string[]
  }

  export type RelatedValuesCreateNestedManyWithoutEquationsInput = {
    create?: XOR<RelatedValuesCreateWithoutEquationsInput, RelatedValuesUncheckedCreateWithoutEquationsInput> | RelatedValuesCreateWithoutEquationsInput[] | RelatedValuesUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: RelatedValuesCreateOrConnectWithoutEquationsInput | RelatedValuesCreateOrConnectWithoutEquationsInput[]
    connect?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutEquationsInput = {
    create?: XOR<TagCreateWithoutEquationsInput, TagUncheckedCreateWithoutEquationsInput> | TagCreateWithoutEquationsInput[] | TagUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutEquationsInput | TagCreateOrConnectWithoutEquationsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutEquationsInput = {
    create?: XOR<TopicCreateWithoutEquationsInput, TopicUncheckedCreateWithoutEquationsInput> | TopicCreateWithoutEquationsInput[] | TopicUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutEquationsInput | TopicCreateOrConnectWithoutEquationsInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutEquationsInput = {
    create?: XOR<SubjectCreateWithoutEquationsInput, SubjectUncheckedCreateWithoutEquationsInput> | SubjectCreateWithoutEquationsInput[] | SubjectUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutEquationsInput | SubjectCreateOrConnectWithoutEquationsInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type MdxNoteCreateNestedManyWithoutEquationsInput = {
    create?: XOR<MdxNoteCreateWithoutEquationsInput, MdxNoteUncheckedCreateWithoutEquationsInput> | MdxNoteCreateWithoutEquationsInput[] | MdxNoteUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutEquationsInput | MdxNoteCreateOrConnectWithoutEquationsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type RelatedValuesUncheckedCreateNestedManyWithoutEquationsInput = {
    create?: XOR<RelatedValuesCreateWithoutEquationsInput, RelatedValuesUncheckedCreateWithoutEquationsInput> | RelatedValuesCreateWithoutEquationsInput[] | RelatedValuesUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: RelatedValuesCreateOrConnectWithoutEquationsInput | RelatedValuesCreateOrConnectWithoutEquationsInput[]
    connect?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutEquationsInput = {
    create?: XOR<TagCreateWithoutEquationsInput, TagUncheckedCreateWithoutEquationsInput> | TagCreateWithoutEquationsInput[] | TagUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutEquationsInput | TagCreateOrConnectWithoutEquationsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutEquationsInput = {
    create?: XOR<TopicCreateWithoutEquationsInput, TopicUncheckedCreateWithoutEquationsInput> | TopicCreateWithoutEquationsInput[] | TopicUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutEquationsInput | TopicCreateOrConnectWithoutEquationsInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutEquationsInput = {
    create?: XOR<SubjectCreateWithoutEquationsInput, SubjectUncheckedCreateWithoutEquationsInput> | SubjectCreateWithoutEquationsInput[] | SubjectUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutEquationsInput | SubjectCreateOrConnectWithoutEquationsInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type MdxNoteUncheckedCreateNestedManyWithoutEquationsInput = {
    create?: XOR<MdxNoteCreateWithoutEquationsInput, MdxNoteUncheckedCreateWithoutEquationsInput> | MdxNoteCreateWithoutEquationsInput[] | MdxNoteUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutEquationsInput | MdxNoteCreateOrConnectWithoutEquationsInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type EquationUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EquationUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RelatedValuesUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<RelatedValuesCreateWithoutEquationsInput, RelatedValuesUncheckedCreateWithoutEquationsInput> | RelatedValuesCreateWithoutEquationsInput[] | RelatedValuesUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: RelatedValuesCreateOrConnectWithoutEquationsInput | RelatedValuesCreateOrConnectWithoutEquationsInput[]
    upsert?: RelatedValuesUpsertWithWhereUniqueWithoutEquationsInput | RelatedValuesUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
    disconnect?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
    delete?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
    connect?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
    update?: RelatedValuesUpdateWithWhereUniqueWithoutEquationsInput | RelatedValuesUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: RelatedValuesUpdateManyWithWhereWithoutEquationsInput | RelatedValuesUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: RelatedValuesScalarWhereInput | RelatedValuesScalarWhereInput[]
  }

  export type TagUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<TagCreateWithoutEquationsInput, TagUncheckedCreateWithoutEquationsInput> | TagCreateWithoutEquationsInput[] | TagUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutEquationsInput | TagCreateOrConnectWithoutEquationsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutEquationsInput | TagUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutEquationsInput | TagUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutEquationsInput | TagUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<TopicCreateWithoutEquationsInput, TopicUncheckedCreateWithoutEquationsInput> | TopicCreateWithoutEquationsInput[] | TopicUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutEquationsInput | TopicCreateOrConnectWithoutEquationsInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutEquationsInput | TopicUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutEquationsInput | TopicUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutEquationsInput | TopicUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<SubjectCreateWithoutEquationsInput, SubjectUncheckedCreateWithoutEquationsInput> | SubjectCreateWithoutEquationsInput[] | SubjectUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutEquationsInput | SubjectCreateOrConnectWithoutEquationsInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutEquationsInput | SubjectUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutEquationsInput | SubjectUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutEquationsInput | SubjectUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type MdxNoteUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutEquationsInput, MdxNoteUncheckedCreateWithoutEquationsInput> | MdxNoteCreateWithoutEquationsInput[] | MdxNoteUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutEquationsInput | MdxNoteCreateOrConnectWithoutEquationsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutEquationsInput | MdxNoteUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutEquationsInput | MdxNoteUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutEquationsInput | MdxNoteUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type RelatedValuesUncheckedUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<RelatedValuesCreateWithoutEquationsInput, RelatedValuesUncheckedCreateWithoutEquationsInput> | RelatedValuesCreateWithoutEquationsInput[] | RelatedValuesUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: RelatedValuesCreateOrConnectWithoutEquationsInput | RelatedValuesCreateOrConnectWithoutEquationsInput[]
    upsert?: RelatedValuesUpsertWithWhereUniqueWithoutEquationsInput | RelatedValuesUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
    disconnect?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
    delete?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
    connect?: RelatedValuesWhereUniqueInput | RelatedValuesWhereUniqueInput[]
    update?: RelatedValuesUpdateWithWhereUniqueWithoutEquationsInput | RelatedValuesUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: RelatedValuesUpdateManyWithWhereWithoutEquationsInput | RelatedValuesUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: RelatedValuesScalarWhereInput | RelatedValuesScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<TagCreateWithoutEquationsInput, TagUncheckedCreateWithoutEquationsInput> | TagCreateWithoutEquationsInput[] | TagUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutEquationsInput | TagCreateOrConnectWithoutEquationsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutEquationsInput | TagUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutEquationsInput | TagUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutEquationsInput | TagUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<TopicCreateWithoutEquationsInput, TopicUncheckedCreateWithoutEquationsInput> | TopicCreateWithoutEquationsInput[] | TopicUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutEquationsInput | TopicCreateOrConnectWithoutEquationsInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutEquationsInput | TopicUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutEquationsInput | TopicUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutEquationsInput | TopicUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<SubjectCreateWithoutEquationsInput, SubjectUncheckedCreateWithoutEquationsInput> | SubjectCreateWithoutEquationsInput[] | SubjectUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutEquationsInput | SubjectCreateOrConnectWithoutEquationsInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutEquationsInput | SubjectUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutEquationsInput | SubjectUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutEquationsInput | SubjectUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type MdxNoteUncheckedUpdateManyWithoutEquationsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutEquationsInput, MdxNoteUncheckedCreateWithoutEquationsInput> | MdxNoteCreateWithoutEquationsInput[] | MdxNoteUncheckedCreateWithoutEquationsInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutEquationsInput | MdxNoteCreateOrConnectWithoutEquationsInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutEquationsInput | MdxNoteUpsertWithWhereUniqueWithoutEquationsInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutEquationsInput | MdxNoteUpdateWithWhereUniqueWithoutEquationsInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutEquationsInput | MdxNoteUpdateManyWithWhereWithoutEquationsInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type MdxNoteCreateNestedOneWithoutDefinitionsInput = {
    create?: XOR<MdxNoteCreateWithoutDefinitionsInput, MdxNoteUncheckedCreateWithoutDefinitionsInput>
    connectOrCreate?: MdxNoteCreateOrConnectWithoutDefinitionsInput
    connect?: MdxNoteWhereUniqueInput
  }

  export type MdxNoteUpdateOneWithoutDefinitionsNestedInput = {
    create?: XOR<MdxNoteCreateWithoutDefinitionsInput, MdxNoteUncheckedCreateWithoutDefinitionsInput>
    connectOrCreate?: MdxNoteCreateOrConnectWithoutDefinitionsInput
    upsert?: MdxNoteUpsertWithoutDefinitionsInput
    disconnect?: MdxNoteWhereInput | boolean
    delete?: MdxNoteWhereInput | boolean
    connect?: MdxNoteWhereUniqueInput
    update?: XOR<XOR<MdxNoteUpdateToOneWithWhereWithoutDefinitionsInput, MdxNoteUpdateWithoutDefinitionsInput>, MdxNoteUncheckedUpdateWithoutDefinitionsInput>
  }

  export type EnumImageAlignmentFieldUpdateOperationsInput = {
    set?: $Enums.ImageAlignment
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type TagCreateNestedManyWithoutQAPairInput = {
    create?: XOR<TagCreateWithoutQAPairInput, TagUncheckedCreateWithoutQAPairInput> | TagCreateWithoutQAPairInput[] | TagUncheckedCreateWithoutQAPairInput[]
    connectOrCreate?: TagCreateOrConnectWithoutQAPairInput | TagCreateOrConnectWithoutQAPairInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutQAPairInput = {
    create?: XOR<TopicCreateWithoutQAPairInput, TopicUncheckedCreateWithoutQAPairInput> | TopicCreateWithoutQAPairInput[] | TopicUncheckedCreateWithoutQAPairInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutQAPairInput | TopicCreateOrConnectWithoutQAPairInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutQaPairInput = {
    create?: XOR<SubjectCreateWithoutQaPairInput, SubjectUncheckedCreateWithoutQaPairInput> | SubjectCreateWithoutQaPairInput[] | SubjectUncheckedCreateWithoutQaPairInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutQaPairInput | SubjectCreateOrConnectWithoutQaPairInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type PracticeExamCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<PracticeExamCreateWithoutQuestionsInput, PracticeExamUncheckedCreateWithoutQuestionsInput> | PracticeExamCreateWithoutQuestionsInput[] | PracticeExamUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutQuestionsInput | PracticeExamCreateOrConnectWithoutQuestionsInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutQAPairInput = {
    create?: XOR<TagCreateWithoutQAPairInput, TagUncheckedCreateWithoutQAPairInput> | TagCreateWithoutQAPairInput[] | TagUncheckedCreateWithoutQAPairInput[]
    connectOrCreate?: TagCreateOrConnectWithoutQAPairInput | TagCreateOrConnectWithoutQAPairInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutQAPairInput = {
    create?: XOR<TopicCreateWithoutQAPairInput, TopicUncheckedCreateWithoutQAPairInput> | TopicCreateWithoutQAPairInput[] | TopicUncheckedCreateWithoutQAPairInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutQAPairInput | TopicCreateOrConnectWithoutQAPairInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutQaPairInput = {
    create?: XOR<SubjectCreateWithoutQaPairInput, SubjectUncheckedCreateWithoutQaPairInput> | SubjectCreateWithoutQaPairInput[] | SubjectUncheckedCreateWithoutQaPairInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutQaPairInput | SubjectCreateOrConnectWithoutQaPairInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type PracticeExamUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<PracticeExamCreateWithoutQuestionsInput, PracticeExamUncheckedCreateWithoutQuestionsInput> | PracticeExamCreateWithoutQuestionsInput[] | PracticeExamUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutQuestionsInput | PracticeExamCreateOrConnectWithoutQuestionsInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
  }

  export type TagUpdateManyWithoutQAPairNestedInput = {
    create?: XOR<TagCreateWithoutQAPairInput, TagUncheckedCreateWithoutQAPairInput> | TagCreateWithoutQAPairInput[] | TagUncheckedCreateWithoutQAPairInput[]
    connectOrCreate?: TagCreateOrConnectWithoutQAPairInput | TagCreateOrConnectWithoutQAPairInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutQAPairInput | TagUpsertWithWhereUniqueWithoutQAPairInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutQAPairInput | TagUpdateWithWhereUniqueWithoutQAPairInput[]
    updateMany?: TagUpdateManyWithWhereWithoutQAPairInput | TagUpdateManyWithWhereWithoutQAPairInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutQAPairNestedInput = {
    create?: XOR<TopicCreateWithoutQAPairInput, TopicUncheckedCreateWithoutQAPairInput> | TopicCreateWithoutQAPairInput[] | TopicUncheckedCreateWithoutQAPairInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutQAPairInput | TopicCreateOrConnectWithoutQAPairInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutQAPairInput | TopicUpsertWithWhereUniqueWithoutQAPairInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutQAPairInput | TopicUpdateWithWhereUniqueWithoutQAPairInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutQAPairInput | TopicUpdateManyWithWhereWithoutQAPairInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutQaPairNestedInput = {
    create?: XOR<SubjectCreateWithoutQaPairInput, SubjectUncheckedCreateWithoutQaPairInput> | SubjectCreateWithoutQaPairInput[] | SubjectUncheckedCreateWithoutQaPairInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutQaPairInput | SubjectCreateOrConnectWithoutQaPairInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutQaPairInput | SubjectUpsertWithWhereUniqueWithoutQaPairInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutQaPairInput | SubjectUpdateWithWhereUniqueWithoutQaPairInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutQaPairInput | SubjectUpdateManyWithWhereWithoutQaPairInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type PracticeExamUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<PracticeExamCreateWithoutQuestionsInput, PracticeExamUncheckedCreateWithoutQuestionsInput> | PracticeExamCreateWithoutQuestionsInput[] | PracticeExamUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutQuestionsInput | PracticeExamCreateOrConnectWithoutQuestionsInput[]
    upsert?: PracticeExamUpsertWithWhereUniqueWithoutQuestionsInput | PracticeExamUpsertWithWhereUniqueWithoutQuestionsInput[]
    set?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    disconnect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    delete?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    update?: PracticeExamUpdateWithWhereUniqueWithoutQuestionsInput | PracticeExamUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: PracticeExamUpdateManyWithWhereWithoutQuestionsInput | PracticeExamUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutQAPairNestedInput = {
    create?: XOR<TagCreateWithoutQAPairInput, TagUncheckedCreateWithoutQAPairInput> | TagCreateWithoutQAPairInput[] | TagUncheckedCreateWithoutQAPairInput[]
    connectOrCreate?: TagCreateOrConnectWithoutQAPairInput | TagCreateOrConnectWithoutQAPairInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutQAPairInput | TagUpsertWithWhereUniqueWithoutQAPairInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutQAPairInput | TagUpdateWithWhereUniqueWithoutQAPairInput[]
    updateMany?: TagUpdateManyWithWhereWithoutQAPairInput | TagUpdateManyWithWhereWithoutQAPairInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutQAPairNestedInput = {
    create?: XOR<TopicCreateWithoutQAPairInput, TopicUncheckedCreateWithoutQAPairInput> | TopicCreateWithoutQAPairInput[] | TopicUncheckedCreateWithoutQAPairInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutQAPairInput | TopicCreateOrConnectWithoutQAPairInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutQAPairInput | TopicUpsertWithWhereUniqueWithoutQAPairInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutQAPairInput | TopicUpdateWithWhereUniqueWithoutQAPairInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutQAPairInput | TopicUpdateManyWithWhereWithoutQAPairInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutQaPairNestedInput = {
    create?: XOR<SubjectCreateWithoutQaPairInput, SubjectUncheckedCreateWithoutQaPairInput> | SubjectCreateWithoutQaPairInput[] | SubjectUncheckedCreateWithoutQaPairInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutQaPairInput | SubjectCreateOrConnectWithoutQaPairInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutQaPairInput | SubjectUpsertWithWhereUniqueWithoutQaPairInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutQaPairInput | SubjectUpdateWithWhereUniqueWithoutQaPairInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutQaPairInput | SubjectUpdateManyWithWhereWithoutQaPairInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type PracticeExamUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<PracticeExamCreateWithoutQuestionsInput, PracticeExamUncheckedCreateWithoutQuestionsInput> | PracticeExamCreateWithoutQuestionsInput[] | PracticeExamUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: PracticeExamCreateOrConnectWithoutQuestionsInput | PracticeExamCreateOrConnectWithoutQuestionsInput[]
    upsert?: PracticeExamUpsertWithWhereUniqueWithoutQuestionsInput | PracticeExamUpsertWithWhereUniqueWithoutQuestionsInput[]
    set?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    disconnect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    delete?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    connect?: PracticeExamWhereUniqueInput | PracticeExamWhereUniqueInput[]
    update?: PracticeExamUpdateWithWhereUniqueWithoutQuestionsInput | PracticeExamUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: PracticeExamUpdateManyWithWhereWithoutQuestionsInput | PracticeExamUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
  }

  export type TopicCreateNestedManyWithoutPracticeExamInput = {
    create?: XOR<TopicCreateWithoutPracticeExamInput, TopicUncheckedCreateWithoutPracticeExamInput> | TopicCreateWithoutPracticeExamInput[] | TopicUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutPracticeExamInput | TopicCreateOrConnectWithoutPracticeExamInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutPracticeExamInput = {
    create?: XOR<TagCreateWithoutPracticeExamInput, TagUncheckedCreateWithoutPracticeExamInput> | TagCreateWithoutPracticeExamInput[] | TagUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPracticeExamInput | TagCreateOrConnectWithoutPracticeExamInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutPracticeExamInput = {
    create?: XOR<SubjectCreateWithoutPracticeExamInput, SubjectUncheckedCreateWithoutPracticeExamInput> | SubjectCreateWithoutPracticeExamInput[] | SubjectUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutPracticeExamInput | SubjectCreateOrConnectWithoutPracticeExamInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type QAPairCreateNestedManyWithoutPracticeExamInput = {
    create?: XOR<QAPairCreateWithoutPracticeExamInput, QAPairUncheckedCreateWithoutPracticeExamInput> | QAPairCreateWithoutPracticeExamInput[] | QAPairUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutPracticeExamInput | QAPairCreateOrConnectWithoutPracticeExamInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutPracticeExamInput = {
    create?: XOR<TopicCreateWithoutPracticeExamInput, TopicUncheckedCreateWithoutPracticeExamInput> | TopicCreateWithoutPracticeExamInput[] | TopicUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutPracticeExamInput | TopicCreateOrConnectWithoutPracticeExamInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutPracticeExamInput = {
    create?: XOR<TagCreateWithoutPracticeExamInput, TagUncheckedCreateWithoutPracticeExamInput> | TagCreateWithoutPracticeExamInput[] | TagUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPracticeExamInput | TagCreateOrConnectWithoutPracticeExamInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutPracticeExamInput = {
    create?: XOR<SubjectCreateWithoutPracticeExamInput, SubjectUncheckedCreateWithoutPracticeExamInput> | SubjectCreateWithoutPracticeExamInput[] | SubjectUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutPracticeExamInput | SubjectCreateOrConnectWithoutPracticeExamInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type QAPairUncheckedCreateNestedManyWithoutPracticeExamInput = {
    create?: XOR<QAPairCreateWithoutPracticeExamInput, QAPairUncheckedCreateWithoutPracticeExamInput> | QAPairCreateWithoutPracticeExamInput[] | QAPairUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutPracticeExamInput | QAPairCreateOrConnectWithoutPracticeExamInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type TopicUpdateManyWithoutPracticeExamNestedInput = {
    create?: XOR<TopicCreateWithoutPracticeExamInput, TopicUncheckedCreateWithoutPracticeExamInput> | TopicCreateWithoutPracticeExamInput[] | TopicUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutPracticeExamInput | TopicCreateOrConnectWithoutPracticeExamInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutPracticeExamInput | TopicUpsertWithWhereUniqueWithoutPracticeExamInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutPracticeExamInput | TopicUpdateWithWhereUniqueWithoutPracticeExamInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutPracticeExamInput | TopicUpdateManyWithWhereWithoutPracticeExamInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type TagUpdateManyWithoutPracticeExamNestedInput = {
    create?: XOR<TagCreateWithoutPracticeExamInput, TagUncheckedCreateWithoutPracticeExamInput> | TagCreateWithoutPracticeExamInput[] | TagUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPracticeExamInput | TagCreateOrConnectWithoutPracticeExamInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPracticeExamInput | TagUpsertWithWhereUniqueWithoutPracticeExamInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPracticeExamInput | TagUpdateWithWhereUniqueWithoutPracticeExamInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPracticeExamInput | TagUpdateManyWithWhereWithoutPracticeExamInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutPracticeExamNestedInput = {
    create?: XOR<SubjectCreateWithoutPracticeExamInput, SubjectUncheckedCreateWithoutPracticeExamInput> | SubjectCreateWithoutPracticeExamInput[] | SubjectUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutPracticeExamInput | SubjectCreateOrConnectWithoutPracticeExamInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutPracticeExamInput | SubjectUpsertWithWhereUniqueWithoutPracticeExamInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutPracticeExamInput | SubjectUpdateWithWhereUniqueWithoutPracticeExamInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutPracticeExamInput | SubjectUpdateManyWithWhereWithoutPracticeExamInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type QAPairUpdateManyWithoutPracticeExamNestedInput = {
    create?: XOR<QAPairCreateWithoutPracticeExamInput, QAPairUncheckedCreateWithoutPracticeExamInput> | QAPairCreateWithoutPracticeExamInput[] | QAPairUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutPracticeExamInput | QAPairCreateOrConnectWithoutPracticeExamInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutPracticeExamInput | QAPairUpsertWithWhereUniqueWithoutPracticeExamInput[]
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutPracticeExamInput | QAPairUpdateWithWhereUniqueWithoutPracticeExamInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutPracticeExamInput | QAPairUpdateManyWithWhereWithoutPracticeExamInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutPracticeExamNestedInput = {
    create?: XOR<TopicCreateWithoutPracticeExamInput, TopicUncheckedCreateWithoutPracticeExamInput> | TopicCreateWithoutPracticeExamInput[] | TopicUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutPracticeExamInput | TopicCreateOrConnectWithoutPracticeExamInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutPracticeExamInput | TopicUpsertWithWhereUniqueWithoutPracticeExamInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutPracticeExamInput | TopicUpdateWithWhereUniqueWithoutPracticeExamInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutPracticeExamInput | TopicUpdateManyWithWhereWithoutPracticeExamInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutPracticeExamNestedInput = {
    create?: XOR<TagCreateWithoutPracticeExamInput, TagUncheckedCreateWithoutPracticeExamInput> | TagCreateWithoutPracticeExamInput[] | TagUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPracticeExamInput | TagCreateOrConnectWithoutPracticeExamInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPracticeExamInput | TagUpsertWithWhereUniqueWithoutPracticeExamInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPracticeExamInput | TagUpdateWithWhereUniqueWithoutPracticeExamInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPracticeExamInput | TagUpdateManyWithWhereWithoutPracticeExamInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutPracticeExamNestedInput = {
    create?: XOR<SubjectCreateWithoutPracticeExamInput, SubjectUncheckedCreateWithoutPracticeExamInput> | SubjectCreateWithoutPracticeExamInput[] | SubjectUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutPracticeExamInput | SubjectCreateOrConnectWithoutPracticeExamInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutPracticeExamInput | SubjectUpsertWithWhereUniqueWithoutPracticeExamInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutPracticeExamInput | SubjectUpdateWithWhereUniqueWithoutPracticeExamInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutPracticeExamInput | SubjectUpdateManyWithWhereWithoutPracticeExamInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type QAPairUncheckedUpdateManyWithoutPracticeExamNestedInput = {
    create?: XOR<QAPairCreateWithoutPracticeExamInput, QAPairUncheckedCreateWithoutPracticeExamInput> | QAPairCreateWithoutPracticeExamInput[] | QAPairUncheckedCreateWithoutPracticeExamInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutPracticeExamInput | QAPairCreateOrConnectWithoutPracticeExamInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutPracticeExamInput | QAPairUpsertWithWhereUniqueWithoutPracticeExamInput[]
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutPracticeExamInput | QAPairUpdateWithWhereUniqueWithoutPracticeExamInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutPracticeExamInput | QAPairUpdateManyWithWhereWithoutPracticeExamInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type MdxNoteCreateNestedManyWithoutSequentialListInput = {
    create?: XOR<MdxNoteCreateWithoutSequentialListInput, MdxNoteUncheckedCreateWithoutSequentialListInput> | MdxNoteCreateWithoutSequentialListInput[] | MdxNoteUncheckedCreateWithoutSequentialListInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutSequentialListInput | MdxNoteCreateOrConnectWithoutSequentialListInput[]
    createMany?: MdxNoteCreateManySequentialListInputEnvelope
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbCreateNestedManyWithoutSequentialListInput = {
    create?: XOR<IpynbCreateWithoutSequentialListInput, IpynbUncheckedCreateWithoutSequentialListInput> | IpynbCreateWithoutSequentialListInput[] | IpynbUncheckedCreateWithoutSequentialListInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutSequentialListInput | IpynbCreateOrConnectWithoutSequentialListInput[]
    createMany?: IpynbCreateManySequentialListInputEnvelope
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type MdxNoteUncheckedCreateNestedManyWithoutSequentialListInput = {
    create?: XOR<MdxNoteCreateWithoutSequentialListInput, MdxNoteUncheckedCreateWithoutSequentialListInput> | MdxNoteCreateWithoutSequentialListInput[] | MdxNoteUncheckedCreateWithoutSequentialListInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutSequentialListInput | MdxNoteCreateOrConnectWithoutSequentialListInput[]
    createMany?: MdxNoteCreateManySequentialListInputEnvelope
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type IpynbUncheckedCreateNestedManyWithoutSequentialListInput = {
    create?: XOR<IpynbCreateWithoutSequentialListInput, IpynbUncheckedCreateWithoutSequentialListInput> | IpynbCreateWithoutSequentialListInput[] | IpynbUncheckedCreateWithoutSequentialListInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutSequentialListInput | IpynbCreateOrConnectWithoutSequentialListInput[]
    createMany?: IpynbCreateManySequentialListInputEnvelope
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
  }

  export type MdxNoteUpdateManyWithoutSequentialListNestedInput = {
    create?: XOR<MdxNoteCreateWithoutSequentialListInput, MdxNoteUncheckedCreateWithoutSequentialListInput> | MdxNoteCreateWithoutSequentialListInput[] | MdxNoteUncheckedCreateWithoutSequentialListInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutSequentialListInput | MdxNoteCreateOrConnectWithoutSequentialListInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutSequentialListInput | MdxNoteUpsertWithWhereUniqueWithoutSequentialListInput[]
    createMany?: MdxNoteCreateManySequentialListInputEnvelope
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutSequentialListInput | MdxNoteUpdateWithWhereUniqueWithoutSequentialListInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutSequentialListInput | MdxNoteUpdateManyWithWhereWithoutSequentialListInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUpdateManyWithoutSequentialListNestedInput = {
    create?: XOR<IpynbCreateWithoutSequentialListInput, IpynbUncheckedCreateWithoutSequentialListInput> | IpynbCreateWithoutSequentialListInput[] | IpynbUncheckedCreateWithoutSequentialListInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutSequentialListInput | IpynbCreateOrConnectWithoutSequentialListInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutSequentialListInput | IpynbUpsertWithWhereUniqueWithoutSequentialListInput[]
    createMany?: IpynbCreateManySequentialListInputEnvelope
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutSequentialListInput | IpynbUpdateWithWhereUniqueWithoutSequentialListInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutSequentialListInput | IpynbUpdateManyWithWhereWithoutSequentialListInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type MdxNoteUncheckedUpdateManyWithoutSequentialListNestedInput = {
    create?: XOR<MdxNoteCreateWithoutSequentialListInput, MdxNoteUncheckedCreateWithoutSequentialListInput> | MdxNoteCreateWithoutSequentialListInput[] | MdxNoteUncheckedCreateWithoutSequentialListInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutSequentialListInput | MdxNoteCreateOrConnectWithoutSequentialListInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutSequentialListInput | MdxNoteUpsertWithWhereUniqueWithoutSequentialListInput[]
    createMany?: MdxNoteCreateManySequentialListInputEnvelope
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutSequentialListInput | MdxNoteUpdateWithWhereUniqueWithoutSequentialListInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutSequentialListInput | MdxNoteUpdateManyWithWhereWithoutSequentialListInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type IpynbUncheckedUpdateManyWithoutSequentialListNestedInput = {
    create?: XOR<IpynbCreateWithoutSequentialListInput, IpynbUncheckedCreateWithoutSequentialListInput> | IpynbCreateWithoutSequentialListInput[] | IpynbUncheckedCreateWithoutSequentialListInput[]
    connectOrCreate?: IpynbCreateOrConnectWithoutSequentialListInput | IpynbCreateOrConnectWithoutSequentialListInput[]
    upsert?: IpynbUpsertWithWhereUniqueWithoutSequentialListInput | IpynbUpsertWithWhereUniqueWithoutSequentialListInput[]
    createMany?: IpynbCreateManySequentialListInputEnvelope
    set?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    disconnect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    delete?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    connect?: IpynbWhereUniqueInput | IpynbWhereUniqueInput[]
    update?: IpynbUpdateWithWhereUniqueWithoutSequentialListInput | IpynbUpdateWithWhereUniqueWithoutSequentialListInput[]
    updateMany?: IpynbUpdateManyWithWhereWithoutSequentialListInput | IpynbUpdateManyWithWhereWithoutSequentialListInput[]
    deleteMany?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
  }

  export type MdxNoteCreatecitationsListOrderInput = {
    set: string[]
  }

  export type MdxNoteCreateimportantValuesInput = {
    set: number[]
  }

  export type MdxNoteCreateoutgoingQuickLinksInput = {
    set: string[]
  }

  export type TopicCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<TopicCreateWithoutMdxNotesInput, TopicUncheckedCreateWithoutMdxNotesInput> | TopicCreateWithoutMdxNotesInput[] | TopicUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutMdxNotesInput | TopicCreateOrConnectWithoutMdxNotesInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<SubjectCreateWithoutMdxNotesInput, SubjectUncheckedCreateWithoutMdxNotesInput> | SubjectCreateWithoutMdxNotesInput[] | SubjectUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutMdxNotesInput | SubjectCreateOrConnectWithoutMdxNotesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<TagCreateWithoutMdxNotesInput, TagUncheckedCreateWithoutMdxNotesInput> | TagCreateWithoutMdxNotesInput[] | TagUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutMdxNotesInput | TagCreateOrConnectWithoutMdxNotesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type BibEntryCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<BibEntryCreateWithoutMdxNotesInput, BibEntryUncheckedCreateWithoutMdxNotesInput> | BibEntryCreateWithoutMdxNotesInput[] | BibEntryUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutMdxNotesInput | BibEntryCreateOrConnectWithoutMdxNotesInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type SequentialNoteListCreateNestedOneWithoutMdxNoteInput = {
    create?: XOR<SequentialNoteListCreateWithoutMdxNoteInput, SequentialNoteListUncheckedCreateWithoutMdxNoteInput>
    connectOrCreate?: SequentialNoteListCreateOrConnectWithoutMdxNoteInput
    connect?: SequentialNoteListWhereUniqueInput
  }

  export type ReadingListCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<ReadingListCreateWithoutMdxNotesInput, ReadingListUncheckedCreateWithoutMdxNotesInput> | ReadingListCreateWithoutMdxNotesInput[] | ReadingListUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutMdxNotesInput | ReadingListCreateOrConnectWithoutMdxNotesInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
  }

  export type EquationCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<EquationCreateWithoutMdxNotesInput, EquationUncheckedCreateWithoutMdxNotesInput> | EquationCreateWithoutMdxNotesInput[] | EquationUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutMdxNotesInput | EquationCreateOrConnectWithoutMdxNotesInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type DefinitionCreateNestedManyWithoutMdxNoteInput = {
    create?: XOR<DefinitionCreateWithoutMdxNoteInput, DefinitionUncheckedCreateWithoutMdxNoteInput> | DefinitionCreateWithoutMdxNoteInput[] | DefinitionUncheckedCreateWithoutMdxNoteInput[]
    connectOrCreate?: DefinitionCreateOrConnectWithoutMdxNoteInput | DefinitionCreateOrConnectWithoutMdxNoteInput[]
    createMany?: DefinitionCreateManyMdxNoteInputEnvelope
    connect?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
  }

  export type ToDoCreateNestedManyWithoutAssociatedNotesInput = {
    create?: XOR<ToDoCreateWithoutAssociatedNotesInput, ToDoUncheckedCreateWithoutAssociatedNotesInput> | ToDoCreateWithoutAssociatedNotesInput[] | ToDoUncheckedCreateWithoutAssociatedNotesInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutAssociatedNotesInput | ToDoCreateOrConnectWithoutAssociatedNotesInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<TopicCreateWithoutMdxNotesInput, TopicUncheckedCreateWithoutMdxNotesInput> | TopicCreateWithoutMdxNotesInput[] | TopicUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutMdxNotesInput | TopicCreateOrConnectWithoutMdxNotesInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<SubjectCreateWithoutMdxNotesInput, SubjectUncheckedCreateWithoutMdxNotesInput> | SubjectCreateWithoutMdxNotesInput[] | SubjectUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutMdxNotesInput | SubjectCreateOrConnectWithoutMdxNotesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<TagCreateWithoutMdxNotesInput, TagUncheckedCreateWithoutMdxNotesInput> | TagCreateWithoutMdxNotesInput[] | TagUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutMdxNotesInput | TagCreateOrConnectWithoutMdxNotesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<BibEntryCreateWithoutMdxNotesInput, BibEntryUncheckedCreateWithoutMdxNotesInput> | BibEntryCreateWithoutMdxNotesInput[] | BibEntryUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutMdxNotesInput | BibEntryCreateOrConnectWithoutMdxNotesInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<ReadingListCreateWithoutMdxNotesInput, ReadingListUncheckedCreateWithoutMdxNotesInput> | ReadingListCreateWithoutMdxNotesInput[] | ReadingListUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutMdxNotesInput | ReadingListCreateOrConnectWithoutMdxNotesInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
  }

  export type EquationUncheckedCreateNestedManyWithoutMdxNotesInput = {
    create?: XOR<EquationCreateWithoutMdxNotesInput, EquationUncheckedCreateWithoutMdxNotesInput> | EquationCreateWithoutMdxNotesInput[] | EquationUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutMdxNotesInput | EquationCreateOrConnectWithoutMdxNotesInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
  }

  export type DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput = {
    create?: XOR<DefinitionCreateWithoutMdxNoteInput, DefinitionUncheckedCreateWithoutMdxNoteInput> | DefinitionCreateWithoutMdxNoteInput[] | DefinitionUncheckedCreateWithoutMdxNoteInput[]
    connectOrCreate?: DefinitionCreateOrConnectWithoutMdxNoteInput | DefinitionCreateOrConnectWithoutMdxNoteInput[]
    createMany?: DefinitionCreateManyMdxNoteInputEnvelope
    connect?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
  }

  export type ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput = {
    create?: XOR<ToDoCreateWithoutAssociatedNotesInput, ToDoUncheckedCreateWithoutAssociatedNotesInput> | ToDoCreateWithoutAssociatedNotesInput[] | ToDoUncheckedCreateWithoutAssociatedNotesInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutAssociatedNotesInput | ToDoCreateOrConnectWithoutAssociatedNotesInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type MdxNoteUpdatecitationsListOrderInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MdxNoteUpdateimportantValuesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MdxNoteUpdateoutgoingQuickLinksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TopicUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<TopicCreateWithoutMdxNotesInput, TopicUncheckedCreateWithoutMdxNotesInput> | TopicCreateWithoutMdxNotesInput[] | TopicUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutMdxNotesInput | TopicCreateOrConnectWithoutMdxNotesInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutMdxNotesInput | TopicUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutMdxNotesInput | TopicUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutMdxNotesInput | TopicUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<SubjectCreateWithoutMdxNotesInput, SubjectUncheckedCreateWithoutMdxNotesInput> | SubjectCreateWithoutMdxNotesInput[] | SubjectUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutMdxNotesInput | SubjectCreateOrConnectWithoutMdxNotesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutMdxNotesInput | SubjectUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutMdxNotesInput | SubjectUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutMdxNotesInput | SubjectUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type TagUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<TagCreateWithoutMdxNotesInput, TagUncheckedCreateWithoutMdxNotesInput> | TagCreateWithoutMdxNotesInput[] | TagUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutMdxNotesInput | TagCreateOrConnectWithoutMdxNotesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutMdxNotesInput | TagUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutMdxNotesInput | TagUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutMdxNotesInput | TagUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type BibEntryUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<BibEntryCreateWithoutMdxNotesInput, BibEntryUncheckedCreateWithoutMdxNotesInput> | BibEntryCreateWithoutMdxNotesInput[] | BibEntryUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutMdxNotesInput | BibEntryCreateOrConnectWithoutMdxNotesInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutMdxNotesInput | BibEntryUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutMdxNotesInput | BibEntryUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutMdxNotesInput | BibEntryUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type SequentialNoteListUpdateOneWithoutMdxNoteNestedInput = {
    create?: XOR<SequentialNoteListCreateWithoutMdxNoteInput, SequentialNoteListUncheckedCreateWithoutMdxNoteInput>
    connectOrCreate?: SequentialNoteListCreateOrConnectWithoutMdxNoteInput
    upsert?: SequentialNoteListUpsertWithoutMdxNoteInput
    disconnect?: SequentialNoteListWhereInput | boolean
    delete?: SequentialNoteListWhereInput | boolean
    connect?: SequentialNoteListWhereUniqueInput
    update?: XOR<XOR<SequentialNoteListUpdateToOneWithWhereWithoutMdxNoteInput, SequentialNoteListUpdateWithoutMdxNoteInput>, SequentialNoteListUncheckedUpdateWithoutMdxNoteInput>
  }

  export type ReadingListUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<ReadingListCreateWithoutMdxNotesInput, ReadingListUncheckedCreateWithoutMdxNotesInput> | ReadingListCreateWithoutMdxNotesInput[] | ReadingListUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutMdxNotesInput | ReadingListCreateOrConnectWithoutMdxNotesInput[]
    upsert?: ReadingListUpsertWithWhereUniqueWithoutMdxNotesInput | ReadingListUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    disconnect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    delete?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    update?: ReadingListUpdateWithWhereUniqueWithoutMdxNotesInput | ReadingListUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: ReadingListUpdateManyWithWhereWithoutMdxNotesInput | ReadingListUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: ReadingListScalarWhereInput | ReadingListScalarWhereInput[]
  }

  export type EquationUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<EquationCreateWithoutMdxNotesInput, EquationUncheckedCreateWithoutMdxNotesInput> | EquationCreateWithoutMdxNotesInput[] | EquationUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutMdxNotesInput | EquationCreateOrConnectWithoutMdxNotesInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutMdxNotesInput | EquationUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutMdxNotesInput | EquationUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutMdxNotesInput | EquationUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type DefinitionUpdateManyWithoutMdxNoteNestedInput = {
    create?: XOR<DefinitionCreateWithoutMdxNoteInput, DefinitionUncheckedCreateWithoutMdxNoteInput> | DefinitionCreateWithoutMdxNoteInput[] | DefinitionUncheckedCreateWithoutMdxNoteInput[]
    connectOrCreate?: DefinitionCreateOrConnectWithoutMdxNoteInput | DefinitionCreateOrConnectWithoutMdxNoteInput[]
    upsert?: DefinitionUpsertWithWhereUniqueWithoutMdxNoteInput | DefinitionUpsertWithWhereUniqueWithoutMdxNoteInput[]
    createMany?: DefinitionCreateManyMdxNoteInputEnvelope
    set?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
    disconnect?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
    delete?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
    connect?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
    update?: DefinitionUpdateWithWhereUniqueWithoutMdxNoteInput | DefinitionUpdateWithWhereUniqueWithoutMdxNoteInput[]
    updateMany?: DefinitionUpdateManyWithWhereWithoutMdxNoteInput | DefinitionUpdateManyWithWhereWithoutMdxNoteInput[]
    deleteMany?: DefinitionScalarWhereInput | DefinitionScalarWhereInput[]
  }

  export type ToDoUpdateManyWithoutAssociatedNotesNestedInput = {
    create?: XOR<ToDoCreateWithoutAssociatedNotesInput, ToDoUncheckedCreateWithoutAssociatedNotesInput> | ToDoCreateWithoutAssociatedNotesInput[] | ToDoUncheckedCreateWithoutAssociatedNotesInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutAssociatedNotesInput | ToDoCreateOrConnectWithoutAssociatedNotesInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutAssociatedNotesInput | ToDoUpsertWithWhereUniqueWithoutAssociatedNotesInput[]
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutAssociatedNotesInput | ToDoUpdateWithWhereUniqueWithoutAssociatedNotesInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutAssociatedNotesInput | ToDoUpdateManyWithWhereWithoutAssociatedNotesInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<TopicCreateWithoutMdxNotesInput, TopicUncheckedCreateWithoutMdxNotesInput> | TopicCreateWithoutMdxNotesInput[] | TopicUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutMdxNotesInput | TopicCreateOrConnectWithoutMdxNotesInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutMdxNotesInput | TopicUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutMdxNotesInput | TopicUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutMdxNotesInput | TopicUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<SubjectCreateWithoutMdxNotesInput, SubjectUncheckedCreateWithoutMdxNotesInput> | SubjectCreateWithoutMdxNotesInput[] | SubjectUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutMdxNotesInput | SubjectCreateOrConnectWithoutMdxNotesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutMdxNotesInput | SubjectUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutMdxNotesInput | SubjectUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutMdxNotesInput | SubjectUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<TagCreateWithoutMdxNotesInput, TagUncheckedCreateWithoutMdxNotesInput> | TagCreateWithoutMdxNotesInput[] | TagUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutMdxNotesInput | TagCreateOrConnectWithoutMdxNotesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutMdxNotesInput | TagUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutMdxNotesInput | TagUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutMdxNotesInput | TagUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<BibEntryCreateWithoutMdxNotesInput, BibEntryUncheckedCreateWithoutMdxNotesInput> | BibEntryCreateWithoutMdxNotesInput[] | BibEntryUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutMdxNotesInput | BibEntryCreateOrConnectWithoutMdxNotesInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutMdxNotesInput | BibEntryUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutMdxNotesInput | BibEntryUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutMdxNotesInput | BibEntryUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<ReadingListCreateWithoutMdxNotesInput, ReadingListUncheckedCreateWithoutMdxNotesInput> | ReadingListCreateWithoutMdxNotesInput[] | ReadingListUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutMdxNotesInput | ReadingListCreateOrConnectWithoutMdxNotesInput[]
    upsert?: ReadingListUpsertWithWhereUniqueWithoutMdxNotesInput | ReadingListUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    disconnect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    delete?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    update?: ReadingListUpdateWithWhereUniqueWithoutMdxNotesInput | ReadingListUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: ReadingListUpdateManyWithWhereWithoutMdxNotesInput | ReadingListUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: ReadingListScalarWhereInput | ReadingListScalarWhereInput[]
  }

  export type EquationUncheckedUpdateManyWithoutMdxNotesNestedInput = {
    create?: XOR<EquationCreateWithoutMdxNotesInput, EquationUncheckedCreateWithoutMdxNotesInput> | EquationCreateWithoutMdxNotesInput[] | EquationUncheckedCreateWithoutMdxNotesInput[]
    connectOrCreate?: EquationCreateOrConnectWithoutMdxNotesInput | EquationCreateOrConnectWithoutMdxNotesInput[]
    upsert?: EquationUpsertWithWhereUniqueWithoutMdxNotesInput | EquationUpsertWithWhereUniqueWithoutMdxNotesInput[]
    set?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    disconnect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    delete?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    connect?: EquationWhereUniqueInput | EquationWhereUniqueInput[]
    update?: EquationUpdateWithWhereUniqueWithoutMdxNotesInput | EquationUpdateWithWhereUniqueWithoutMdxNotesInput[]
    updateMany?: EquationUpdateManyWithWhereWithoutMdxNotesInput | EquationUpdateManyWithWhereWithoutMdxNotesInput[]
    deleteMany?: EquationScalarWhereInput | EquationScalarWhereInput[]
  }

  export type DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput = {
    create?: XOR<DefinitionCreateWithoutMdxNoteInput, DefinitionUncheckedCreateWithoutMdxNoteInput> | DefinitionCreateWithoutMdxNoteInput[] | DefinitionUncheckedCreateWithoutMdxNoteInput[]
    connectOrCreate?: DefinitionCreateOrConnectWithoutMdxNoteInput | DefinitionCreateOrConnectWithoutMdxNoteInput[]
    upsert?: DefinitionUpsertWithWhereUniqueWithoutMdxNoteInput | DefinitionUpsertWithWhereUniqueWithoutMdxNoteInput[]
    createMany?: DefinitionCreateManyMdxNoteInputEnvelope
    set?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
    disconnect?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
    delete?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
    connect?: DefinitionWhereUniqueInput | DefinitionWhereUniqueInput[]
    update?: DefinitionUpdateWithWhereUniqueWithoutMdxNoteInput | DefinitionUpdateWithWhereUniqueWithoutMdxNoteInput[]
    updateMany?: DefinitionUpdateManyWithWhereWithoutMdxNoteInput | DefinitionUpdateManyWithWhereWithoutMdxNoteInput[]
    deleteMany?: DefinitionScalarWhereInput | DefinitionScalarWhereInput[]
  }

  export type ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput = {
    create?: XOR<ToDoCreateWithoutAssociatedNotesInput, ToDoUncheckedCreateWithoutAssociatedNotesInput> | ToDoCreateWithoutAssociatedNotesInput[] | ToDoUncheckedCreateWithoutAssociatedNotesInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutAssociatedNotesInput | ToDoCreateOrConnectWithoutAssociatedNotesInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutAssociatedNotesInput | ToDoUpsertWithWhereUniqueWithoutAssociatedNotesInput[]
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutAssociatedNotesInput | ToDoUpdateWithWhereUniqueWithoutAssociatedNotesInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutAssociatedNotesInput | ToDoUpdateManyWithWhereWithoutAssociatedNotesInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type IpynbCreatecitationsListOrderInput = {
    set: string[]
  }

  export type IpynbCreateimportantValuesInput = {
    set: number[]
  }

  export type IpynbCreateoutgoingQuickLinksInput = {
    set: string[]
  }

  export type TagCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<TagCreateWithoutIpynbNotesInput, TagUncheckedCreateWithoutIpynbNotesInput> | TagCreateWithoutIpynbNotesInput[] | TagUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutIpynbNotesInput | TagCreateOrConnectWithoutIpynbNotesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<TopicCreateWithoutIpynbNotesInput, TopicUncheckedCreateWithoutIpynbNotesInput> | TopicCreateWithoutIpynbNotesInput[] | TopicUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutIpynbNotesInput | TopicCreateOrConnectWithoutIpynbNotesInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<SubjectCreateWithoutIpynbNotesInput, SubjectUncheckedCreateWithoutIpynbNotesInput> | SubjectCreateWithoutIpynbNotesInput[] | SubjectUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutIpynbNotesInput | SubjectCreateOrConnectWithoutIpynbNotesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type BibEntryCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<BibEntryCreateWithoutIpynbNotesInput, BibEntryUncheckedCreateWithoutIpynbNotesInput> | BibEntryCreateWithoutIpynbNotesInput[] | BibEntryUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutIpynbNotesInput | BibEntryCreateOrConnectWithoutIpynbNotesInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type SequentialNoteListCreateNestedOneWithoutIpynbInput = {
    create?: XOR<SequentialNoteListCreateWithoutIpynbInput, SequentialNoteListUncheckedCreateWithoutIpynbInput>
    connectOrCreate?: SequentialNoteListCreateOrConnectWithoutIpynbInput
    connect?: SequentialNoteListWhereUniqueInput
  }

  export type ReadingListCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<ReadingListCreateWithoutIpynbNotesInput, ReadingListUncheckedCreateWithoutIpynbNotesInput> | ReadingListCreateWithoutIpynbNotesInput[] | ReadingListUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutIpynbNotesInput | ReadingListCreateOrConnectWithoutIpynbNotesInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<TagCreateWithoutIpynbNotesInput, TagUncheckedCreateWithoutIpynbNotesInput> | TagCreateWithoutIpynbNotesInput[] | TagUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutIpynbNotesInput | TagCreateOrConnectWithoutIpynbNotesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<TopicCreateWithoutIpynbNotesInput, TopicUncheckedCreateWithoutIpynbNotesInput> | TopicCreateWithoutIpynbNotesInput[] | TopicUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutIpynbNotesInput | TopicCreateOrConnectWithoutIpynbNotesInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<SubjectCreateWithoutIpynbNotesInput, SubjectUncheckedCreateWithoutIpynbNotesInput> | SubjectCreateWithoutIpynbNotesInput[] | SubjectUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutIpynbNotesInput | SubjectCreateOrConnectWithoutIpynbNotesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type BibEntryUncheckedCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<BibEntryCreateWithoutIpynbNotesInput, BibEntryUncheckedCreateWithoutIpynbNotesInput> | BibEntryCreateWithoutIpynbNotesInput[] | BibEntryUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutIpynbNotesInput | BibEntryCreateOrConnectWithoutIpynbNotesInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
  }

  export type ReadingListUncheckedCreateNestedManyWithoutIpynbNotesInput = {
    create?: XOR<ReadingListCreateWithoutIpynbNotesInput, ReadingListUncheckedCreateWithoutIpynbNotesInput> | ReadingListCreateWithoutIpynbNotesInput[] | ReadingListUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutIpynbNotesInput | ReadingListCreateOrConnectWithoutIpynbNotesInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
  }

  export type IpynbUpdatecitationsListOrderInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IpynbUpdateimportantValuesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type IpynbUpdateoutgoingQuickLinksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TagUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<TagCreateWithoutIpynbNotesInput, TagUncheckedCreateWithoutIpynbNotesInput> | TagCreateWithoutIpynbNotesInput[] | TagUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutIpynbNotesInput | TagCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutIpynbNotesInput | TagUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutIpynbNotesInput | TagUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutIpynbNotesInput | TagUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<TopicCreateWithoutIpynbNotesInput, TopicUncheckedCreateWithoutIpynbNotesInput> | TopicCreateWithoutIpynbNotesInput[] | TopicUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutIpynbNotesInput | TopicCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutIpynbNotesInput | TopicUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutIpynbNotesInput | TopicUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutIpynbNotesInput | TopicUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<SubjectCreateWithoutIpynbNotesInput, SubjectUncheckedCreateWithoutIpynbNotesInput> | SubjectCreateWithoutIpynbNotesInput[] | SubjectUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutIpynbNotesInput | SubjectCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutIpynbNotesInput | SubjectUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutIpynbNotesInput | SubjectUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutIpynbNotesInput | SubjectUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type BibEntryUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<BibEntryCreateWithoutIpynbNotesInput, BibEntryUncheckedCreateWithoutIpynbNotesInput> | BibEntryCreateWithoutIpynbNotesInput[] | BibEntryUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutIpynbNotesInput | BibEntryCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutIpynbNotesInput | BibEntryUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutIpynbNotesInput | BibEntryUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutIpynbNotesInput | BibEntryUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type SequentialNoteListUpdateOneWithoutIpynbNestedInput = {
    create?: XOR<SequentialNoteListCreateWithoutIpynbInput, SequentialNoteListUncheckedCreateWithoutIpynbInput>
    connectOrCreate?: SequentialNoteListCreateOrConnectWithoutIpynbInput
    upsert?: SequentialNoteListUpsertWithoutIpynbInput
    disconnect?: SequentialNoteListWhereInput | boolean
    delete?: SequentialNoteListWhereInput | boolean
    connect?: SequentialNoteListWhereUniqueInput
    update?: XOR<XOR<SequentialNoteListUpdateToOneWithWhereWithoutIpynbInput, SequentialNoteListUpdateWithoutIpynbInput>, SequentialNoteListUncheckedUpdateWithoutIpynbInput>
  }

  export type ReadingListUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<ReadingListCreateWithoutIpynbNotesInput, ReadingListUncheckedCreateWithoutIpynbNotesInput> | ReadingListCreateWithoutIpynbNotesInput[] | ReadingListUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutIpynbNotesInput | ReadingListCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: ReadingListUpsertWithWhereUniqueWithoutIpynbNotesInput | ReadingListUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    disconnect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    delete?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    update?: ReadingListUpdateWithWhereUniqueWithoutIpynbNotesInput | ReadingListUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: ReadingListUpdateManyWithWhereWithoutIpynbNotesInput | ReadingListUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: ReadingListScalarWhereInput | ReadingListScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<TagCreateWithoutIpynbNotesInput, TagUncheckedCreateWithoutIpynbNotesInput> | TagCreateWithoutIpynbNotesInput[] | TagUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutIpynbNotesInput | TagCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutIpynbNotesInput | TagUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutIpynbNotesInput | TagUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutIpynbNotesInput | TagUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<TopicCreateWithoutIpynbNotesInput, TopicUncheckedCreateWithoutIpynbNotesInput> | TopicCreateWithoutIpynbNotesInput[] | TopicUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutIpynbNotesInput | TopicCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutIpynbNotesInput | TopicUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutIpynbNotesInput | TopicUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutIpynbNotesInput | TopicUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<SubjectCreateWithoutIpynbNotesInput, SubjectUncheckedCreateWithoutIpynbNotesInput> | SubjectCreateWithoutIpynbNotesInput[] | SubjectUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutIpynbNotesInput | SubjectCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutIpynbNotesInput | SubjectUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutIpynbNotesInput | SubjectUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutIpynbNotesInput | SubjectUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type BibEntryUncheckedUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<BibEntryCreateWithoutIpynbNotesInput, BibEntryUncheckedCreateWithoutIpynbNotesInput> | BibEntryCreateWithoutIpynbNotesInput[] | BibEntryUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: BibEntryCreateOrConnectWithoutIpynbNotesInput | BibEntryCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: BibEntryUpsertWithWhereUniqueWithoutIpynbNotesInput | BibEntryUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    disconnect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    delete?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    connect?: BibEntryWhereUniqueInput | BibEntryWhereUniqueInput[]
    update?: BibEntryUpdateWithWhereUniqueWithoutIpynbNotesInput | BibEntryUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: BibEntryUpdateManyWithWhereWithoutIpynbNotesInput | BibEntryUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
  }

  export type ReadingListUncheckedUpdateManyWithoutIpynbNotesNestedInput = {
    create?: XOR<ReadingListCreateWithoutIpynbNotesInput, ReadingListUncheckedCreateWithoutIpynbNotesInput> | ReadingListCreateWithoutIpynbNotesInput[] | ReadingListUncheckedCreateWithoutIpynbNotesInput[]
    connectOrCreate?: ReadingListCreateOrConnectWithoutIpynbNotesInput | ReadingListCreateOrConnectWithoutIpynbNotesInput[]
    upsert?: ReadingListUpsertWithWhereUniqueWithoutIpynbNotesInput | ReadingListUpsertWithWhereUniqueWithoutIpynbNotesInput[]
    set?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    disconnect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    delete?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    connect?: ReadingListWhereUniqueInput | ReadingListWhereUniqueInput[]
    update?: ReadingListUpdateWithWhereUniqueWithoutIpynbNotesInput | ReadingListUpdateWithWhereUniqueWithoutIpynbNotesInput[]
    updateMany?: ReadingListUpdateManyWithWhereWithoutIpynbNotesInput | ReadingListUpdateManyWithWhereWithoutIpynbNotesInput[]
    deleteMany?: ReadingListScalarWhereInput | ReadingListScalarWhereInput[]
  }

  export type ToDoCreateNestedManyWithoutToDoListInput = {
    create?: XOR<ToDoCreateWithoutToDoListInput, ToDoUncheckedCreateWithoutToDoListInput> | ToDoCreateWithoutToDoListInput[] | ToDoUncheckedCreateWithoutToDoListInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutToDoListInput | ToDoCreateOrConnectWithoutToDoListInput[]
    createMany?: ToDoCreateManyToDoListInputEnvelope
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutTodoListInput = {
    create?: XOR<TagCreateWithoutTodoListInput, TagUncheckedCreateWithoutTodoListInput> | TagCreateWithoutTodoListInput[] | TagUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTodoListInput | TagCreateOrConnectWithoutTodoListInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutTodoListInput = {
    create?: XOR<TopicCreateWithoutTodoListInput, TopicUncheckedCreateWithoutTodoListInput> | TopicCreateWithoutTodoListInput[] | TopicUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutTodoListInput | TopicCreateOrConnectWithoutTodoListInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutTodoListInput = {
    create?: XOR<SubjectCreateWithoutTodoListInput, SubjectUncheckedCreateWithoutTodoListInput> | SubjectCreateWithoutTodoListInput[] | SubjectUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutTodoListInput | SubjectCreateOrConnectWithoutTodoListInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ToDoUncheckedCreateNestedManyWithoutToDoListInput = {
    create?: XOR<ToDoCreateWithoutToDoListInput, ToDoUncheckedCreateWithoutToDoListInput> | ToDoCreateWithoutToDoListInput[] | ToDoUncheckedCreateWithoutToDoListInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutToDoListInput | ToDoCreateOrConnectWithoutToDoListInput[]
    createMany?: ToDoCreateManyToDoListInputEnvelope
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutTodoListInput = {
    create?: XOR<TagCreateWithoutTodoListInput, TagUncheckedCreateWithoutTodoListInput> | TagCreateWithoutTodoListInput[] | TagUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTodoListInput | TagCreateOrConnectWithoutTodoListInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutTodoListInput = {
    create?: XOR<TopicCreateWithoutTodoListInput, TopicUncheckedCreateWithoutTodoListInput> | TopicCreateWithoutTodoListInput[] | TopicUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutTodoListInput | TopicCreateOrConnectWithoutTodoListInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutTodoListInput = {
    create?: XOR<SubjectCreateWithoutTodoListInput, SubjectUncheckedCreateWithoutTodoListInput> | SubjectCreateWithoutTodoListInput[] | SubjectUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutTodoListInput | SubjectCreateOrConnectWithoutTodoListInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ToDoUpdateManyWithoutToDoListNestedInput = {
    create?: XOR<ToDoCreateWithoutToDoListInput, ToDoUncheckedCreateWithoutToDoListInput> | ToDoCreateWithoutToDoListInput[] | ToDoUncheckedCreateWithoutToDoListInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutToDoListInput | ToDoCreateOrConnectWithoutToDoListInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutToDoListInput | ToDoUpsertWithWhereUniqueWithoutToDoListInput[]
    createMany?: ToDoCreateManyToDoListInputEnvelope
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutToDoListInput | ToDoUpdateWithWhereUniqueWithoutToDoListInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutToDoListInput | ToDoUpdateManyWithWhereWithoutToDoListInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type TagUpdateManyWithoutTodoListNestedInput = {
    create?: XOR<TagCreateWithoutTodoListInput, TagUncheckedCreateWithoutTodoListInput> | TagCreateWithoutTodoListInput[] | TagUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTodoListInput | TagCreateOrConnectWithoutTodoListInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTodoListInput | TagUpsertWithWhereUniqueWithoutTodoListInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTodoListInput | TagUpdateWithWhereUniqueWithoutTodoListInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTodoListInput | TagUpdateManyWithWhereWithoutTodoListInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutTodoListNestedInput = {
    create?: XOR<TopicCreateWithoutTodoListInput, TopicUncheckedCreateWithoutTodoListInput> | TopicCreateWithoutTodoListInput[] | TopicUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutTodoListInput | TopicCreateOrConnectWithoutTodoListInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutTodoListInput | TopicUpsertWithWhereUniqueWithoutTodoListInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutTodoListInput | TopicUpdateWithWhereUniqueWithoutTodoListInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutTodoListInput | TopicUpdateManyWithWhereWithoutTodoListInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutTodoListNestedInput = {
    create?: XOR<SubjectCreateWithoutTodoListInput, SubjectUncheckedCreateWithoutTodoListInput> | SubjectCreateWithoutTodoListInput[] | SubjectUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutTodoListInput | SubjectCreateOrConnectWithoutTodoListInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutTodoListInput | SubjectUpsertWithWhereUniqueWithoutTodoListInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutTodoListInput | SubjectUpdateWithWhereUniqueWithoutTodoListInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutTodoListInput | SubjectUpdateManyWithWhereWithoutTodoListInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ToDoUncheckedUpdateManyWithoutToDoListNestedInput = {
    create?: XOR<ToDoCreateWithoutToDoListInput, ToDoUncheckedCreateWithoutToDoListInput> | ToDoCreateWithoutToDoListInput[] | ToDoUncheckedCreateWithoutToDoListInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutToDoListInput | ToDoCreateOrConnectWithoutToDoListInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutToDoListInput | ToDoUpsertWithWhereUniqueWithoutToDoListInput[]
    createMany?: ToDoCreateManyToDoListInputEnvelope
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutToDoListInput | ToDoUpdateWithWhereUniqueWithoutToDoListInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutToDoListInput | ToDoUpdateManyWithWhereWithoutToDoListInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutTodoListNestedInput = {
    create?: XOR<TagCreateWithoutTodoListInput, TagUncheckedCreateWithoutTodoListInput> | TagCreateWithoutTodoListInput[] | TagUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTodoListInput | TagCreateOrConnectWithoutTodoListInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTodoListInput | TagUpsertWithWhereUniqueWithoutTodoListInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTodoListInput | TagUpdateWithWhereUniqueWithoutTodoListInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTodoListInput | TagUpdateManyWithWhereWithoutTodoListInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutTodoListNestedInput = {
    create?: XOR<TopicCreateWithoutTodoListInput, TopicUncheckedCreateWithoutTodoListInput> | TopicCreateWithoutTodoListInput[] | TopicUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutTodoListInput | TopicCreateOrConnectWithoutTodoListInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutTodoListInput | TopicUpsertWithWhereUniqueWithoutTodoListInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutTodoListInput | TopicUpdateWithWhereUniqueWithoutTodoListInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutTodoListInput | TopicUpdateManyWithWhereWithoutTodoListInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutTodoListNestedInput = {
    create?: XOR<SubjectCreateWithoutTodoListInput, SubjectUncheckedCreateWithoutTodoListInput> | SubjectCreateWithoutTodoListInput[] | SubjectUncheckedCreateWithoutTodoListInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutTodoListInput | SubjectCreateOrConnectWithoutTodoListInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutTodoListInput | SubjectUpsertWithWhereUniqueWithoutTodoListInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutTodoListInput | SubjectUpdateWithWhereUniqueWithoutTodoListInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutTodoListInput | SubjectUpdateManyWithWhereWithoutTodoListInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type MdxNoteCreateNestedManyWithoutToDoInput = {
    create?: XOR<MdxNoteCreateWithoutToDoInput, MdxNoteUncheckedCreateWithoutToDoInput> | MdxNoteCreateWithoutToDoInput[] | MdxNoteUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutToDoInput | MdxNoteCreateOrConnectWithoutToDoInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutToDoInput = {
    create?: XOR<TagCreateWithoutToDoInput, TagUncheckedCreateWithoutToDoInput> | TagCreateWithoutToDoInput[] | TagUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: TagCreateOrConnectWithoutToDoInput | TagCreateOrConnectWithoutToDoInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutToDoInput = {
    create?: XOR<TopicCreateWithoutToDoInput, TopicUncheckedCreateWithoutToDoInput> | TopicCreateWithoutToDoInput[] | TopicUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutToDoInput | TopicCreateOrConnectWithoutToDoInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutToDoInput = {
    create?: XOR<SubjectCreateWithoutToDoInput, SubjectUncheckedCreateWithoutToDoInput> | SubjectCreateWithoutToDoInput[] | SubjectUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutToDoInput | SubjectCreateOrConnectWithoutToDoInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ToDoCreateNestedOneWithoutChildInput = {
    create?: XOR<ToDoCreateWithoutChildInput, ToDoUncheckedCreateWithoutChildInput>
    connectOrCreate?: ToDoCreateOrConnectWithoutChildInput
    connect?: ToDoWhereUniqueInput
  }

  export type ToDoCreateNestedManyWithoutParentInput = {
    create?: XOR<ToDoCreateWithoutParentInput, ToDoUncheckedCreateWithoutParentInput> | ToDoCreateWithoutParentInput[] | ToDoUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutParentInput | ToDoCreateOrConnectWithoutParentInput[]
    createMany?: ToDoCreateManyParentInputEnvelope
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type ToDoListCreateNestedOneWithoutTasksInput = {
    create?: XOR<ToDoListCreateWithoutTasksInput, ToDoListUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ToDoListCreateOrConnectWithoutTasksInput
    connect?: ToDoListWhereUniqueInput
  }

  export type MdxNoteUncheckedCreateNestedManyWithoutToDoInput = {
    create?: XOR<MdxNoteCreateWithoutToDoInput, MdxNoteUncheckedCreateWithoutToDoInput> | MdxNoteCreateWithoutToDoInput[] | MdxNoteUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutToDoInput | MdxNoteCreateOrConnectWithoutToDoInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutToDoInput = {
    create?: XOR<TagCreateWithoutToDoInput, TagUncheckedCreateWithoutToDoInput> | TagCreateWithoutToDoInput[] | TagUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: TagCreateOrConnectWithoutToDoInput | TagCreateOrConnectWithoutToDoInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutToDoInput = {
    create?: XOR<TopicCreateWithoutToDoInput, TopicUncheckedCreateWithoutToDoInput> | TopicCreateWithoutToDoInput[] | TopicUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutToDoInput | TopicCreateOrConnectWithoutToDoInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutToDoInput = {
    create?: XOR<SubjectCreateWithoutToDoInput, SubjectUncheckedCreateWithoutToDoInput> | SubjectCreateWithoutToDoInput[] | SubjectUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutToDoInput | SubjectCreateOrConnectWithoutToDoInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ToDoUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ToDoCreateWithoutParentInput, ToDoUncheckedCreateWithoutParentInput> | ToDoCreateWithoutParentInput[] | ToDoUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutParentInput | ToDoCreateOrConnectWithoutParentInput[]
    createMany?: ToDoCreateManyParentInputEnvelope
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumTaskCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TaskCategory | null
  }

  export type EnumToDoListStatusFieldUpdateOperationsInput = {
    set?: $Enums.ToDoListStatus
  }

  export type MdxNoteUpdateManyWithoutToDoNestedInput = {
    create?: XOR<MdxNoteCreateWithoutToDoInput, MdxNoteUncheckedCreateWithoutToDoInput> | MdxNoteCreateWithoutToDoInput[] | MdxNoteUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutToDoInput | MdxNoteCreateOrConnectWithoutToDoInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutToDoInput | MdxNoteUpsertWithWhereUniqueWithoutToDoInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutToDoInput | MdxNoteUpdateWithWhereUniqueWithoutToDoInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutToDoInput | MdxNoteUpdateManyWithWhereWithoutToDoInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type TagUpdateManyWithoutToDoNestedInput = {
    create?: XOR<TagCreateWithoutToDoInput, TagUncheckedCreateWithoutToDoInput> | TagCreateWithoutToDoInput[] | TagUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: TagCreateOrConnectWithoutToDoInput | TagCreateOrConnectWithoutToDoInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutToDoInput | TagUpsertWithWhereUniqueWithoutToDoInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutToDoInput | TagUpdateWithWhereUniqueWithoutToDoInput[]
    updateMany?: TagUpdateManyWithWhereWithoutToDoInput | TagUpdateManyWithWhereWithoutToDoInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutToDoNestedInput = {
    create?: XOR<TopicCreateWithoutToDoInput, TopicUncheckedCreateWithoutToDoInput> | TopicCreateWithoutToDoInput[] | TopicUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutToDoInput | TopicCreateOrConnectWithoutToDoInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutToDoInput | TopicUpsertWithWhereUniqueWithoutToDoInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutToDoInput | TopicUpdateWithWhereUniqueWithoutToDoInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutToDoInput | TopicUpdateManyWithWhereWithoutToDoInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutToDoNestedInput = {
    create?: XOR<SubjectCreateWithoutToDoInput, SubjectUncheckedCreateWithoutToDoInput> | SubjectCreateWithoutToDoInput[] | SubjectUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutToDoInput | SubjectCreateOrConnectWithoutToDoInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutToDoInput | SubjectUpsertWithWhereUniqueWithoutToDoInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutToDoInput | SubjectUpdateWithWhereUniqueWithoutToDoInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutToDoInput | SubjectUpdateManyWithWhereWithoutToDoInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ToDoUpdateOneWithoutChildNestedInput = {
    create?: XOR<ToDoCreateWithoutChildInput, ToDoUncheckedCreateWithoutChildInput>
    connectOrCreate?: ToDoCreateOrConnectWithoutChildInput
    upsert?: ToDoUpsertWithoutChildInput
    disconnect?: ToDoWhereInput | boolean
    delete?: ToDoWhereInput | boolean
    connect?: ToDoWhereUniqueInput
    update?: XOR<XOR<ToDoUpdateToOneWithWhereWithoutChildInput, ToDoUpdateWithoutChildInput>, ToDoUncheckedUpdateWithoutChildInput>
  }

  export type ToDoUpdateManyWithoutParentNestedInput = {
    create?: XOR<ToDoCreateWithoutParentInput, ToDoUncheckedCreateWithoutParentInput> | ToDoCreateWithoutParentInput[] | ToDoUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutParentInput | ToDoCreateOrConnectWithoutParentInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutParentInput | ToDoUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ToDoCreateManyParentInputEnvelope
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutParentInput | ToDoUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutParentInput | ToDoUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type ToDoListUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ToDoListCreateWithoutTasksInput, ToDoListUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ToDoListCreateOrConnectWithoutTasksInput
    upsert?: ToDoListUpsertWithoutTasksInput
    disconnect?: ToDoListWhereInput | boolean
    delete?: ToDoListWhereInput | boolean
    connect?: ToDoListWhereUniqueInput
    update?: XOR<XOR<ToDoListUpdateToOneWithWhereWithoutTasksInput, ToDoListUpdateWithoutTasksInput>, ToDoListUncheckedUpdateWithoutTasksInput>
  }

  export type MdxNoteUncheckedUpdateManyWithoutToDoNestedInput = {
    create?: XOR<MdxNoteCreateWithoutToDoInput, MdxNoteUncheckedCreateWithoutToDoInput> | MdxNoteCreateWithoutToDoInput[] | MdxNoteUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: MdxNoteCreateOrConnectWithoutToDoInput | MdxNoteCreateOrConnectWithoutToDoInput[]
    upsert?: MdxNoteUpsertWithWhereUniqueWithoutToDoInput | MdxNoteUpsertWithWhereUniqueWithoutToDoInput[]
    set?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    disconnect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    delete?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    connect?: MdxNoteWhereUniqueInput | MdxNoteWhereUniqueInput[]
    update?: MdxNoteUpdateWithWhereUniqueWithoutToDoInput | MdxNoteUpdateWithWhereUniqueWithoutToDoInput[]
    updateMany?: MdxNoteUpdateManyWithWhereWithoutToDoInput | MdxNoteUpdateManyWithWhereWithoutToDoInput[]
    deleteMany?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutToDoNestedInput = {
    create?: XOR<TagCreateWithoutToDoInput, TagUncheckedCreateWithoutToDoInput> | TagCreateWithoutToDoInput[] | TagUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: TagCreateOrConnectWithoutToDoInput | TagCreateOrConnectWithoutToDoInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutToDoInput | TagUpsertWithWhereUniqueWithoutToDoInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutToDoInput | TagUpdateWithWhereUniqueWithoutToDoInput[]
    updateMany?: TagUpdateManyWithWhereWithoutToDoInput | TagUpdateManyWithWhereWithoutToDoInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutToDoNestedInput = {
    create?: XOR<TopicCreateWithoutToDoInput, TopicUncheckedCreateWithoutToDoInput> | TopicCreateWithoutToDoInput[] | TopicUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutToDoInput | TopicCreateOrConnectWithoutToDoInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutToDoInput | TopicUpsertWithWhereUniqueWithoutToDoInput[]
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutToDoInput | TopicUpdateWithWhereUniqueWithoutToDoInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutToDoInput | TopicUpdateManyWithWhereWithoutToDoInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutToDoNestedInput = {
    create?: XOR<SubjectCreateWithoutToDoInput, SubjectUncheckedCreateWithoutToDoInput> | SubjectCreateWithoutToDoInput[] | SubjectUncheckedCreateWithoutToDoInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutToDoInput | SubjectCreateOrConnectWithoutToDoInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutToDoInput | SubjectUpsertWithWhereUniqueWithoutToDoInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutToDoInput | SubjectUpdateWithWhereUniqueWithoutToDoInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutToDoInput | SubjectUpdateManyWithWhereWithoutToDoInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ToDoUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ToDoCreateWithoutParentInput, ToDoUncheckedCreateWithoutParentInput> | ToDoCreateWithoutParentInput[] | ToDoUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ToDoCreateOrConnectWithoutParentInput | ToDoCreateOrConnectWithoutParentInput[]
    upsert?: ToDoUpsertWithWhereUniqueWithoutParentInput | ToDoUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ToDoCreateManyParentInputEnvelope
    set?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    disconnect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    delete?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    connect?: ToDoWhereUniqueInput | ToDoWhereUniqueInput[]
    update?: ToDoUpdateWithWhereUniqueWithoutParentInput | ToDoUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ToDoUpdateManyWithWhereWithoutParentInput | ToDoUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
  }

  export type KanBanListCreateNestedOneWithoutCardsInput = {
    create?: XOR<KanBanListCreateWithoutCardsInput, KanBanListUncheckedCreateWithoutCardsInput>
    connectOrCreate?: KanBanListCreateOrConnectWithoutCardsInput
    connect?: KanBanListWhereUniqueInput
  }

  export type KanBanListUpdateOneWithoutCardsNestedInput = {
    create?: XOR<KanBanListCreateWithoutCardsInput, KanBanListUncheckedCreateWithoutCardsInput>
    connectOrCreate?: KanBanListCreateOrConnectWithoutCardsInput
    upsert?: KanBanListUpsertWithoutCardsInput
    disconnect?: KanBanListWhereInput | boolean
    delete?: KanBanListWhereInput | boolean
    connect?: KanBanListWhereUniqueInput
    update?: XOR<XOR<KanBanListUpdateToOneWithWhereWithoutCardsInput, KanBanListUpdateWithoutCardsInput>, KanBanListUncheckedUpdateWithoutCardsInput>
  }

  export type KanBanCardCreateNestedManyWithoutKanBanListInput = {
    create?: XOR<KanBanCardCreateWithoutKanBanListInput, KanBanCardUncheckedCreateWithoutKanBanListInput> | KanBanCardCreateWithoutKanBanListInput[] | KanBanCardUncheckedCreateWithoutKanBanListInput[]
    connectOrCreate?: KanBanCardCreateOrConnectWithoutKanBanListInput | KanBanCardCreateOrConnectWithoutKanBanListInput[]
    createMany?: KanBanCardCreateManyKanBanListInputEnvelope
    connect?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
  }

  export type KanbanCreateNestedOneWithoutListsInput = {
    create?: XOR<KanbanCreateWithoutListsInput, KanbanUncheckedCreateWithoutListsInput>
    connectOrCreate?: KanbanCreateOrConnectWithoutListsInput
    connect?: KanbanWhereUniqueInput
  }

  export type KanBanCardUncheckedCreateNestedManyWithoutKanBanListInput = {
    create?: XOR<KanBanCardCreateWithoutKanBanListInput, KanBanCardUncheckedCreateWithoutKanBanListInput> | KanBanCardCreateWithoutKanBanListInput[] | KanBanCardUncheckedCreateWithoutKanBanListInput[]
    connectOrCreate?: KanBanCardCreateOrConnectWithoutKanBanListInput | KanBanCardCreateOrConnectWithoutKanBanListInput[]
    createMany?: KanBanCardCreateManyKanBanListInputEnvelope
    connect?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
  }

  export type KanBanCardUpdateManyWithoutKanBanListNestedInput = {
    create?: XOR<KanBanCardCreateWithoutKanBanListInput, KanBanCardUncheckedCreateWithoutKanBanListInput> | KanBanCardCreateWithoutKanBanListInput[] | KanBanCardUncheckedCreateWithoutKanBanListInput[]
    connectOrCreate?: KanBanCardCreateOrConnectWithoutKanBanListInput | KanBanCardCreateOrConnectWithoutKanBanListInput[]
    upsert?: KanBanCardUpsertWithWhereUniqueWithoutKanBanListInput | KanBanCardUpsertWithWhereUniqueWithoutKanBanListInput[]
    createMany?: KanBanCardCreateManyKanBanListInputEnvelope
    set?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
    disconnect?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
    delete?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
    connect?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
    update?: KanBanCardUpdateWithWhereUniqueWithoutKanBanListInput | KanBanCardUpdateWithWhereUniqueWithoutKanBanListInput[]
    updateMany?: KanBanCardUpdateManyWithWhereWithoutKanBanListInput | KanBanCardUpdateManyWithWhereWithoutKanBanListInput[]
    deleteMany?: KanBanCardScalarWhereInput | KanBanCardScalarWhereInput[]
  }

  export type KanbanUpdateOneWithoutListsNestedInput = {
    create?: XOR<KanbanCreateWithoutListsInput, KanbanUncheckedCreateWithoutListsInput>
    connectOrCreate?: KanbanCreateOrConnectWithoutListsInput
    upsert?: KanbanUpsertWithoutListsInput
    disconnect?: KanbanWhereInput | boolean
    delete?: KanbanWhereInput | boolean
    connect?: KanbanWhereUniqueInput
    update?: XOR<XOR<KanbanUpdateToOneWithWhereWithoutListsInput, KanbanUpdateWithoutListsInput>, KanbanUncheckedUpdateWithoutListsInput>
  }

  export type KanBanCardUncheckedUpdateManyWithoutKanBanListNestedInput = {
    create?: XOR<KanBanCardCreateWithoutKanBanListInput, KanBanCardUncheckedCreateWithoutKanBanListInput> | KanBanCardCreateWithoutKanBanListInput[] | KanBanCardUncheckedCreateWithoutKanBanListInput[]
    connectOrCreate?: KanBanCardCreateOrConnectWithoutKanBanListInput | KanBanCardCreateOrConnectWithoutKanBanListInput[]
    upsert?: KanBanCardUpsertWithWhereUniqueWithoutKanBanListInput | KanBanCardUpsertWithWhereUniqueWithoutKanBanListInput[]
    createMany?: KanBanCardCreateManyKanBanListInputEnvelope
    set?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
    disconnect?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
    delete?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
    connect?: KanBanCardWhereUniqueInput | KanBanCardWhereUniqueInput[]
    update?: KanBanCardUpdateWithWhereUniqueWithoutKanBanListInput | KanBanCardUpdateWithWhereUniqueWithoutKanBanListInput[]
    updateMany?: KanBanCardUpdateManyWithWhereWithoutKanBanListInput | KanBanCardUpdateManyWithWhereWithoutKanBanListInput[]
    deleteMany?: KanBanCardScalarWhereInput | KanBanCardScalarWhereInput[]
  }

  export type KanBanListCreateNestedManyWithoutKanbanInput = {
    create?: XOR<KanBanListCreateWithoutKanbanInput, KanBanListUncheckedCreateWithoutKanbanInput> | KanBanListCreateWithoutKanbanInput[] | KanBanListUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: KanBanListCreateOrConnectWithoutKanbanInput | KanBanListCreateOrConnectWithoutKanbanInput[]
    createMany?: KanBanListCreateManyKanbanInputEnvelope
    connect?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutKanbanInput = {
    create?: XOR<TagCreateWithoutKanbanInput, TagUncheckedCreateWithoutKanbanInput> | TagCreateWithoutKanbanInput[] | TagUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: TagCreateOrConnectWithoutKanbanInput | TagCreateOrConnectWithoutKanbanInput[]
    createMany?: TagCreateManyKanbanInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutKanbanInput = {
    create?: XOR<SubjectCreateWithoutKanbanInput, SubjectUncheckedCreateWithoutKanbanInput> | SubjectCreateWithoutKanbanInput[] | SubjectUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutKanbanInput | SubjectCreateOrConnectWithoutKanbanInput[]
    createMany?: SubjectCreateManyKanbanInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutKanbanInput = {
    create?: XOR<TopicCreateWithoutKanbanInput, TopicUncheckedCreateWithoutKanbanInput> | TopicCreateWithoutKanbanInput[] | TopicUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutKanbanInput | TopicCreateOrConnectWithoutKanbanInput[]
    createMany?: TopicCreateManyKanbanInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type KanBanListUncheckedCreateNestedManyWithoutKanbanInput = {
    create?: XOR<KanBanListCreateWithoutKanbanInput, KanBanListUncheckedCreateWithoutKanbanInput> | KanBanListCreateWithoutKanbanInput[] | KanBanListUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: KanBanListCreateOrConnectWithoutKanbanInput | KanBanListCreateOrConnectWithoutKanbanInput[]
    createMany?: KanBanListCreateManyKanbanInputEnvelope
    connect?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutKanbanInput = {
    create?: XOR<TagCreateWithoutKanbanInput, TagUncheckedCreateWithoutKanbanInput> | TagCreateWithoutKanbanInput[] | TagUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: TagCreateOrConnectWithoutKanbanInput | TagCreateOrConnectWithoutKanbanInput[]
    createMany?: TagCreateManyKanbanInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutKanbanInput = {
    create?: XOR<SubjectCreateWithoutKanbanInput, SubjectUncheckedCreateWithoutKanbanInput> | SubjectCreateWithoutKanbanInput[] | SubjectUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutKanbanInput | SubjectCreateOrConnectWithoutKanbanInput[]
    createMany?: SubjectCreateManyKanbanInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutKanbanInput = {
    create?: XOR<TopicCreateWithoutKanbanInput, TopicUncheckedCreateWithoutKanbanInput> | TopicCreateWithoutKanbanInput[] | TopicUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutKanbanInput | TopicCreateOrConnectWithoutKanbanInput[]
    createMany?: TopicCreateManyKanbanInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type KanBanListUpdateManyWithoutKanbanNestedInput = {
    create?: XOR<KanBanListCreateWithoutKanbanInput, KanBanListUncheckedCreateWithoutKanbanInput> | KanBanListCreateWithoutKanbanInput[] | KanBanListUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: KanBanListCreateOrConnectWithoutKanbanInput | KanBanListCreateOrConnectWithoutKanbanInput[]
    upsert?: KanBanListUpsertWithWhereUniqueWithoutKanbanInput | KanBanListUpsertWithWhereUniqueWithoutKanbanInput[]
    createMany?: KanBanListCreateManyKanbanInputEnvelope
    set?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
    disconnect?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
    delete?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
    connect?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
    update?: KanBanListUpdateWithWhereUniqueWithoutKanbanInput | KanBanListUpdateWithWhereUniqueWithoutKanbanInput[]
    updateMany?: KanBanListUpdateManyWithWhereWithoutKanbanInput | KanBanListUpdateManyWithWhereWithoutKanbanInput[]
    deleteMany?: KanBanListScalarWhereInput | KanBanListScalarWhereInput[]
  }

  export type TagUpdateManyWithoutKanbanNestedInput = {
    create?: XOR<TagCreateWithoutKanbanInput, TagUncheckedCreateWithoutKanbanInput> | TagCreateWithoutKanbanInput[] | TagUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: TagCreateOrConnectWithoutKanbanInput | TagCreateOrConnectWithoutKanbanInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutKanbanInput | TagUpsertWithWhereUniqueWithoutKanbanInput[]
    createMany?: TagCreateManyKanbanInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutKanbanInput | TagUpdateWithWhereUniqueWithoutKanbanInput[]
    updateMany?: TagUpdateManyWithWhereWithoutKanbanInput | TagUpdateManyWithWhereWithoutKanbanInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutKanbanNestedInput = {
    create?: XOR<SubjectCreateWithoutKanbanInput, SubjectUncheckedCreateWithoutKanbanInput> | SubjectCreateWithoutKanbanInput[] | SubjectUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutKanbanInput | SubjectCreateOrConnectWithoutKanbanInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutKanbanInput | SubjectUpsertWithWhereUniqueWithoutKanbanInput[]
    createMany?: SubjectCreateManyKanbanInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutKanbanInput | SubjectUpdateWithWhereUniqueWithoutKanbanInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutKanbanInput | SubjectUpdateManyWithWhereWithoutKanbanInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutKanbanNestedInput = {
    create?: XOR<TopicCreateWithoutKanbanInput, TopicUncheckedCreateWithoutKanbanInput> | TopicCreateWithoutKanbanInput[] | TopicUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutKanbanInput | TopicCreateOrConnectWithoutKanbanInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutKanbanInput | TopicUpsertWithWhereUniqueWithoutKanbanInput[]
    createMany?: TopicCreateManyKanbanInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutKanbanInput | TopicUpdateWithWhereUniqueWithoutKanbanInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutKanbanInput | TopicUpdateManyWithWhereWithoutKanbanInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type KanBanListUncheckedUpdateManyWithoutKanbanNestedInput = {
    create?: XOR<KanBanListCreateWithoutKanbanInput, KanBanListUncheckedCreateWithoutKanbanInput> | KanBanListCreateWithoutKanbanInput[] | KanBanListUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: KanBanListCreateOrConnectWithoutKanbanInput | KanBanListCreateOrConnectWithoutKanbanInput[]
    upsert?: KanBanListUpsertWithWhereUniqueWithoutKanbanInput | KanBanListUpsertWithWhereUniqueWithoutKanbanInput[]
    createMany?: KanBanListCreateManyKanbanInputEnvelope
    set?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
    disconnect?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
    delete?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
    connect?: KanBanListWhereUniqueInput | KanBanListWhereUniqueInput[]
    update?: KanBanListUpdateWithWhereUniqueWithoutKanbanInput | KanBanListUpdateWithWhereUniqueWithoutKanbanInput[]
    updateMany?: KanBanListUpdateManyWithWhereWithoutKanbanInput | KanBanListUpdateManyWithWhereWithoutKanbanInput[]
    deleteMany?: KanBanListScalarWhereInput | KanBanListScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutKanbanNestedInput = {
    create?: XOR<TagCreateWithoutKanbanInput, TagUncheckedCreateWithoutKanbanInput> | TagCreateWithoutKanbanInput[] | TagUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: TagCreateOrConnectWithoutKanbanInput | TagCreateOrConnectWithoutKanbanInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutKanbanInput | TagUpsertWithWhereUniqueWithoutKanbanInput[]
    createMany?: TagCreateManyKanbanInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutKanbanInput | TagUpdateWithWhereUniqueWithoutKanbanInput[]
    updateMany?: TagUpdateManyWithWhereWithoutKanbanInput | TagUpdateManyWithWhereWithoutKanbanInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutKanbanNestedInput = {
    create?: XOR<SubjectCreateWithoutKanbanInput, SubjectUncheckedCreateWithoutKanbanInput> | SubjectCreateWithoutKanbanInput[] | SubjectUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutKanbanInput | SubjectCreateOrConnectWithoutKanbanInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutKanbanInput | SubjectUpsertWithWhereUniqueWithoutKanbanInput[]
    createMany?: SubjectCreateManyKanbanInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutKanbanInput | SubjectUpdateWithWhereUniqueWithoutKanbanInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutKanbanInput | SubjectUpdateManyWithWhereWithoutKanbanInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutKanbanNestedInput = {
    create?: XOR<TopicCreateWithoutKanbanInput, TopicUncheckedCreateWithoutKanbanInput> | TopicCreateWithoutKanbanInput[] | TopicUncheckedCreateWithoutKanbanInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutKanbanInput | TopicCreateOrConnectWithoutKanbanInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutKanbanInput | TopicUpsertWithWhereUniqueWithoutKanbanInput[]
    createMany?: TopicCreateManyKanbanInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutKanbanInput | TopicUpdateWithWhereUniqueWithoutKanbanInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutKanbanInput | TopicUpdateManyWithWhereWithoutKanbanInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type DietCreateNestedOneWithoutPeriodsFollowedInput = {
    create?: XOR<DietCreateWithoutPeriodsFollowedInput, DietUncheckedCreateWithoutPeriodsFollowedInput>
    connectOrCreate?: DietCreateOrConnectWithoutPeriodsFollowedInput
    connect?: DietWhereUniqueInput
  }

  export type DietUpdateOneWithoutPeriodsFollowedNestedInput = {
    create?: XOR<DietCreateWithoutPeriodsFollowedInput, DietUncheckedCreateWithoutPeriodsFollowedInput>
    connectOrCreate?: DietCreateOrConnectWithoutPeriodsFollowedInput
    upsert?: DietUpsertWithoutPeriodsFollowedInput
    disconnect?: DietWhereInput | boolean
    delete?: DietWhereInput | boolean
    connect?: DietWhereUniqueInput
    update?: XOR<XOR<DietUpdateToOneWithWhereWithoutPeriodsFollowedInput, DietUpdateWithoutPeriodsFollowedInput>, DietUncheckedUpdateWithoutPeriodsFollowedInput>
  }

  export type DietCreategoalsInput = {
    set: $Enums.DIETARY_GOAL[]
  }

  export type DietaryItemCreateNestedManyWithoutDietInput = {
    create?: XOR<DietaryItemCreateWithoutDietInput, DietaryItemUncheckedCreateWithoutDietInput> | DietaryItemCreateWithoutDietInput[] | DietaryItemUncheckedCreateWithoutDietInput[]
    connectOrCreate?: DietaryItemCreateOrConnectWithoutDietInput | DietaryItemCreateOrConnectWithoutDietInput[]
    connect?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
  }

  export type TimePeriodCreateNestedManyWithoutDietInput = {
    create?: XOR<TimePeriodCreateWithoutDietInput, TimePeriodUncheckedCreateWithoutDietInput> | TimePeriodCreateWithoutDietInput[] | TimePeriodUncheckedCreateWithoutDietInput[]
    connectOrCreate?: TimePeriodCreateOrConnectWithoutDietInput | TimePeriodCreateOrConnectWithoutDietInput[]
    createMany?: TimePeriodCreateManyDietInputEnvelope
    connect?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
  }

  export type HealthReportCreateNestedManyWithoutCurrentDietInput = {
    create?: XOR<HealthReportCreateWithoutCurrentDietInput, HealthReportUncheckedCreateWithoutCurrentDietInput> | HealthReportCreateWithoutCurrentDietInput[] | HealthReportUncheckedCreateWithoutCurrentDietInput[]
    connectOrCreate?: HealthReportCreateOrConnectWithoutCurrentDietInput | HealthReportCreateOrConnectWithoutCurrentDietInput[]
    createMany?: HealthReportCreateManyCurrentDietInputEnvelope
    connect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
  }

  export type DietaryItemUncheckedCreateNestedManyWithoutDietInput = {
    create?: XOR<DietaryItemCreateWithoutDietInput, DietaryItemUncheckedCreateWithoutDietInput> | DietaryItemCreateWithoutDietInput[] | DietaryItemUncheckedCreateWithoutDietInput[]
    connectOrCreate?: DietaryItemCreateOrConnectWithoutDietInput | DietaryItemCreateOrConnectWithoutDietInput[]
    connect?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
  }

  export type TimePeriodUncheckedCreateNestedManyWithoutDietInput = {
    create?: XOR<TimePeriodCreateWithoutDietInput, TimePeriodUncheckedCreateWithoutDietInput> | TimePeriodCreateWithoutDietInput[] | TimePeriodUncheckedCreateWithoutDietInput[]
    connectOrCreate?: TimePeriodCreateOrConnectWithoutDietInput | TimePeriodCreateOrConnectWithoutDietInput[]
    createMany?: TimePeriodCreateManyDietInputEnvelope
    connect?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
  }

  export type HealthReportUncheckedCreateNestedManyWithoutCurrentDietInput = {
    create?: XOR<HealthReportCreateWithoutCurrentDietInput, HealthReportUncheckedCreateWithoutCurrentDietInput> | HealthReportCreateWithoutCurrentDietInput[] | HealthReportUncheckedCreateWithoutCurrentDietInput[]
    connectOrCreate?: HealthReportCreateOrConnectWithoutCurrentDietInput | HealthReportCreateOrConnectWithoutCurrentDietInput[]
    createMany?: HealthReportCreateManyCurrentDietInputEnvelope
    connect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
  }

  export type EnumTERTIARY_TOGGLEFieldUpdateOperationsInput = {
    set?: $Enums.TERTIARY_TOGGLE
  }

  export type DietUpdategoalsInput = {
    set?: $Enums.DIETARY_GOAL[]
    push?: $Enums.DIETARY_GOAL | $Enums.DIETARY_GOAL[]
  }

  export type DietaryItemUpdateManyWithoutDietNestedInput = {
    create?: XOR<DietaryItemCreateWithoutDietInput, DietaryItemUncheckedCreateWithoutDietInput> | DietaryItemCreateWithoutDietInput[] | DietaryItemUncheckedCreateWithoutDietInput[]
    connectOrCreate?: DietaryItemCreateOrConnectWithoutDietInput | DietaryItemCreateOrConnectWithoutDietInput[]
    upsert?: DietaryItemUpsertWithWhereUniqueWithoutDietInput | DietaryItemUpsertWithWhereUniqueWithoutDietInput[]
    set?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
    disconnect?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
    delete?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
    connect?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
    update?: DietaryItemUpdateWithWhereUniqueWithoutDietInput | DietaryItemUpdateWithWhereUniqueWithoutDietInput[]
    updateMany?: DietaryItemUpdateManyWithWhereWithoutDietInput | DietaryItemUpdateManyWithWhereWithoutDietInput[]
    deleteMany?: DietaryItemScalarWhereInput | DietaryItemScalarWhereInput[]
  }

  export type TimePeriodUpdateManyWithoutDietNestedInput = {
    create?: XOR<TimePeriodCreateWithoutDietInput, TimePeriodUncheckedCreateWithoutDietInput> | TimePeriodCreateWithoutDietInput[] | TimePeriodUncheckedCreateWithoutDietInput[]
    connectOrCreate?: TimePeriodCreateOrConnectWithoutDietInput | TimePeriodCreateOrConnectWithoutDietInput[]
    upsert?: TimePeriodUpsertWithWhereUniqueWithoutDietInput | TimePeriodUpsertWithWhereUniqueWithoutDietInput[]
    createMany?: TimePeriodCreateManyDietInputEnvelope
    set?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
    disconnect?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
    delete?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
    connect?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
    update?: TimePeriodUpdateWithWhereUniqueWithoutDietInput | TimePeriodUpdateWithWhereUniqueWithoutDietInput[]
    updateMany?: TimePeriodUpdateManyWithWhereWithoutDietInput | TimePeriodUpdateManyWithWhereWithoutDietInput[]
    deleteMany?: TimePeriodScalarWhereInput | TimePeriodScalarWhereInput[]
  }

  export type HealthReportUpdateManyWithoutCurrentDietNestedInput = {
    create?: XOR<HealthReportCreateWithoutCurrentDietInput, HealthReportUncheckedCreateWithoutCurrentDietInput> | HealthReportCreateWithoutCurrentDietInput[] | HealthReportUncheckedCreateWithoutCurrentDietInput[]
    connectOrCreate?: HealthReportCreateOrConnectWithoutCurrentDietInput | HealthReportCreateOrConnectWithoutCurrentDietInput[]
    upsert?: HealthReportUpsertWithWhereUniqueWithoutCurrentDietInput | HealthReportUpsertWithWhereUniqueWithoutCurrentDietInput[]
    createMany?: HealthReportCreateManyCurrentDietInputEnvelope
    set?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    disconnect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    delete?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    connect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    update?: HealthReportUpdateWithWhereUniqueWithoutCurrentDietInput | HealthReportUpdateWithWhereUniqueWithoutCurrentDietInput[]
    updateMany?: HealthReportUpdateManyWithWhereWithoutCurrentDietInput | HealthReportUpdateManyWithWhereWithoutCurrentDietInput[]
    deleteMany?: HealthReportScalarWhereInput | HealthReportScalarWhereInput[]
  }

  export type DietaryItemUncheckedUpdateManyWithoutDietNestedInput = {
    create?: XOR<DietaryItemCreateWithoutDietInput, DietaryItemUncheckedCreateWithoutDietInput> | DietaryItemCreateWithoutDietInput[] | DietaryItemUncheckedCreateWithoutDietInput[]
    connectOrCreate?: DietaryItemCreateOrConnectWithoutDietInput | DietaryItemCreateOrConnectWithoutDietInput[]
    upsert?: DietaryItemUpsertWithWhereUniqueWithoutDietInput | DietaryItemUpsertWithWhereUniqueWithoutDietInput[]
    set?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
    disconnect?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
    delete?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
    connect?: DietaryItemWhereUniqueInput | DietaryItemWhereUniqueInput[]
    update?: DietaryItemUpdateWithWhereUniqueWithoutDietInput | DietaryItemUpdateWithWhereUniqueWithoutDietInput[]
    updateMany?: DietaryItemUpdateManyWithWhereWithoutDietInput | DietaryItemUpdateManyWithWhereWithoutDietInput[]
    deleteMany?: DietaryItemScalarWhereInput | DietaryItemScalarWhereInput[]
  }

  export type TimePeriodUncheckedUpdateManyWithoutDietNestedInput = {
    create?: XOR<TimePeriodCreateWithoutDietInput, TimePeriodUncheckedCreateWithoutDietInput> | TimePeriodCreateWithoutDietInput[] | TimePeriodUncheckedCreateWithoutDietInput[]
    connectOrCreate?: TimePeriodCreateOrConnectWithoutDietInput | TimePeriodCreateOrConnectWithoutDietInput[]
    upsert?: TimePeriodUpsertWithWhereUniqueWithoutDietInput | TimePeriodUpsertWithWhereUniqueWithoutDietInput[]
    createMany?: TimePeriodCreateManyDietInputEnvelope
    set?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
    disconnect?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
    delete?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
    connect?: TimePeriodWhereUniqueInput | TimePeriodWhereUniqueInput[]
    update?: TimePeriodUpdateWithWhereUniqueWithoutDietInput | TimePeriodUpdateWithWhereUniqueWithoutDietInput[]
    updateMany?: TimePeriodUpdateManyWithWhereWithoutDietInput | TimePeriodUpdateManyWithWhereWithoutDietInput[]
    deleteMany?: TimePeriodScalarWhereInput | TimePeriodScalarWhereInput[]
  }

  export type HealthReportUncheckedUpdateManyWithoutCurrentDietNestedInput = {
    create?: XOR<HealthReportCreateWithoutCurrentDietInput, HealthReportUncheckedCreateWithoutCurrentDietInput> | HealthReportCreateWithoutCurrentDietInput[] | HealthReportUncheckedCreateWithoutCurrentDietInput[]
    connectOrCreate?: HealthReportCreateOrConnectWithoutCurrentDietInput | HealthReportCreateOrConnectWithoutCurrentDietInput[]
    upsert?: HealthReportUpsertWithWhereUniqueWithoutCurrentDietInput | HealthReportUpsertWithWhereUniqueWithoutCurrentDietInput[]
    createMany?: HealthReportCreateManyCurrentDietInputEnvelope
    set?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    disconnect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    delete?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    connect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    update?: HealthReportUpdateWithWhereUniqueWithoutCurrentDietInput | HealthReportUpdateWithWhereUniqueWithoutCurrentDietInput[]
    updateMany?: HealthReportUpdateManyWithWhereWithoutCurrentDietInput | HealthReportUpdateManyWithWhereWithoutCurrentDietInput[]
    deleteMany?: HealthReportScalarWhereInput | HealthReportScalarWhereInput[]
  }

  export type DietaryItemCreateNestedOneWithoutServingInput = {
    create?: XOR<DietaryItemCreateWithoutServingInput, DietaryItemUncheckedCreateWithoutServingInput>
    connectOrCreate?: DietaryItemCreateOrConnectWithoutServingInput
    connect?: DietaryItemWhereUniqueInput
  }

  export type NullableEnumQUANTITY_GUESSFieldUpdateOperationsInput = {
    set?: $Enums.QUANTITY_GUESS | null
  }

  export type DietaryItemUpdateOneRequiredWithoutServingNestedInput = {
    create?: XOR<DietaryItemCreateWithoutServingInput, DietaryItemUncheckedCreateWithoutServingInput>
    connectOrCreate?: DietaryItemCreateOrConnectWithoutServingInput
    upsert?: DietaryItemUpsertWithoutServingInput
    connect?: DietaryItemWhereUniqueInput
    update?: XOR<XOR<DietaryItemUpdateToOneWithWhereWithoutServingInput, DietaryItemUpdateWithoutServingInput>, DietaryItemUncheckedUpdateWithoutServingInput>
  }

  export type DietCreateNestedManyWithoutItemsInput = {
    create?: XOR<DietCreateWithoutItemsInput, DietUncheckedCreateWithoutItemsInput> | DietCreateWithoutItemsInput[] | DietUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: DietCreateOrConnectWithoutItemsInput | DietCreateOrConnectWithoutItemsInput[]
    connect?: DietWhereUniqueInput | DietWhereUniqueInput[]
  }

  export type ServingCreateNestedManyWithoutItemInput = {
    create?: XOR<ServingCreateWithoutItemInput, ServingUncheckedCreateWithoutItemInput> | ServingCreateWithoutItemInput[] | ServingUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ServingCreateOrConnectWithoutItemInput | ServingCreateOrConnectWithoutItemInput[]
    createMany?: ServingCreateManyItemInputEnvelope
    connect?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
  }

  export type DietUncheckedCreateNestedManyWithoutItemsInput = {
    create?: XOR<DietCreateWithoutItemsInput, DietUncheckedCreateWithoutItemsInput> | DietCreateWithoutItemsInput[] | DietUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: DietCreateOrConnectWithoutItemsInput | DietCreateOrConnectWithoutItemsInput[]
    connect?: DietWhereUniqueInput | DietWhereUniqueInput[]
  }

  export type ServingUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ServingCreateWithoutItemInput, ServingUncheckedCreateWithoutItemInput> | ServingCreateWithoutItemInput[] | ServingUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ServingCreateOrConnectWithoutItemInput | ServingCreateOrConnectWithoutItemInput[]
    createMany?: ServingCreateManyItemInputEnvelope
    connect?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
  }

  export type DietUpdateManyWithoutItemsNestedInput = {
    create?: XOR<DietCreateWithoutItemsInput, DietUncheckedCreateWithoutItemsInput> | DietCreateWithoutItemsInput[] | DietUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: DietCreateOrConnectWithoutItemsInput | DietCreateOrConnectWithoutItemsInput[]
    upsert?: DietUpsertWithWhereUniqueWithoutItemsInput | DietUpsertWithWhereUniqueWithoutItemsInput[]
    set?: DietWhereUniqueInput | DietWhereUniqueInput[]
    disconnect?: DietWhereUniqueInput | DietWhereUniqueInput[]
    delete?: DietWhereUniqueInput | DietWhereUniqueInput[]
    connect?: DietWhereUniqueInput | DietWhereUniqueInput[]
    update?: DietUpdateWithWhereUniqueWithoutItemsInput | DietUpdateWithWhereUniqueWithoutItemsInput[]
    updateMany?: DietUpdateManyWithWhereWithoutItemsInput | DietUpdateManyWithWhereWithoutItemsInput[]
    deleteMany?: DietScalarWhereInput | DietScalarWhereInput[]
  }

  export type ServingUpdateManyWithoutItemNestedInput = {
    create?: XOR<ServingCreateWithoutItemInput, ServingUncheckedCreateWithoutItemInput> | ServingCreateWithoutItemInput[] | ServingUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ServingCreateOrConnectWithoutItemInput | ServingCreateOrConnectWithoutItemInput[]
    upsert?: ServingUpsertWithWhereUniqueWithoutItemInput | ServingUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ServingCreateManyItemInputEnvelope
    set?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
    disconnect?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
    delete?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
    connect?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
    update?: ServingUpdateWithWhereUniqueWithoutItemInput | ServingUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ServingUpdateManyWithWhereWithoutItemInput | ServingUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ServingScalarWhereInput | ServingScalarWhereInput[]
  }

  export type DietUncheckedUpdateManyWithoutItemsNestedInput = {
    create?: XOR<DietCreateWithoutItemsInput, DietUncheckedCreateWithoutItemsInput> | DietCreateWithoutItemsInput[] | DietUncheckedCreateWithoutItemsInput[]
    connectOrCreate?: DietCreateOrConnectWithoutItemsInput | DietCreateOrConnectWithoutItemsInput[]
    upsert?: DietUpsertWithWhereUniqueWithoutItemsInput | DietUpsertWithWhereUniqueWithoutItemsInput[]
    set?: DietWhereUniqueInput | DietWhereUniqueInput[]
    disconnect?: DietWhereUniqueInput | DietWhereUniqueInput[]
    delete?: DietWhereUniqueInput | DietWhereUniqueInput[]
    connect?: DietWhereUniqueInput | DietWhereUniqueInput[]
    update?: DietUpdateWithWhereUniqueWithoutItemsInput | DietUpdateWithWhereUniqueWithoutItemsInput[]
    updateMany?: DietUpdateManyWithWhereWithoutItemsInput | DietUpdateManyWithWhereWithoutItemsInput[]
    deleteMany?: DietScalarWhereInput | DietScalarWhereInput[]
  }

  export type ServingUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ServingCreateWithoutItemInput, ServingUncheckedCreateWithoutItemInput> | ServingCreateWithoutItemInput[] | ServingUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ServingCreateOrConnectWithoutItemInput | ServingCreateOrConnectWithoutItemInput[]
    upsert?: ServingUpsertWithWhereUniqueWithoutItemInput | ServingUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ServingCreateManyItemInputEnvelope
    set?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
    disconnect?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
    delete?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
    connect?: ServingWhereUniqueInput | ServingWhereUniqueInput[]
    update?: ServingUpdateWithWhereUniqueWithoutItemInput | ServingUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ServingUpdateManyWithWhereWithoutItemInput | ServingUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ServingScalarWhereInput | ServingScalarWhereInput[]
  }

  export type DietCreateNestedOneWithoutHealthReportInput = {
    create?: XOR<DietCreateWithoutHealthReportInput, DietUncheckedCreateWithoutHealthReportInput>
    connectOrCreate?: DietCreateOrConnectWithoutHealthReportInput
    connect?: DietWhereUniqueInput
  }

  export type DietUpdateOneWithoutHealthReportNestedInput = {
    create?: XOR<DietCreateWithoutHealthReportInput, DietUncheckedCreateWithoutHealthReportInput>
    connectOrCreate?: DietCreateOrConnectWithoutHealthReportInput
    upsert?: DietUpsertWithoutHealthReportInput
    disconnect?: DietWhereInput | boolean
    delete?: DietWhereInput | boolean
    connect?: DietWhereUniqueInput
    update?: XOR<XOR<DietUpdateToOneWithWhereWithoutHealthReportInput, DietUpdateWithoutHealthReportInput>, DietUncheckedUpdateWithoutHealthReportInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumautoSettingFilter<$PrismaModel = never> = {
    equals?: $Enums.autoSetting | EnumautoSettingFieldRefInput<$PrismaModel>
    in?: $Enums.autoSetting[] | ListEnumautoSettingFieldRefInput<$PrismaModel>
    notIn?: $Enums.autoSetting[] | ListEnumautoSettingFieldRefInput<$PrismaModel>
    not?: NestedEnumautoSettingFilter<$PrismaModel> | $Enums.autoSetting
  }

  export type NestedEnumautoSettingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.autoSetting | EnumautoSettingFieldRefInput<$PrismaModel>
    in?: $Enums.autoSetting[] | ListEnumautoSettingFieldRefInput<$PrismaModel>
    notIn?: $Enums.autoSetting[] | ListEnumautoSettingFieldRefInput<$PrismaModel>
    not?: NestedEnumautoSettingWithAggregatesFilter<$PrismaModel> | $Enums.autoSetting
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumautoSettingFilter<$PrismaModel>
    _max?: NestedEnumautoSettingFilter<$PrismaModel>
  }

  export type NestedEnumTechnologiesFilter<$PrismaModel = never> = {
    equals?: $Enums.Technologies | EnumTechnologiesFieldRefInput<$PrismaModel>
    in?: $Enums.Technologies[] | ListEnumTechnologiesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Technologies[] | ListEnumTechnologiesFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnologiesFilter<$PrismaModel> | $Enums.Technologies
  }

  export type NestedEnumTechnologiesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Technologies | EnumTechnologiesFieldRefInput<$PrismaModel>
    in?: $Enums.Technologies[] | ListEnumTechnologiesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Technologies[] | ListEnumTechnologiesFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnologiesWithAggregatesFilter<$PrismaModel> | $Enums.Technologies
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechnologiesFilter<$PrismaModel>
    _max?: NestedEnumTechnologiesFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumImageAlignmentFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageAlignment | EnumImageAlignmentFieldRefInput<$PrismaModel>
    in?: $Enums.ImageAlignment[] | ListEnumImageAlignmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageAlignment[] | ListEnumImageAlignmentFieldRefInput<$PrismaModel>
    not?: NestedEnumImageAlignmentFilter<$PrismaModel> | $Enums.ImageAlignment
  }

  export type NestedEnumImageAlignmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageAlignment | EnumImageAlignmentFieldRefInput<$PrismaModel>
    in?: $Enums.ImageAlignment[] | ListEnumImageAlignmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageAlignment[] | ListEnumImageAlignmentFieldRefInput<$PrismaModel>
    not?: NestedEnumImageAlignmentWithAggregatesFilter<$PrismaModel> | $Enums.ImageAlignment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageAlignmentFilter<$PrismaModel>
    _max?: NestedEnumImageAlignmentFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumTaskCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCategory | EnumTaskCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskCategoryNullableFilter<$PrismaModel> | $Enums.TaskCategory | null
  }

  export type NestedEnumToDoListStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ToDoListStatus | EnumToDoListStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ToDoListStatus[] | ListEnumToDoListStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ToDoListStatus[] | ListEnumToDoListStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumToDoListStatusFilter<$PrismaModel> | $Enums.ToDoListStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaskCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCategory | EnumTaskCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumToDoListStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ToDoListStatus | EnumToDoListStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ToDoListStatus[] | ListEnumToDoListStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ToDoListStatus[] | ListEnumToDoListStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumToDoListStatusWithAggregatesFilter<$PrismaModel> | $Enums.ToDoListStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumToDoListStatusFilter<$PrismaModel>
    _max?: NestedEnumToDoListStatusFilter<$PrismaModel>
  }

  export type NestedEnumTERTIARY_TOGGLEFilter<$PrismaModel = never> = {
    equals?: $Enums.TERTIARY_TOGGLE | EnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    in?: $Enums.TERTIARY_TOGGLE[] | ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    notIn?: $Enums.TERTIARY_TOGGLE[] | ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    not?: NestedEnumTERTIARY_TOGGLEFilter<$PrismaModel> | $Enums.TERTIARY_TOGGLE
  }

  export type NestedEnumTERTIARY_TOGGLEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TERTIARY_TOGGLE | EnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    in?: $Enums.TERTIARY_TOGGLE[] | ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    notIn?: $Enums.TERTIARY_TOGGLE[] | ListEnumTERTIARY_TOGGLEFieldRefInput<$PrismaModel>
    not?: NestedEnumTERTIARY_TOGGLEWithAggregatesFilter<$PrismaModel> | $Enums.TERTIARY_TOGGLE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTERTIARY_TOGGLEFilter<$PrismaModel>
    _max?: NestedEnumTERTIARY_TOGGLEFilter<$PrismaModel>
  }

  export type NestedEnumQUANTITY_GUESSNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.QUANTITY_GUESS | EnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    in?: $Enums.QUANTITY_GUESS[] | ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QUANTITY_GUESS[] | ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQUANTITY_GUESSNullableFilter<$PrismaModel> | $Enums.QUANTITY_GUESS | null
  }

  export type NestedEnumQUANTITY_GUESSNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QUANTITY_GUESS | EnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    in?: $Enums.QUANTITY_GUESS[] | ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QUANTITY_GUESS[] | ListEnumQUANTITY_GUESSFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQUANTITY_GUESSNullableWithAggregatesFilter<$PrismaModel> | $Enums.QUANTITY_GUESS | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumQUANTITY_GUESSNullableFilter<$PrismaModel>
    _max?: NestedEnumQUANTITY_GUESSNullableFilter<$PrismaModel>
  }

  export type MdxNoteCreateWithoutSubjectsInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateWithoutSubjectsInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteCreateOrConnectWithoutSubjectsInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutSubjectsInput, MdxNoteUncheckedCreateWithoutSubjectsInput>
  }

  export type IpynbCreateWithoutSubjectsInput = {
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryCreateNestedManyWithoutIpynbNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutIpynbInput
    readingList?: ReadingListCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbUncheckedCreateWithoutSubjectsInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialKey?: string | null
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicUncheckedCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutIpynbNotesInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbCreateOrConnectWithoutSubjectsInput = {
    where: IpynbWhereUniqueInput
    create: XOR<IpynbCreateWithoutSubjectsInput, IpynbUncheckedCreateWithoutSubjectsInput>
  }

  export type QAPairCreateWithoutSubjectsInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    tags?: TagCreateNestedManyWithoutQAPairInput
    topics?: TopicCreateNestedManyWithoutQAPairInput
    practiceExam?: PracticeExamCreateNestedManyWithoutQuestionsInput
  }

  export type QAPairUncheckedCreateWithoutSubjectsInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    tags?: TagUncheckedCreateNestedManyWithoutQAPairInput
    topics?: TopicUncheckedCreateNestedManyWithoutQAPairInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QAPairCreateOrConnectWithoutSubjectsInput = {
    where: QAPairWhereUniqueInput
    create: XOR<QAPairCreateWithoutSubjectsInput, QAPairUncheckedCreateWithoutSubjectsInput>
  }

  export type PracticeExamCreateWithoutSubjectsInput = {
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    topics?: TopicCreateNestedManyWithoutPracticeExamInput
    tags?: TagCreateNestedManyWithoutPracticeExamInput
    questions?: QAPairCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamUncheckedCreateWithoutSubjectsInput = {
    id?: number
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutPracticeExamInput
    tags?: TagUncheckedCreateNestedManyWithoutPracticeExamInput
    questions?: QAPairUncheckedCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamCreateOrConnectWithoutSubjectsInput = {
    where: PracticeExamWhereUniqueInput
    create: XOR<PracticeExamCreateWithoutSubjectsInput, PracticeExamUncheckedCreateWithoutSubjectsInput>
  }

  export type KanbanCreateWithoutSubjectsInput = {
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    lists?: KanBanListCreateNestedManyWithoutKanbanInput
    tags?: TagCreateNestedManyWithoutKanbanInput
    topics?: TopicCreateNestedManyWithoutKanbanInput
  }

  export type KanbanUncheckedCreateWithoutSubjectsInput = {
    id?: number
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    lists?: KanBanListUncheckedCreateNestedManyWithoutKanbanInput
    tags?: TagUncheckedCreateNestedManyWithoutKanbanInput
    topics?: TopicUncheckedCreateNestedManyWithoutKanbanInput
  }

  export type KanbanCreateOrConnectWithoutSubjectsInput = {
    where: KanbanWhereUniqueInput
    create: XOR<KanbanCreateWithoutSubjectsInput, KanbanUncheckedCreateWithoutSubjectsInput>
  }

  export type ToDoListCreateWithoutSubjectsInput = {
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tasks?: ToDoCreateNestedManyWithoutToDoListInput
    tags?: TagCreateNestedManyWithoutTodoListInput
    topics?: TopicCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListUncheckedCreateWithoutSubjectsInput = {
    id?: number
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tasks?: ToDoUncheckedCreateNestedManyWithoutToDoListInput
    tags?: TagUncheckedCreateNestedManyWithoutTodoListInput
    topics?: TopicUncheckedCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListCreateOrConnectWithoutSubjectsInput = {
    where: ToDoListWhereUniqueInput
    create: XOR<ToDoListCreateWithoutSubjectsInput, ToDoListUncheckedCreateWithoutSubjectsInput>
  }

  export type ToDoCreateWithoutSubjectsInput = {
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    associatedNotes?: MdxNoteCreateNestedManyWithoutToDoInput
    tags?: TagCreateNestedManyWithoutToDoInput
    topics?: TopicCreateNestedManyWithoutToDoInput
    parent?: ToDoCreateNestedOneWithoutChildInput
    child?: ToDoCreateNestedManyWithoutParentInput
    ToDoList?: ToDoListCreateNestedOneWithoutTasksInput
  }

  export type ToDoUncheckedCreateWithoutSubjectsInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
    associatedNotes?: MdxNoteUncheckedCreateNestedManyWithoutToDoInput
    tags?: TagUncheckedCreateNestedManyWithoutToDoInput
    topics?: TopicUncheckedCreateNestedManyWithoutToDoInput
    child?: ToDoUncheckedCreateNestedManyWithoutParentInput
  }

  export type ToDoCreateOrConnectWithoutSubjectsInput = {
    where: ToDoWhereUniqueInput
    create: XOR<ToDoCreateWithoutSubjectsInput, ToDoUncheckedCreateWithoutSubjectsInput>
  }

  export type BibEntryCreateWithoutSubjectsInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    Bib?: BibCreateNestedOneWithoutEntriesInput
    citationGroups?: CitationsGroupCreateNestedManyWithoutEntriesInput
    tags?: TagCreateNestedManyWithoutBibEntriesInput
    topics?: TopicCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUncheckedCreateWithoutSubjectsInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput
    tags?: TagUncheckedCreateNestedManyWithoutBibEntriesInput
    topics?: TopicUncheckedCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryCreateOrConnectWithoutSubjectsInput = {
    where: BibEntryWhereUniqueInput
    create: XOR<BibEntryCreateWithoutSubjectsInput, BibEntryUncheckedCreateWithoutSubjectsInput>
  }

  export type EquationCreateWithoutSubjectsInput = {
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesCreateNestedManyWithoutEquationsInput
    tags?: TagCreateNestedManyWithoutEquationsInput
    topics?: TopicCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteCreateNestedManyWithoutEquationsInput
  }

  export type EquationUncheckedCreateWithoutSubjectsInput = {
    id?: number
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesUncheckedCreateNestedManyWithoutEquationsInput
    tags?: TagUncheckedCreateNestedManyWithoutEquationsInput
    topics?: TopicUncheckedCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutEquationsInput
  }

  export type EquationCreateOrConnectWithoutSubjectsInput = {
    where: EquationWhereUniqueInput
    create: XOR<EquationCreateWithoutSubjectsInput, EquationUncheckedCreateWithoutSubjectsInput>
  }

  export type MdxNoteUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: MdxNoteWhereUniqueInput
    update: XOR<MdxNoteUpdateWithoutSubjectsInput, MdxNoteUncheckedUpdateWithoutSubjectsInput>
    create: XOR<MdxNoteCreateWithoutSubjectsInput, MdxNoteUncheckedCreateWithoutSubjectsInput>
  }

  export type MdxNoteUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: MdxNoteWhereUniqueInput
    data: XOR<MdxNoteUpdateWithoutSubjectsInput, MdxNoteUncheckedUpdateWithoutSubjectsInput>
  }

  export type MdxNoteUpdateManyWithWhereWithoutSubjectsInput = {
    where: MdxNoteScalarWhereInput
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type MdxNoteScalarWhereInput = {
    AND?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
    OR?: MdxNoteScalarWhereInput[]
    NOT?: MdxNoteScalarWhereInput | MdxNoteScalarWhereInput[]
    id?: IntFilter<"MdxNote"> | number
    isProtected?: BoolNullableFilter<"MdxNote"> | boolean | null
    dietSummaryKey?: StringNullableFilter<"MdxNote"> | string | null
    title?: StringFilter<"MdxNote"> | string
    latexTitle?: StringNullableFilter<"MdxNote"> | string | null
    rootRelativePath?: StringFilter<"MdxNote"> | string
    noteType?: StringFilter<"MdxNote"> | string
    content?: StringFilter<"MdxNote"> | string
    formatted?: StringNullableFilter<"MdxNote"> | string | null
    summary?: StringNullableFilter<"MdxNote"> | string | null
    citationsListOrder?: StringNullableListFilter<"MdxNote">
    importantValues?: FloatNullableListFilter<"MdxNote">
    imageSrc?: StringNullableFilter<"MdxNote"> | string | null
    href?: StringFilter<"MdxNote"> | string
    sequentialKey?: StringNullableFilter<"MdxNote"> | string | null
    sequentialIndex?: FloatNullableFilter<"MdxNote"> | number | null
    floatImages?: BoolFilter<"MdxNote"> | boolean
    remoteUrl?: StringNullableFilter<"MdxNote"> | string | null
    trackRemote?: BoolFilter<"MdxNote"> | boolean
    outgoingQuickLinks?: StringNullableListFilter<"MdxNote">
    quickLink?: StringNullableFilter<"MdxNote"> | string | null
    bookmarked?: BoolFilter<"MdxNote"> | boolean
    firstSync?: DateTimeFilter<"MdxNote"> | Date | string
    lastSync?: DateTimeFilter<"MdxNote"> | Date | string
  }

  export type IpynbUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: IpynbWhereUniqueInput
    update: XOR<IpynbUpdateWithoutSubjectsInput, IpynbUncheckedUpdateWithoutSubjectsInput>
    create: XOR<IpynbCreateWithoutSubjectsInput, IpynbUncheckedCreateWithoutSubjectsInput>
  }

  export type IpynbUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: IpynbWhereUniqueInput
    data: XOR<IpynbUpdateWithoutSubjectsInput, IpynbUncheckedUpdateWithoutSubjectsInput>
  }

  export type IpynbUpdateManyWithWhereWithoutSubjectsInput = {
    where: IpynbScalarWhereInput
    data: XOR<IpynbUpdateManyMutationInput, IpynbUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type IpynbScalarWhereInput = {
    AND?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
    OR?: IpynbScalarWhereInput[]
    NOT?: IpynbScalarWhereInput | IpynbScalarWhereInput[]
    id?: IntFilter<"Ipynb"> | number
    rootRelativePath?: StringFilter<"Ipynb"> | string
    isProtected?: BoolNullableFilter<"Ipynb"> | boolean | null
    title?: StringFilter<"Ipynb"> | string
    latexTitle?: StringNullableFilter<"Ipynb"> | string | null
    citationsListOrder?: StringNullableListFilter<"Ipynb">
    importantValues?: FloatNullableListFilter<"Ipynb">
    href?: StringFilter<"Ipynb"> | string
    outgoingQuickLinks?: StringNullableListFilter<"Ipynb">
    raw?: BytesFilter<"Ipynb"> | Buffer
    sequentialKey?: StringNullableFilter<"Ipynb"> | string | null
    sequentialIndex?: IntNullableFilter<"Ipynb"> | number | null
    bookmarked?: BoolFilter<"Ipynb"> | boolean
    firstSync?: DateTimeFilter<"Ipynb"> | Date | string
    lastSync?: DateTimeFilter<"Ipynb"> | Date | string
  }

  export type QAPairUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: QAPairWhereUniqueInput
    update: XOR<QAPairUpdateWithoutSubjectsInput, QAPairUncheckedUpdateWithoutSubjectsInput>
    create: XOR<QAPairCreateWithoutSubjectsInput, QAPairUncheckedCreateWithoutSubjectsInput>
  }

  export type QAPairUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: QAPairWhereUniqueInput
    data: XOR<QAPairUpdateWithoutSubjectsInput, QAPairUncheckedUpdateWithoutSubjectsInput>
  }

  export type QAPairUpdateManyWithWhereWithoutSubjectsInput = {
    where: QAPairScalarWhereInput
    data: XOR<QAPairUpdateManyMutationInput, QAPairUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type QAPairScalarWhereInput = {
    AND?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
    OR?: QAPairScalarWhereInput[]
    NOT?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
    id?: StringFilter<"QAPair"> | string
    question?: StringFilter<"QAPair"> | string
    answer?: StringFilter<"QAPair"> | string
    description?: StringNullableFilter<"QAPair"> | string | null
    secondaryLabel?: StringNullableFilter<"QAPair"> | string | null
    correctCount?: IntFilter<"QAPair"> | number
    inCorrectCount?: IntFilter<"QAPair"> | number
  }

  export type PracticeExamUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: PracticeExamWhereUniqueInput
    update: XOR<PracticeExamUpdateWithoutSubjectsInput, PracticeExamUncheckedUpdateWithoutSubjectsInput>
    create: XOR<PracticeExamCreateWithoutSubjectsInput, PracticeExamUncheckedCreateWithoutSubjectsInput>
  }

  export type PracticeExamUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: PracticeExamWhereUniqueInput
    data: XOR<PracticeExamUpdateWithoutSubjectsInput, PracticeExamUncheckedUpdateWithoutSubjectsInput>
  }

  export type PracticeExamUpdateManyWithWhereWithoutSubjectsInput = {
    where: PracticeExamScalarWhereInput
    data: XOR<PracticeExamUpdateManyMutationInput, PracticeExamUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type PracticeExamScalarWhereInput = {
    AND?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
    OR?: PracticeExamScalarWhereInput[]
    NOT?: PracticeExamScalarWhereInput | PracticeExamScalarWhereInput[]
    id?: IntFilter<"PracticeExam"> | number
    correctCount?: IntFilter<"PracticeExam"> | number
    inCorrectCount?: IntFilter<"PracticeExam"> | number
    timeLimitInSeconds?: IntFilter<"PracticeExam"> | number
    timeCompletedInSeconds?: IntFilter<"PracticeExam"> | number
    date?: DateTimeFilter<"PracticeExam"> | Date | string
  }

  export type KanbanUpsertWithoutSubjectsInput = {
    update: XOR<KanbanUpdateWithoutSubjectsInput, KanbanUncheckedUpdateWithoutSubjectsInput>
    create: XOR<KanbanCreateWithoutSubjectsInput, KanbanUncheckedCreateWithoutSubjectsInput>
    where?: KanbanWhereInput
  }

  export type KanbanUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: KanbanWhereInput
    data: XOR<KanbanUpdateWithoutSubjectsInput, KanbanUncheckedUpdateWithoutSubjectsInput>
  }

  export type KanbanUpdateWithoutSubjectsInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: KanBanListUpdateManyWithoutKanbanNestedInput
    tags?: TagUpdateManyWithoutKanbanNestedInput
    topics?: TopicUpdateManyWithoutKanbanNestedInput
  }

  export type KanbanUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: KanBanListUncheckedUpdateManyWithoutKanbanNestedInput
    tags?: TagUncheckedUpdateManyWithoutKanbanNestedInput
    topics?: TopicUncheckedUpdateManyWithoutKanbanNestedInput
  }

  export type ToDoListUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: ToDoListWhereUniqueInput
    update: XOR<ToDoListUpdateWithoutSubjectsInput, ToDoListUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ToDoListCreateWithoutSubjectsInput, ToDoListUncheckedCreateWithoutSubjectsInput>
  }

  export type ToDoListUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: ToDoListWhereUniqueInput
    data: XOR<ToDoListUpdateWithoutSubjectsInput, ToDoListUncheckedUpdateWithoutSubjectsInput>
  }

  export type ToDoListUpdateManyWithWhereWithoutSubjectsInput = {
    where: ToDoListScalarWhereInput
    data: XOR<ToDoListUpdateManyMutationInput, ToDoListUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type ToDoListScalarWhereInput = {
    AND?: ToDoListScalarWhereInput | ToDoListScalarWhereInput[]
    OR?: ToDoListScalarWhereInput[]
    NOT?: ToDoListScalarWhereInput | ToDoListScalarWhereInput[]
    id?: IntFilter<"ToDoList"> | number
    label?: StringFilter<"ToDoList"> | string
    createdAt?: DateTimeFilter<"ToDoList"> | Date | string
    lastUpdate?: DateTimeFilter<"ToDoList"> | Date | string
  }

  export type ToDoUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: ToDoWhereUniqueInput
    update: XOR<ToDoUpdateWithoutSubjectsInput, ToDoUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ToDoCreateWithoutSubjectsInput, ToDoUncheckedCreateWithoutSubjectsInput>
  }

  export type ToDoUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: ToDoWhereUniqueInput
    data: XOR<ToDoUpdateWithoutSubjectsInput, ToDoUncheckedUpdateWithoutSubjectsInput>
  }

  export type ToDoUpdateManyWithWhereWithoutSubjectsInput = {
    where: ToDoScalarWhereInput
    data: XOR<ToDoUpdateManyMutationInput, ToDoUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type ToDoScalarWhereInput = {
    AND?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
    OR?: ToDoScalarWhereInput[]
    NOT?: ToDoScalarWhereInput | ToDoScalarWhereInput[]
    id?: IntFilter<"ToDo"> | number
    createdAt?: DateTimeFilter<"ToDo"> | Date | string
    task?: StringFilter<"ToDo"> | string
    dueAt?: DateTimeNullableFilter<"ToDo"> | Date | string | null
    details?: StringNullableFilter<"ToDo"> | string | null
    parentId?: IntNullableFilter<"ToDo"> | number | null
    category?: EnumTaskCategoryNullableFilter<"ToDo"> | $Enums.TaskCategory | null
    bookmarked?: BoolFilter<"ToDo"> | boolean
    status?: EnumToDoListStatusFilter<"ToDo"> | $Enums.ToDoListStatus
    priority?: IntFilter<"ToDo"> | number
    toDoListId?: IntNullableFilter<"ToDo"> | number | null
  }

  export type BibEntryUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: BibEntryWhereUniqueInput
    update: XOR<BibEntryUpdateWithoutSubjectsInput, BibEntryUncheckedUpdateWithoutSubjectsInput>
    create: XOR<BibEntryCreateWithoutSubjectsInput, BibEntryUncheckedCreateWithoutSubjectsInput>
  }

  export type BibEntryUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: BibEntryWhereUniqueInput
    data: XOR<BibEntryUpdateWithoutSubjectsInput, BibEntryUncheckedUpdateWithoutSubjectsInput>
  }

  export type BibEntryUpdateManyWithWhereWithoutSubjectsInput = {
    where: BibEntryScalarWhereInput
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type BibEntryScalarWhereInput = {
    AND?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
    OR?: BibEntryScalarWhereInput[]
    NOT?: BibEntryScalarWhereInput | BibEntryScalarWhereInput[]
    id?: StringFilter<"BibEntry"> | string
    BibId?: IntNullableFilter<"BibEntry"> | number | null
    OwnWork?: BoolFilter<"BibEntry"> | boolean
    ColleaguesWork?: BoolFilter<"BibEntry"> | boolean
    read?: BoolFilter<"BibEntry"> | boolean
    htmlCitation?: StringNullableFilter<"BibEntry"> | string | null
    PdfPath?: StringNullableFilter<"BibEntry"> | string | null
    address?: StringNullableFilter<"BibEntry"> | string | null
    annote?: StringNullableFilter<"BibEntry"> | string | null
    author?: StringNullableFilter<"BibEntry"> | string | null
    booktitle?: StringNullableFilter<"BibEntry"> | string | null
    chapter?: StringNullableFilter<"BibEntry"> | string | null
    crossref?: StringNullableFilter<"BibEntry"> | string | null
    doi?: StringNullableFilter<"BibEntry"> | string | null
    edition?: StringNullableFilter<"BibEntry"> | string | null
    editor?: StringNullableFilter<"BibEntry"> | string | null
    email?: StringNullableFilter<"BibEntry"> | string | null
    howpublished?: StringNullableFilter<"BibEntry"> | string | null
    institution?: StringNullableFilter<"BibEntry"> | string | null
    journal?: StringNullableFilter<"BibEntry"> | string | null
    month?: StringNullableFilter<"BibEntry"> | string | null
    note?: StringNullableFilter<"BibEntry"> | string | null
    number?: StringNullableFilter<"BibEntry"> | string | null
    organization?: StringNullableFilter<"BibEntry"> | string | null
    pages?: StringNullableFilter<"BibEntry"> | string | null
    publisher?: StringNullableFilter<"BibEntry"> | string | null
    school?: StringNullableFilter<"BibEntry"> | string | null
    series?: StringNullableFilter<"BibEntry"> | string | null
    title?: StringNullableFilter<"BibEntry"> | string | null
    volume?: StringNullableFilter<"BibEntry"> | string | null
    type?: StringNullableFilter<"BibEntry"> | string | null
    year?: StringNullableFilter<"BibEntry"> | string | null
    numpages?: StringNullableFilter<"BibEntry"> | string | null
    url?: StringNullableFilter<"BibEntry"> | string | null
    issue?: StringNullableFilter<"BibEntry"> | string | null
    issn?: StringNullableFilter<"BibEntry"> | string | null
    abstract?: StringNullableFilter<"BibEntry"> | string | null
    urldate?: StringNullableFilter<"BibEntry"> | string | null
    keywords?: StringNullableFilter<"BibEntry"> | string | null
    copyright?: StringNullableFilter<"BibEntry"> | string | null
    added?: DateTimeFilter<"BibEntry"> | Date | string
  }

  export type EquationUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: EquationWhereUniqueInput
    update: XOR<EquationUpdateWithoutSubjectsInput, EquationUncheckedUpdateWithoutSubjectsInput>
    create: XOR<EquationCreateWithoutSubjectsInput, EquationUncheckedCreateWithoutSubjectsInput>
  }

  export type EquationUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: EquationWhereUniqueInput
    data: XOR<EquationUpdateWithoutSubjectsInput, EquationUncheckedUpdateWithoutSubjectsInput>
  }

  export type EquationUpdateManyWithWhereWithoutSubjectsInput = {
    where: EquationScalarWhereInput
    data: XOR<EquationUpdateManyMutationInput, EquationUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type EquationScalarWhereInput = {
    AND?: EquationScalarWhereInput | EquationScalarWhereInput[]
    OR?: EquationScalarWhereInput[]
    NOT?: EquationScalarWhereInput | EquationScalarWhereInput[]
    id?: IntFilter<"Equation"> | number
    equationId?: StringNullableFilter<"Equation"> | string | null
    title?: StringFilter<"Equation"> | string
    desc?: StringNullableFilter<"Equation"> | string | null
    content?: StringFilter<"Equation"> | string
    asPython?: StringNullableFilter<"Equation"> | string | null
    variableLegend?: JsonNullableFilter<"Equation">
    variables?: StringNullableListFilter<"Equation">
    keywords?: StringNullableListFilter<"Equation">
    createdAt?: DateTimeFilter<"Equation"> | Date | string
  }

  export type MdxNoteCreateWithoutTopicsInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateWithoutTopicsInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteCreateOrConnectWithoutTopicsInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutTopicsInput, MdxNoteUncheckedCreateWithoutTopicsInput>
  }

  export type IpynbCreateWithoutTopicsInput = {
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryCreateNestedManyWithoutIpynbNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutIpynbInput
    readingList?: ReadingListCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbUncheckedCreateWithoutTopicsInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialKey?: string | null
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutIpynbNotesInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbCreateOrConnectWithoutTopicsInput = {
    where: IpynbWhereUniqueInput
    create: XOR<IpynbCreateWithoutTopicsInput, IpynbUncheckedCreateWithoutTopicsInput>
  }

  export type QAPairCreateWithoutTopicsInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    tags?: TagCreateNestedManyWithoutQAPairInput
    subjects?: SubjectCreateNestedManyWithoutQaPairInput
    practiceExam?: PracticeExamCreateNestedManyWithoutQuestionsInput
  }

  export type QAPairUncheckedCreateWithoutTopicsInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    tags?: TagUncheckedCreateNestedManyWithoutQAPairInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutQaPairInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QAPairCreateOrConnectWithoutTopicsInput = {
    where: QAPairWhereUniqueInput
    create: XOR<QAPairCreateWithoutTopicsInput, QAPairUncheckedCreateWithoutTopicsInput>
  }

  export type PracticeExamCreateWithoutTopicsInput = {
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    tags?: TagCreateNestedManyWithoutPracticeExamInput
    subjects?: SubjectCreateNestedManyWithoutPracticeExamInput
    questions?: QAPairCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamUncheckedCreateWithoutTopicsInput = {
    id?: number
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutPracticeExamInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutPracticeExamInput
    questions?: QAPairUncheckedCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamCreateOrConnectWithoutTopicsInput = {
    where: PracticeExamWhereUniqueInput
    create: XOR<PracticeExamCreateWithoutTopicsInput, PracticeExamUncheckedCreateWithoutTopicsInput>
  }

  export type ToDoCreateWithoutTopicsInput = {
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    associatedNotes?: MdxNoteCreateNestedManyWithoutToDoInput
    tags?: TagCreateNestedManyWithoutToDoInput
    subjects?: SubjectCreateNestedManyWithoutToDoInput
    parent?: ToDoCreateNestedOneWithoutChildInput
    child?: ToDoCreateNestedManyWithoutParentInput
    ToDoList?: ToDoListCreateNestedOneWithoutTasksInput
  }

  export type ToDoUncheckedCreateWithoutTopicsInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
    associatedNotes?: MdxNoteUncheckedCreateNestedManyWithoutToDoInput
    tags?: TagUncheckedCreateNestedManyWithoutToDoInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutToDoInput
    child?: ToDoUncheckedCreateNestedManyWithoutParentInput
  }

  export type ToDoCreateOrConnectWithoutTopicsInput = {
    where: ToDoWhereUniqueInput
    create: XOR<ToDoCreateWithoutTopicsInput, ToDoUncheckedCreateWithoutTopicsInput>
  }

  export type KanbanCreateWithoutTopicsInput = {
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    lists?: KanBanListCreateNestedManyWithoutKanbanInput
    tags?: TagCreateNestedManyWithoutKanbanInput
    subjects?: SubjectCreateNestedManyWithoutKanbanInput
  }

  export type KanbanUncheckedCreateWithoutTopicsInput = {
    id?: number
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    lists?: KanBanListUncheckedCreateNestedManyWithoutKanbanInput
    tags?: TagUncheckedCreateNestedManyWithoutKanbanInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutKanbanInput
  }

  export type KanbanCreateOrConnectWithoutTopicsInput = {
    where: KanbanWhereUniqueInput
    create: XOR<KanbanCreateWithoutTopicsInput, KanbanUncheckedCreateWithoutTopicsInput>
  }

  export type ToDoListCreateWithoutTopicsInput = {
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tasks?: ToDoCreateNestedManyWithoutToDoListInput
    tags?: TagCreateNestedManyWithoutTodoListInput
    subjects?: SubjectCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListUncheckedCreateWithoutTopicsInput = {
    id?: number
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tasks?: ToDoUncheckedCreateNestedManyWithoutToDoListInput
    tags?: TagUncheckedCreateNestedManyWithoutTodoListInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListCreateOrConnectWithoutTopicsInput = {
    where: ToDoListWhereUniqueInput
    create: XOR<ToDoListCreateWithoutTopicsInput, ToDoListUncheckedCreateWithoutTopicsInput>
  }

  export type BibEntryCreateWithoutTopicsInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    Bib?: BibCreateNestedOneWithoutEntriesInput
    citationGroups?: CitationsGroupCreateNestedManyWithoutEntriesInput
    tags?: TagCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUncheckedCreateWithoutTopicsInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput
    tags?: TagUncheckedCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryCreateOrConnectWithoutTopicsInput = {
    where: BibEntryWhereUniqueInput
    create: XOR<BibEntryCreateWithoutTopicsInput, BibEntryUncheckedCreateWithoutTopicsInput>
  }

  export type EquationCreateWithoutTopicsInput = {
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesCreateNestedManyWithoutEquationsInput
    tags?: TagCreateNestedManyWithoutEquationsInput
    subjects?: SubjectCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteCreateNestedManyWithoutEquationsInput
  }

  export type EquationUncheckedCreateWithoutTopicsInput = {
    id?: number
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesUncheckedCreateNestedManyWithoutEquationsInput
    tags?: TagUncheckedCreateNestedManyWithoutEquationsInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutEquationsInput
  }

  export type EquationCreateOrConnectWithoutTopicsInput = {
    where: EquationWhereUniqueInput
    create: XOR<EquationCreateWithoutTopicsInput, EquationUncheckedCreateWithoutTopicsInput>
  }

  export type MdxNoteUpsertWithWhereUniqueWithoutTopicsInput = {
    where: MdxNoteWhereUniqueInput
    update: XOR<MdxNoteUpdateWithoutTopicsInput, MdxNoteUncheckedUpdateWithoutTopicsInput>
    create: XOR<MdxNoteCreateWithoutTopicsInput, MdxNoteUncheckedCreateWithoutTopicsInput>
  }

  export type MdxNoteUpdateWithWhereUniqueWithoutTopicsInput = {
    where: MdxNoteWhereUniqueInput
    data: XOR<MdxNoteUpdateWithoutTopicsInput, MdxNoteUncheckedUpdateWithoutTopicsInput>
  }

  export type MdxNoteUpdateManyWithWhereWithoutTopicsInput = {
    where: MdxNoteScalarWhereInput
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyWithoutTopicsInput>
  }

  export type IpynbUpsertWithWhereUniqueWithoutTopicsInput = {
    where: IpynbWhereUniqueInput
    update: XOR<IpynbUpdateWithoutTopicsInput, IpynbUncheckedUpdateWithoutTopicsInput>
    create: XOR<IpynbCreateWithoutTopicsInput, IpynbUncheckedCreateWithoutTopicsInput>
  }

  export type IpynbUpdateWithWhereUniqueWithoutTopicsInput = {
    where: IpynbWhereUniqueInput
    data: XOR<IpynbUpdateWithoutTopicsInput, IpynbUncheckedUpdateWithoutTopicsInput>
  }

  export type IpynbUpdateManyWithWhereWithoutTopicsInput = {
    where: IpynbScalarWhereInput
    data: XOR<IpynbUpdateManyMutationInput, IpynbUncheckedUpdateManyWithoutTopicsInput>
  }

  export type QAPairUpsertWithWhereUniqueWithoutTopicsInput = {
    where: QAPairWhereUniqueInput
    update: XOR<QAPairUpdateWithoutTopicsInput, QAPairUncheckedUpdateWithoutTopicsInput>
    create: XOR<QAPairCreateWithoutTopicsInput, QAPairUncheckedCreateWithoutTopicsInput>
  }

  export type QAPairUpdateWithWhereUniqueWithoutTopicsInput = {
    where: QAPairWhereUniqueInput
    data: XOR<QAPairUpdateWithoutTopicsInput, QAPairUncheckedUpdateWithoutTopicsInput>
  }

  export type QAPairUpdateManyWithWhereWithoutTopicsInput = {
    where: QAPairScalarWhereInput
    data: XOR<QAPairUpdateManyMutationInput, QAPairUncheckedUpdateManyWithoutTopicsInput>
  }

  export type PracticeExamUpsertWithWhereUniqueWithoutTopicsInput = {
    where: PracticeExamWhereUniqueInput
    update: XOR<PracticeExamUpdateWithoutTopicsInput, PracticeExamUncheckedUpdateWithoutTopicsInput>
    create: XOR<PracticeExamCreateWithoutTopicsInput, PracticeExamUncheckedCreateWithoutTopicsInput>
  }

  export type PracticeExamUpdateWithWhereUniqueWithoutTopicsInput = {
    where: PracticeExamWhereUniqueInput
    data: XOR<PracticeExamUpdateWithoutTopicsInput, PracticeExamUncheckedUpdateWithoutTopicsInput>
  }

  export type PracticeExamUpdateManyWithWhereWithoutTopicsInput = {
    where: PracticeExamScalarWhereInput
    data: XOR<PracticeExamUpdateManyMutationInput, PracticeExamUncheckedUpdateManyWithoutTopicsInput>
  }

  export type ToDoUpsertWithWhereUniqueWithoutTopicsInput = {
    where: ToDoWhereUniqueInput
    update: XOR<ToDoUpdateWithoutTopicsInput, ToDoUncheckedUpdateWithoutTopicsInput>
    create: XOR<ToDoCreateWithoutTopicsInput, ToDoUncheckedCreateWithoutTopicsInput>
  }

  export type ToDoUpdateWithWhereUniqueWithoutTopicsInput = {
    where: ToDoWhereUniqueInput
    data: XOR<ToDoUpdateWithoutTopicsInput, ToDoUncheckedUpdateWithoutTopicsInput>
  }

  export type ToDoUpdateManyWithWhereWithoutTopicsInput = {
    where: ToDoScalarWhereInput
    data: XOR<ToDoUpdateManyMutationInput, ToDoUncheckedUpdateManyWithoutTopicsInput>
  }

  export type KanbanUpsertWithoutTopicsInput = {
    update: XOR<KanbanUpdateWithoutTopicsInput, KanbanUncheckedUpdateWithoutTopicsInput>
    create: XOR<KanbanCreateWithoutTopicsInput, KanbanUncheckedCreateWithoutTopicsInput>
    where?: KanbanWhereInput
  }

  export type KanbanUpdateToOneWithWhereWithoutTopicsInput = {
    where?: KanbanWhereInput
    data: XOR<KanbanUpdateWithoutTopicsInput, KanbanUncheckedUpdateWithoutTopicsInput>
  }

  export type KanbanUpdateWithoutTopicsInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: KanBanListUpdateManyWithoutKanbanNestedInput
    tags?: TagUpdateManyWithoutKanbanNestedInput
    subjects?: SubjectUpdateManyWithoutKanbanNestedInput
  }

  export type KanbanUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: KanBanListUncheckedUpdateManyWithoutKanbanNestedInput
    tags?: TagUncheckedUpdateManyWithoutKanbanNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutKanbanNestedInput
  }

  export type ToDoListUpsertWithWhereUniqueWithoutTopicsInput = {
    where: ToDoListWhereUniqueInput
    update: XOR<ToDoListUpdateWithoutTopicsInput, ToDoListUncheckedUpdateWithoutTopicsInput>
    create: XOR<ToDoListCreateWithoutTopicsInput, ToDoListUncheckedCreateWithoutTopicsInput>
  }

  export type ToDoListUpdateWithWhereUniqueWithoutTopicsInput = {
    where: ToDoListWhereUniqueInput
    data: XOR<ToDoListUpdateWithoutTopicsInput, ToDoListUncheckedUpdateWithoutTopicsInput>
  }

  export type ToDoListUpdateManyWithWhereWithoutTopicsInput = {
    where: ToDoListScalarWhereInput
    data: XOR<ToDoListUpdateManyMutationInput, ToDoListUncheckedUpdateManyWithoutTopicsInput>
  }

  export type BibEntryUpsertWithWhereUniqueWithoutTopicsInput = {
    where: BibEntryWhereUniqueInput
    update: XOR<BibEntryUpdateWithoutTopicsInput, BibEntryUncheckedUpdateWithoutTopicsInput>
    create: XOR<BibEntryCreateWithoutTopicsInput, BibEntryUncheckedCreateWithoutTopicsInput>
  }

  export type BibEntryUpdateWithWhereUniqueWithoutTopicsInput = {
    where: BibEntryWhereUniqueInput
    data: XOR<BibEntryUpdateWithoutTopicsInput, BibEntryUncheckedUpdateWithoutTopicsInput>
  }

  export type BibEntryUpdateManyWithWhereWithoutTopicsInput = {
    where: BibEntryScalarWhereInput
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyWithoutTopicsInput>
  }

  export type EquationUpsertWithWhereUniqueWithoutTopicsInput = {
    where: EquationWhereUniqueInput
    update: XOR<EquationUpdateWithoutTopicsInput, EquationUncheckedUpdateWithoutTopicsInput>
    create: XOR<EquationCreateWithoutTopicsInput, EquationUncheckedCreateWithoutTopicsInput>
  }

  export type EquationUpdateWithWhereUniqueWithoutTopicsInput = {
    where: EquationWhereUniqueInput
    data: XOR<EquationUpdateWithoutTopicsInput, EquationUncheckedUpdateWithoutTopicsInput>
  }

  export type EquationUpdateManyWithWhereWithoutTopicsInput = {
    where: EquationScalarWhereInput
    data: XOR<EquationUpdateManyMutationInput, EquationUncheckedUpdateManyWithoutTopicsInput>
  }

  export type MdxNoteCreateWithoutTagsInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateWithoutTagsInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteCreateOrConnectWithoutTagsInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutTagsInput, MdxNoteUncheckedCreateWithoutTagsInput>
  }

  export type BibEntryCreateWithoutTagsInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    Bib?: BibCreateNestedOneWithoutEntriesInput
    citationGroups?: CitationsGroupCreateNestedManyWithoutEntriesInput
    topics?: TopicCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUncheckedCreateWithoutTagsInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput
    topics?: TopicUncheckedCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryCreateOrConnectWithoutTagsInput = {
    where: BibEntryWhereUniqueInput
    create: XOR<BibEntryCreateWithoutTagsInput, BibEntryUncheckedCreateWithoutTagsInput>
  }

  export type IpynbCreateWithoutTagsInput = {
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryCreateNestedManyWithoutIpynbNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutIpynbInput
    readingList?: ReadingListCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbUncheckedCreateWithoutTagsInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialKey?: string | null
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutIpynbNotesInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbCreateOrConnectWithoutTagsInput = {
    where: IpynbWhereUniqueInput
    create: XOR<IpynbCreateWithoutTagsInput, IpynbUncheckedCreateWithoutTagsInput>
  }

  export type QAPairCreateWithoutTagsInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    topics?: TopicCreateNestedManyWithoutQAPairInput
    subjects?: SubjectCreateNestedManyWithoutQaPairInput
    practiceExam?: PracticeExamCreateNestedManyWithoutQuestionsInput
  }

  export type QAPairUncheckedCreateWithoutTagsInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    topics?: TopicUncheckedCreateNestedManyWithoutQAPairInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutQaPairInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QAPairCreateOrConnectWithoutTagsInput = {
    where: QAPairWhereUniqueInput
    create: XOR<QAPairCreateWithoutTagsInput, QAPairUncheckedCreateWithoutTagsInput>
  }

  export type PracticeExamCreateWithoutTagsInput = {
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    topics?: TopicCreateNestedManyWithoutPracticeExamInput
    subjects?: SubjectCreateNestedManyWithoutPracticeExamInput
    questions?: QAPairCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamUncheckedCreateWithoutTagsInput = {
    id?: number
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutPracticeExamInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutPracticeExamInput
    questions?: QAPairUncheckedCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamCreateOrConnectWithoutTagsInput = {
    where: PracticeExamWhereUniqueInput
    create: XOR<PracticeExamCreateWithoutTagsInput, PracticeExamUncheckedCreateWithoutTagsInput>
  }

  export type EquationCreateWithoutTagsInput = {
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesCreateNestedManyWithoutEquationsInput
    topics?: TopicCreateNestedManyWithoutEquationsInput
    subjects?: SubjectCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteCreateNestedManyWithoutEquationsInput
  }

  export type EquationUncheckedCreateWithoutTagsInput = {
    id?: number
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesUncheckedCreateNestedManyWithoutEquationsInput
    topics?: TopicUncheckedCreateNestedManyWithoutEquationsInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutEquationsInput
  }

  export type EquationCreateOrConnectWithoutTagsInput = {
    where: EquationWhereUniqueInput
    create: XOR<EquationCreateWithoutTagsInput, EquationUncheckedCreateWithoutTagsInput>
  }

  export type ToDoCreateWithoutTagsInput = {
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    associatedNotes?: MdxNoteCreateNestedManyWithoutToDoInput
    topics?: TopicCreateNestedManyWithoutToDoInput
    subjects?: SubjectCreateNestedManyWithoutToDoInput
    parent?: ToDoCreateNestedOneWithoutChildInput
    child?: ToDoCreateNestedManyWithoutParentInput
    ToDoList?: ToDoListCreateNestedOneWithoutTasksInput
  }

  export type ToDoUncheckedCreateWithoutTagsInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
    associatedNotes?: MdxNoteUncheckedCreateNestedManyWithoutToDoInput
    topics?: TopicUncheckedCreateNestedManyWithoutToDoInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutToDoInput
    child?: ToDoUncheckedCreateNestedManyWithoutParentInput
  }

  export type ToDoCreateOrConnectWithoutTagsInput = {
    where: ToDoWhereUniqueInput
    create: XOR<ToDoCreateWithoutTagsInput, ToDoUncheckedCreateWithoutTagsInput>
  }

  export type KanbanCreateWithoutTagsInput = {
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    lists?: KanBanListCreateNestedManyWithoutKanbanInput
    subjects?: SubjectCreateNestedManyWithoutKanbanInput
    topics?: TopicCreateNestedManyWithoutKanbanInput
  }

  export type KanbanUncheckedCreateWithoutTagsInput = {
    id?: number
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    lists?: KanBanListUncheckedCreateNestedManyWithoutKanbanInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutKanbanInput
    topics?: TopicUncheckedCreateNestedManyWithoutKanbanInput
  }

  export type KanbanCreateOrConnectWithoutTagsInput = {
    where: KanbanWhereUniqueInput
    create: XOR<KanbanCreateWithoutTagsInput, KanbanUncheckedCreateWithoutTagsInput>
  }

  export type ToDoListCreateWithoutTagsInput = {
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tasks?: ToDoCreateNestedManyWithoutToDoListInput
    topics?: TopicCreateNestedManyWithoutTodoListInput
    subjects?: SubjectCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListUncheckedCreateWithoutTagsInput = {
    id?: number
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tasks?: ToDoUncheckedCreateNestedManyWithoutToDoListInput
    topics?: TopicUncheckedCreateNestedManyWithoutTodoListInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListCreateOrConnectWithoutTagsInput = {
    where: ToDoListWhereUniqueInput
    create: XOR<ToDoListCreateWithoutTagsInput, ToDoListUncheckedCreateWithoutTagsInput>
  }

  export type MdxNoteUpsertWithWhereUniqueWithoutTagsInput = {
    where: MdxNoteWhereUniqueInput
    update: XOR<MdxNoteUpdateWithoutTagsInput, MdxNoteUncheckedUpdateWithoutTagsInput>
    create: XOR<MdxNoteCreateWithoutTagsInput, MdxNoteUncheckedCreateWithoutTagsInput>
  }

  export type MdxNoteUpdateWithWhereUniqueWithoutTagsInput = {
    where: MdxNoteWhereUniqueInput
    data: XOR<MdxNoteUpdateWithoutTagsInput, MdxNoteUncheckedUpdateWithoutTagsInput>
  }

  export type MdxNoteUpdateManyWithWhereWithoutTagsInput = {
    where: MdxNoteScalarWhereInput
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyWithoutTagsInput>
  }

  export type BibEntryUpsertWithWhereUniqueWithoutTagsInput = {
    where: BibEntryWhereUniqueInput
    update: XOR<BibEntryUpdateWithoutTagsInput, BibEntryUncheckedUpdateWithoutTagsInput>
    create: XOR<BibEntryCreateWithoutTagsInput, BibEntryUncheckedCreateWithoutTagsInput>
  }

  export type BibEntryUpdateWithWhereUniqueWithoutTagsInput = {
    where: BibEntryWhereUniqueInput
    data: XOR<BibEntryUpdateWithoutTagsInput, BibEntryUncheckedUpdateWithoutTagsInput>
  }

  export type BibEntryUpdateManyWithWhereWithoutTagsInput = {
    where: BibEntryScalarWhereInput
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyWithoutTagsInput>
  }

  export type IpynbUpsertWithWhereUniqueWithoutTagsInput = {
    where: IpynbWhereUniqueInput
    update: XOR<IpynbUpdateWithoutTagsInput, IpynbUncheckedUpdateWithoutTagsInput>
    create: XOR<IpynbCreateWithoutTagsInput, IpynbUncheckedCreateWithoutTagsInput>
  }

  export type IpynbUpdateWithWhereUniqueWithoutTagsInput = {
    where: IpynbWhereUniqueInput
    data: XOR<IpynbUpdateWithoutTagsInput, IpynbUncheckedUpdateWithoutTagsInput>
  }

  export type IpynbUpdateManyWithWhereWithoutTagsInput = {
    where: IpynbScalarWhereInput
    data: XOR<IpynbUpdateManyMutationInput, IpynbUncheckedUpdateManyWithoutTagsInput>
  }

  export type QAPairUpsertWithWhereUniqueWithoutTagsInput = {
    where: QAPairWhereUniqueInput
    update: XOR<QAPairUpdateWithoutTagsInput, QAPairUncheckedUpdateWithoutTagsInput>
    create: XOR<QAPairCreateWithoutTagsInput, QAPairUncheckedCreateWithoutTagsInput>
  }

  export type QAPairUpdateWithWhereUniqueWithoutTagsInput = {
    where: QAPairWhereUniqueInput
    data: XOR<QAPairUpdateWithoutTagsInput, QAPairUncheckedUpdateWithoutTagsInput>
  }

  export type QAPairUpdateManyWithWhereWithoutTagsInput = {
    where: QAPairScalarWhereInput
    data: XOR<QAPairUpdateManyMutationInput, QAPairUncheckedUpdateManyWithoutTagsInput>
  }

  export type PracticeExamUpsertWithWhereUniqueWithoutTagsInput = {
    where: PracticeExamWhereUniqueInput
    update: XOR<PracticeExamUpdateWithoutTagsInput, PracticeExamUncheckedUpdateWithoutTagsInput>
    create: XOR<PracticeExamCreateWithoutTagsInput, PracticeExamUncheckedCreateWithoutTagsInput>
  }

  export type PracticeExamUpdateWithWhereUniqueWithoutTagsInput = {
    where: PracticeExamWhereUniqueInput
    data: XOR<PracticeExamUpdateWithoutTagsInput, PracticeExamUncheckedUpdateWithoutTagsInput>
  }

  export type PracticeExamUpdateManyWithWhereWithoutTagsInput = {
    where: PracticeExamScalarWhereInput
    data: XOR<PracticeExamUpdateManyMutationInput, PracticeExamUncheckedUpdateManyWithoutTagsInput>
  }

  export type EquationUpsertWithWhereUniqueWithoutTagsInput = {
    where: EquationWhereUniqueInput
    update: XOR<EquationUpdateWithoutTagsInput, EquationUncheckedUpdateWithoutTagsInput>
    create: XOR<EquationCreateWithoutTagsInput, EquationUncheckedCreateWithoutTagsInput>
  }

  export type EquationUpdateWithWhereUniqueWithoutTagsInput = {
    where: EquationWhereUniqueInput
    data: XOR<EquationUpdateWithoutTagsInput, EquationUncheckedUpdateWithoutTagsInput>
  }

  export type EquationUpdateManyWithWhereWithoutTagsInput = {
    where: EquationScalarWhereInput
    data: XOR<EquationUpdateManyMutationInput, EquationUncheckedUpdateManyWithoutTagsInput>
  }

  export type ToDoUpsertWithWhereUniqueWithoutTagsInput = {
    where: ToDoWhereUniqueInput
    update: XOR<ToDoUpdateWithoutTagsInput, ToDoUncheckedUpdateWithoutTagsInput>
    create: XOR<ToDoCreateWithoutTagsInput, ToDoUncheckedCreateWithoutTagsInput>
  }

  export type ToDoUpdateWithWhereUniqueWithoutTagsInput = {
    where: ToDoWhereUniqueInput
    data: XOR<ToDoUpdateWithoutTagsInput, ToDoUncheckedUpdateWithoutTagsInput>
  }

  export type ToDoUpdateManyWithWhereWithoutTagsInput = {
    where: ToDoScalarWhereInput
    data: XOR<ToDoUpdateManyMutationInput, ToDoUncheckedUpdateManyWithoutTagsInput>
  }

  export type KanbanUpsertWithoutTagsInput = {
    update: XOR<KanbanUpdateWithoutTagsInput, KanbanUncheckedUpdateWithoutTagsInput>
    create: XOR<KanbanCreateWithoutTagsInput, KanbanUncheckedCreateWithoutTagsInput>
    where?: KanbanWhereInput
  }

  export type KanbanUpdateToOneWithWhereWithoutTagsInput = {
    where?: KanbanWhereInput
    data: XOR<KanbanUpdateWithoutTagsInput, KanbanUncheckedUpdateWithoutTagsInput>
  }

  export type KanbanUpdateWithoutTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: KanBanListUpdateManyWithoutKanbanNestedInput
    subjects?: SubjectUpdateManyWithoutKanbanNestedInput
    topics?: TopicUpdateManyWithoutKanbanNestedInput
  }

  export type KanbanUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: KanBanListUncheckedUpdateManyWithoutKanbanNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutKanbanNestedInput
    topics?: TopicUncheckedUpdateManyWithoutKanbanNestedInput
  }

  export type ToDoListUpsertWithWhereUniqueWithoutTagsInput = {
    where: ToDoListWhereUniqueInput
    update: XOR<ToDoListUpdateWithoutTagsInput, ToDoListUncheckedUpdateWithoutTagsInput>
    create: XOR<ToDoListCreateWithoutTagsInput, ToDoListUncheckedCreateWithoutTagsInput>
  }

  export type ToDoListUpdateWithWhereUniqueWithoutTagsInput = {
    where: ToDoListWhereUniqueInput
    data: XOR<ToDoListUpdateWithoutTagsInput, ToDoListUncheckedUpdateWithoutTagsInput>
  }

  export type ToDoListUpdateManyWithWhereWithoutTagsInput = {
    where: ToDoListScalarWhereInput
    data: XOR<ToDoListUpdateManyMutationInput, ToDoListUncheckedUpdateManyWithoutTagsInput>
  }

  export type BibEntryCreateWithoutReadingListInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    Bib?: BibCreateNestedOneWithoutEntriesInput
    citationGroups?: CitationsGroupCreateNestedManyWithoutEntriesInput
    tags?: TagCreateNestedManyWithoutBibEntriesInput
    topics?: TopicCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutCitationsInput
  }

  export type BibEntryUncheckedCreateWithoutReadingListInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput
    tags?: TagUncheckedCreateNestedManyWithoutBibEntriesInput
    topics?: TopicUncheckedCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutCitationsInput
  }

  export type BibEntryCreateOrConnectWithoutReadingListInput = {
    where: BibEntryWhereUniqueInput
    create: XOR<BibEntryCreateWithoutReadingListInput, BibEntryUncheckedCreateWithoutReadingListInput>
  }

  export type MdxNoteCreateWithoutReadingListInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateWithoutReadingListInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteCreateOrConnectWithoutReadingListInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutReadingListInput, MdxNoteUncheckedCreateWithoutReadingListInput>
  }

  export type IpynbCreateWithoutReadingListInput = {
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryCreateNestedManyWithoutIpynbNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutIpynbInput
  }

  export type IpynbUncheckedCreateWithoutReadingListInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialKey?: string | null
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicUncheckedCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbCreateOrConnectWithoutReadingListInput = {
    where: IpynbWhereUniqueInput
    create: XOR<IpynbCreateWithoutReadingListInput, IpynbUncheckedCreateWithoutReadingListInput>
  }

  export type BibEntryUpsertWithWhereUniqueWithoutReadingListInput = {
    where: BibEntryWhereUniqueInput
    update: XOR<BibEntryUpdateWithoutReadingListInput, BibEntryUncheckedUpdateWithoutReadingListInput>
    create: XOR<BibEntryCreateWithoutReadingListInput, BibEntryUncheckedCreateWithoutReadingListInput>
  }

  export type BibEntryUpdateWithWhereUniqueWithoutReadingListInput = {
    where: BibEntryWhereUniqueInput
    data: XOR<BibEntryUpdateWithoutReadingListInput, BibEntryUncheckedUpdateWithoutReadingListInput>
  }

  export type BibEntryUpdateManyWithWhereWithoutReadingListInput = {
    where: BibEntryScalarWhereInput
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyWithoutReadingListInput>
  }

  export type MdxNoteUpsertWithWhereUniqueWithoutReadingListInput = {
    where: MdxNoteWhereUniqueInput
    update: XOR<MdxNoteUpdateWithoutReadingListInput, MdxNoteUncheckedUpdateWithoutReadingListInput>
    create: XOR<MdxNoteCreateWithoutReadingListInput, MdxNoteUncheckedCreateWithoutReadingListInput>
  }

  export type MdxNoteUpdateWithWhereUniqueWithoutReadingListInput = {
    where: MdxNoteWhereUniqueInput
    data: XOR<MdxNoteUpdateWithoutReadingListInput, MdxNoteUncheckedUpdateWithoutReadingListInput>
  }

  export type MdxNoteUpdateManyWithWhereWithoutReadingListInput = {
    where: MdxNoteScalarWhereInput
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyWithoutReadingListInput>
  }

  export type IpynbUpsertWithWhereUniqueWithoutReadingListInput = {
    where: IpynbWhereUniqueInput
    update: XOR<IpynbUpdateWithoutReadingListInput, IpynbUncheckedUpdateWithoutReadingListInput>
    create: XOR<IpynbCreateWithoutReadingListInput, IpynbUncheckedCreateWithoutReadingListInput>
  }

  export type IpynbUpdateWithWhereUniqueWithoutReadingListInput = {
    where: IpynbWhereUniqueInput
    data: XOR<IpynbUpdateWithoutReadingListInput, IpynbUncheckedUpdateWithoutReadingListInput>
  }

  export type IpynbUpdateManyWithWhereWithoutReadingListInput = {
    where: IpynbScalarWhereInput
    data: XOR<IpynbUpdateManyMutationInput, IpynbUncheckedUpdateManyWithoutReadingListInput>
  }

  export type BibCreateWithoutEntriesInput = {
    id?: number
    filename: string
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type BibUncheckedCreateWithoutEntriesInput = {
    id?: number
    filename: string
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type BibCreateOrConnectWithoutEntriesInput = {
    where: BibWhereUniqueInput
    create: XOR<BibCreateWithoutEntriesInput, BibUncheckedCreateWithoutEntriesInput>
  }

  export type CitationsGroupCreateWithoutEntriesInput = {
    name: string
    description?: string | null
  }

  export type CitationsGroupUncheckedCreateWithoutEntriesInput = {
    name: string
    description?: string | null
  }

  export type CitationsGroupCreateOrConnectWithoutEntriesInput = {
    where: CitationsGroupWhereUniqueInput
    create: XOR<CitationsGroupCreateWithoutEntriesInput, CitationsGroupUncheckedCreateWithoutEntriesInput>
  }

  export type TagCreateWithoutBibEntriesInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutBibEntriesInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutBibEntriesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutBibEntriesInput, TagUncheckedCreateWithoutBibEntriesInput>
  }

  export type TopicCreateWithoutBibEntriesInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutBibEntriesInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutBibEntriesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutBibEntriesInput, TopicUncheckedCreateWithoutBibEntriesInput>
  }

  export type SubjectCreateWithoutBibEntriesInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutBibEntriesInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutBibEntriesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutBibEntriesInput, SubjectUncheckedCreateWithoutBibEntriesInput>
  }

  export type MdxNoteCreateWithoutCitationsInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateWithoutCitationsInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteCreateOrConnectWithoutCitationsInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutCitationsInput, MdxNoteUncheckedCreateWithoutCitationsInput>
  }

  export type IpynbCreateWithoutCitationsInput = {
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectCreateNestedManyWithoutIpynbNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutIpynbInput
    readingList?: ReadingListCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbUncheckedCreateWithoutCitationsInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialKey?: string | null
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicUncheckedCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutIpynbNotesInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbCreateOrConnectWithoutCitationsInput = {
    where: IpynbWhereUniqueInput
    create: XOR<IpynbCreateWithoutCitationsInput, IpynbUncheckedCreateWithoutCitationsInput>
  }

  export type ReadingListCreateWithoutBibEntriesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
    mdxNotes?: MdxNoteCreateNestedManyWithoutReadingListInput
    ipynbNotes?: IpynbCreateNestedManyWithoutReadingListInput
  }

  export type ReadingListUncheckedCreateWithoutBibEntriesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
    mdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutReadingListInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutReadingListInput
  }

  export type ReadingListCreateOrConnectWithoutBibEntriesInput = {
    where: ReadingListWhereUniqueInput
    create: XOR<ReadingListCreateWithoutBibEntriesInput, ReadingListUncheckedCreateWithoutBibEntriesInput>
  }

  export type BibUpsertWithoutEntriesInput = {
    update: XOR<BibUpdateWithoutEntriesInput, BibUncheckedUpdateWithoutEntriesInput>
    create: XOR<BibCreateWithoutEntriesInput, BibUncheckedCreateWithoutEntriesInput>
    where?: BibWhereInput
  }

  export type BibUpdateToOneWithWhereWithoutEntriesInput = {
    where?: BibWhereInput
    data: XOR<BibUpdateWithoutEntriesInput, BibUncheckedUpdateWithoutEntriesInput>
  }

  export type BibUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationsGroupUpsertWithWhereUniqueWithoutEntriesInput = {
    where: CitationsGroupWhereUniqueInput
    update: XOR<CitationsGroupUpdateWithoutEntriesInput, CitationsGroupUncheckedUpdateWithoutEntriesInput>
    create: XOR<CitationsGroupCreateWithoutEntriesInput, CitationsGroupUncheckedCreateWithoutEntriesInput>
  }

  export type CitationsGroupUpdateWithWhereUniqueWithoutEntriesInput = {
    where: CitationsGroupWhereUniqueInput
    data: XOR<CitationsGroupUpdateWithoutEntriesInput, CitationsGroupUncheckedUpdateWithoutEntriesInput>
  }

  export type CitationsGroupUpdateManyWithWhereWithoutEntriesInput = {
    where: CitationsGroupScalarWhereInput
    data: XOR<CitationsGroupUpdateManyMutationInput, CitationsGroupUncheckedUpdateManyWithoutEntriesInput>
  }

  export type CitationsGroupScalarWhereInput = {
    AND?: CitationsGroupScalarWhereInput | CitationsGroupScalarWhereInput[]
    OR?: CitationsGroupScalarWhereInput[]
    NOT?: CitationsGroupScalarWhereInput | CitationsGroupScalarWhereInput[]
    name?: StringFilter<"CitationsGroup"> | string
    description?: StringNullableFilter<"CitationsGroup"> | string | null
  }

  export type TagUpsertWithWhereUniqueWithoutBibEntriesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutBibEntriesInput, TagUncheckedUpdateWithoutBibEntriesInput>
    create: XOR<TagCreateWithoutBibEntriesInput, TagUncheckedCreateWithoutBibEntriesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutBibEntriesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutBibEntriesInput, TagUncheckedUpdateWithoutBibEntriesInput>
  }

  export type TagUpdateManyWithWhereWithoutBibEntriesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutBibEntriesInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    value?: StringFilter<"Tag"> | string
    kanbanId?: IntNullableFilter<"Tag"> | number | null
  }

  export type TopicUpsertWithWhereUniqueWithoutBibEntriesInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutBibEntriesInput, TopicUncheckedUpdateWithoutBibEntriesInput>
    create: XOR<TopicCreateWithoutBibEntriesInput, TopicUncheckedCreateWithoutBibEntriesInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutBibEntriesInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutBibEntriesInput, TopicUncheckedUpdateWithoutBibEntriesInput>
  }

  export type TopicUpdateManyWithWhereWithoutBibEntriesInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutBibEntriesInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    value?: StringFilter<"Topic"> | string
    kanbanId?: IntNullableFilter<"Topic"> | number | null
  }

  export type SubjectUpsertWithWhereUniqueWithoutBibEntriesInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutBibEntriesInput, SubjectUncheckedUpdateWithoutBibEntriesInput>
    create: XOR<SubjectCreateWithoutBibEntriesInput, SubjectUncheckedCreateWithoutBibEntriesInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutBibEntriesInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutBibEntriesInput, SubjectUncheckedUpdateWithoutBibEntriesInput>
  }

  export type SubjectUpdateManyWithWhereWithoutBibEntriesInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutBibEntriesInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    value?: StringFilter<"Subject"> | string
    kanbanId?: IntNullableFilter<"Subject"> | number | null
  }

  export type MdxNoteUpsertWithWhereUniqueWithoutCitationsInput = {
    where: MdxNoteWhereUniqueInput
    update: XOR<MdxNoteUpdateWithoutCitationsInput, MdxNoteUncheckedUpdateWithoutCitationsInput>
    create: XOR<MdxNoteCreateWithoutCitationsInput, MdxNoteUncheckedCreateWithoutCitationsInput>
  }

  export type MdxNoteUpdateWithWhereUniqueWithoutCitationsInput = {
    where: MdxNoteWhereUniqueInput
    data: XOR<MdxNoteUpdateWithoutCitationsInput, MdxNoteUncheckedUpdateWithoutCitationsInput>
  }

  export type MdxNoteUpdateManyWithWhereWithoutCitationsInput = {
    where: MdxNoteScalarWhereInput
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyWithoutCitationsInput>
  }

  export type IpynbUpsertWithWhereUniqueWithoutCitationsInput = {
    where: IpynbWhereUniqueInput
    update: XOR<IpynbUpdateWithoutCitationsInput, IpynbUncheckedUpdateWithoutCitationsInput>
    create: XOR<IpynbCreateWithoutCitationsInput, IpynbUncheckedCreateWithoutCitationsInput>
  }

  export type IpynbUpdateWithWhereUniqueWithoutCitationsInput = {
    where: IpynbWhereUniqueInput
    data: XOR<IpynbUpdateWithoutCitationsInput, IpynbUncheckedUpdateWithoutCitationsInput>
  }

  export type IpynbUpdateManyWithWhereWithoutCitationsInput = {
    where: IpynbScalarWhereInput
    data: XOR<IpynbUpdateManyMutationInput, IpynbUncheckedUpdateManyWithoutCitationsInput>
  }

  export type ReadingListUpsertWithWhereUniqueWithoutBibEntriesInput = {
    where: ReadingListWhereUniqueInput
    update: XOR<ReadingListUpdateWithoutBibEntriesInput, ReadingListUncheckedUpdateWithoutBibEntriesInput>
    create: XOR<ReadingListCreateWithoutBibEntriesInput, ReadingListUncheckedCreateWithoutBibEntriesInput>
  }

  export type ReadingListUpdateWithWhereUniqueWithoutBibEntriesInput = {
    where: ReadingListWhereUniqueInput
    data: XOR<ReadingListUpdateWithoutBibEntriesInput, ReadingListUncheckedUpdateWithoutBibEntriesInput>
  }

  export type ReadingListUpdateManyWithWhereWithoutBibEntriesInput = {
    where: ReadingListScalarWhereInput
    data: XOR<ReadingListUpdateManyMutationInput, ReadingListUncheckedUpdateManyWithoutBibEntriesInput>
  }

  export type ReadingListScalarWhereInput = {
    AND?: ReadingListScalarWhereInput | ReadingListScalarWhereInput[]
    OR?: ReadingListScalarWhereInput[]
    NOT?: ReadingListScalarWhereInput | ReadingListScalarWhereInput[]
    name?: StringFilter<"ReadingList"> | string
    description?: StringNullableFilter<"ReadingList"> | string | null
    createdAt?: DateTimeFilter<"ReadingList"> | Date | string
    lastUpdate?: DateTimeFilter<"ReadingList"> | Date | string
  }

  export type BibEntryCreateWithoutCitationGroupsInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    Bib?: BibCreateNestedOneWithoutEntriesInput
    tags?: TagCreateNestedManyWithoutBibEntriesInput
    topics?: TopicCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUncheckedCreateWithoutCitationGroupsInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutBibEntriesInput
    topics?: TopicUncheckedCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryCreateOrConnectWithoutCitationGroupsInput = {
    where: BibEntryWhereUniqueInput
    create: XOR<BibEntryCreateWithoutCitationGroupsInput, BibEntryUncheckedCreateWithoutCitationGroupsInput>
  }

  export type BibEntryUpsertWithWhereUniqueWithoutCitationGroupsInput = {
    where: BibEntryWhereUniqueInput
    update: XOR<BibEntryUpdateWithoutCitationGroupsInput, BibEntryUncheckedUpdateWithoutCitationGroupsInput>
    create: XOR<BibEntryCreateWithoutCitationGroupsInput, BibEntryUncheckedCreateWithoutCitationGroupsInput>
  }

  export type BibEntryUpdateWithWhereUniqueWithoutCitationGroupsInput = {
    where: BibEntryWhereUniqueInput
    data: XOR<BibEntryUpdateWithoutCitationGroupsInput, BibEntryUncheckedUpdateWithoutCitationGroupsInput>
  }

  export type BibEntryUpdateManyWithWhereWithoutCitationGroupsInput = {
    where: BibEntryScalarWhereInput
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyWithoutCitationGroupsInput>
  }

  export type BibEntryCreateWithoutBibInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupCreateNestedManyWithoutEntriesInput
    tags?: TagCreateNestedManyWithoutBibEntriesInput
    topics?: TopicCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUncheckedCreateWithoutBibInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput
    tags?: TagUncheckedCreateNestedManyWithoutBibEntriesInput
    topics?: TopicUncheckedCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutCitationsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryCreateOrConnectWithoutBibInput = {
    where: BibEntryWhereUniqueInput
    create: XOR<BibEntryCreateWithoutBibInput, BibEntryUncheckedCreateWithoutBibInput>
  }

  export type BibEntryCreateManyBibInputEnvelope = {
    data: BibEntryCreateManyBibInput | BibEntryCreateManyBibInput[]
    skipDuplicates?: boolean
  }

  export type BibEntryUpsertWithWhereUniqueWithoutBibInput = {
    where: BibEntryWhereUniqueInput
    update: XOR<BibEntryUpdateWithoutBibInput, BibEntryUncheckedUpdateWithoutBibInput>
    create: XOR<BibEntryCreateWithoutBibInput, BibEntryUncheckedCreateWithoutBibInput>
  }

  export type BibEntryUpdateWithWhereUniqueWithoutBibInput = {
    where: BibEntryWhereUniqueInput
    data: XOR<BibEntryUpdateWithoutBibInput, BibEntryUncheckedUpdateWithoutBibInput>
  }

  export type BibEntryUpdateManyWithWhereWithoutBibInput = {
    where: BibEntryScalarWhereInput
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyWithoutBibInput>
  }

  export type EquationCreateWithoutRelatedValuesInput = {
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    tags?: TagCreateNestedManyWithoutEquationsInput
    topics?: TopicCreateNestedManyWithoutEquationsInput
    subjects?: SubjectCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteCreateNestedManyWithoutEquationsInput
  }

  export type EquationUncheckedCreateWithoutRelatedValuesInput = {
    id?: number
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutEquationsInput
    topics?: TopicUncheckedCreateNestedManyWithoutEquationsInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutEquationsInput
    mdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutEquationsInput
  }

  export type EquationCreateOrConnectWithoutRelatedValuesInput = {
    where: EquationWhereUniqueInput
    create: XOR<EquationCreateWithoutRelatedValuesInput, EquationUncheckedCreateWithoutRelatedValuesInput>
  }

  export type EquationUpsertWithWhereUniqueWithoutRelatedValuesInput = {
    where: EquationWhereUniqueInput
    update: XOR<EquationUpdateWithoutRelatedValuesInput, EquationUncheckedUpdateWithoutRelatedValuesInput>
    create: XOR<EquationCreateWithoutRelatedValuesInput, EquationUncheckedCreateWithoutRelatedValuesInput>
  }

  export type EquationUpdateWithWhereUniqueWithoutRelatedValuesInput = {
    where: EquationWhereUniqueInput
    data: XOR<EquationUpdateWithoutRelatedValuesInput, EquationUncheckedUpdateWithoutRelatedValuesInput>
  }

  export type EquationUpdateManyWithWhereWithoutRelatedValuesInput = {
    where: EquationScalarWhereInput
    data: XOR<EquationUpdateManyMutationInput, EquationUncheckedUpdateManyWithoutRelatedValuesInput>
  }

  export type RelatedValuesCreateWithoutEquationsInput = {
    input: JsonNullValueInput | InputJsonValue
    output: number
    equationId?: RelatedValuesCreateequationIdInput | number[]
  }

  export type RelatedValuesUncheckedCreateWithoutEquationsInput = {
    id?: number
    input: JsonNullValueInput | InputJsonValue
    output: number
    equationId?: RelatedValuesCreateequationIdInput | number[]
  }

  export type RelatedValuesCreateOrConnectWithoutEquationsInput = {
    where: RelatedValuesWhereUniqueInput
    create: XOR<RelatedValuesCreateWithoutEquationsInput, RelatedValuesUncheckedCreateWithoutEquationsInput>
  }

  export type TagCreateWithoutEquationsInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutEquationsInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutEquationsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutEquationsInput, TagUncheckedCreateWithoutEquationsInput>
  }

  export type TopicCreateWithoutEquationsInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutEquationsInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutEquationsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutEquationsInput, TopicUncheckedCreateWithoutEquationsInput>
  }

  export type SubjectCreateWithoutEquationsInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutEquationsInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutEquationsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutEquationsInput, SubjectUncheckedCreateWithoutEquationsInput>
  }

  export type MdxNoteCreateWithoutEquationsInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateWithoutEquationsInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteCreateOrConnectWithoutEquationsInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutEquationsInput, MdxNoteUncheckedCreateWithoutEquationsInput>
  }

  export type RelatedValuesUpsertWithWhereUniqueWithoutEquationsInput = {
    where: RelatedValuesWhereUniqueInput
    update: XOR<RelatedValuesUpdateWithoutEquationsInput, RelatedValuesUncheckedUpdateWithoutEquationsInput>
    create: XOR<RelatedValuesCreateWithoutEquationsInput, RelatedValuesUncheckedCreateWithoutEquationsInput>
  }

  export type RelatedValuesUpdateWithWhereUniqueWithoutEquationsInput = {
    where: RelatedValuesWhereUniqueInput
    data: XOR<RelatedValuesUpdateWithoutEquationsInput, RelatedValuesUncheckedUpdateWithoutEquationsInput>
  }

  export type RelatedValuesUpdateManyWithWhereWithoutEquationsInput = {
    where: RelatedValuesScalarWhereInput
    data: XOR<RelatedValuesUpdateManyMutationInput, RelatedValuesUncheckedUpdateManyWithoutEquationsInput>
  }

  export type RelatedValuesScalarWhereInput = {
    AND?: RelatedValuesScalarWhereInput | RelatedValuesScalarWhereInput[]
    OR?: RelatedValuesScalarWhereInput[]
    NOT?: RelatedValuesScalarWhereInput | RelatedValuesScalarWhereInput[]
    id?: IntFilter<"RelatedValues"> | number
    input?: JsonFilter<"RelatedValues">
    output?: FloatFilter<"RelatedValues"> | number
    equationId?: IntNullableListFilter<"RelatedValues">
  }

  export type TagUpsertWithWhereUniqueWithoutEquationsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutEquationsInput, TagUncheckedUpdateWithoutEquationsInput>
    create: XOR<TagCreateWithoutEquationsInput, TagUncheckedCreateWithoutEquationsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutEquationsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutEquationsInput, TagUncheckedUpdateWithoutEquationsInput>
  }

  export type TagUpdateManyWithWhereWithoutEquationsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutEquationsInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutEquationsInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutEquationsInput, TopicUncheckedUpdateWithoutEquationsInput>
    create: XOR<TopicCreateWithoutEquationsInput, TopicUncheckedCreateWithoutEquationsInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutEquationsInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutEquationsInput, TopicUncheckedUpdateWithoutEquationsInput>
  }

  export type TopicUpdateManyWithWhereWithoutEquationsInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutEquationsInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutEquationsInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutEquationsInput, SubjectUncheckedUpdateWithoutEquationsInput>
    create: XOR<SubjectCreateWithoutEquationsInput, SubjectUncheckedCreateWithoutEquationsInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutEquationsInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutEquationsInput, SubjectUncheckedUpdateWithoutEquationsInput>
  }

  export type SubjectUpdateManyWithWhereWithoutEquationsInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutEquationsInput>
  }

  export type MdxNoteUpsertWithWhereUniqueWithoutEquationsInput = {
    where: MdxNoteWhereUniqueInput
    update: XOR<MdxNoteUpdateWithoutEquationsInput, MdxNoteUncheckedUpdateWithoutEquationsInput>
    create: XOR<MdxNoteCreateWithoutEquationsInput, MdxNoteUncheckedCreateWithoutEquationsInput>
  }

  export type MdxNoteUpdateWithWhereUniqueWithoutEquationsInput = {
    where: MdxNoteWhereUniqueInput
    data: XOR<MdxNoteUpdateWithoutEquationsInput, MdxNoteUncheckedUpdateWithoutEquationsInput>
  }

  export type MdxNoteUpdateManyWithWhereWithoutEquationsInput = {
    where: MdxNoteScalarWhereInput
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyWithoutEquationsInput>
  }

  export type MdxNoteCreateWithoutDefinitionsInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateWithoutDefinitionsInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteCreateOrConnectWithoutDefinitionsInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutDefinitionsInput, MdxNoteUncheckedCreateWithoutDefinitionsInput>
  }

  export type MdxNoteUpsertWithoutDefinitionsInput = {
    update: XOR<MdxNoteUpdateWithoutDefinitionsInput, MdxNoteUncheckedUpdateWithoutDefinitionsInput>
    create: XOR<MdxNoteCreateWithoutDefinitionsInput, MdxNoteUncheckedCreateWithoutDefinitionsInput>
    where?: MdxNoteWhereInput
  }

  export type MdxNoteUpdateToOneWithWhereWithoutDefinitionsInput = {
    where?: MdxNoteWhereInput
    data: XOR<MdxNoteUpdateWithoutDefinitionsInput, MdxNoteUncheckedUpdateWithoutDefinitionsInput>
  }

  export type MdxNoteUpdateWithoutDefinitionsInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutDefinitionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type TagCreateWithoutQAPairInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutQAPairInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutQAPairInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutQAPairInput, TagUncheckedCreateWithoutQAPairInput>
  }

  export type TopicCreateWithoutQAPairInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutQAPairInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutQAPairInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutQAPairInput, TopicUncheckedCreateWithoutQAPairInput>
  }

  export type SubjectCreateWithoutQaPairInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutQaPairInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutQaPairInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutQaPairInput, SubjectUncheckedCreateWithoutQaPairInput>
  }

  export type PracticeExamCreateWithoutQuestionsInput = {
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    topics?: TopicCreateNestedManyWithoutPracticeExamInput
    tags?: TagCreateNestedManyWithoutPracticeExamInput
    subjects?: SubjectCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamUncheckedCreateWithoutQuestionsInput = {
    id?: number
    correctCount: number
    inCorrectCount: number
    timeLimitInSeconds: number
    timeCompletedInSeconds: number
    date?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutPracticeExamInput
    tags?: TagUncheckedCreateNestedManyWithoutPracticeExamInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutPracticeExamInput
  }

  export type PracticeExamCreateOrConnectWithoutQuestionsInput = {
    where: PracticeExamWhereUniqueInput
    create: XOR<PracticeExamCreateWithoutQuestionsInput, PracticeExamUncheckedCreateWithoutQuestionsInput>
  }

  export type TagUpsertWithWhereUniqueWithoutQAPairInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutQAPairInput, TagUncheckedUpdateWithoutQAPairInput>
    create: XOR<TagCreateWithoutQAPairInput, TagUncheckedCreateWithoutQAPairInput>
  }

  export type TagUpdateWithWhereUniqueWithoutQAPairInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutQAPairInput, TagUncheckedUpdateWithoutQAPairInput>
  }

  export type TagUpdateManyWithWhereWithoutQAPairInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutQAPairInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutQAPairInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutQAPairInput, TopicUncheckedUpdateWithoutQAPairInput>
    create: XOR<TopicCreateWithoutQAPairInput, TopicUncheckedCreateWithoutQAPairInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutQAPairInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutQAPairInput, TopicUncheckedUpdateWithoutQAPairInput>
  }

  export type TopicUpdateManyWithWhereWithoutQAPairInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutQAPairInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutQaPairInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutQaPairInput, SubjectUncheckedUpdateWithoutQaPairInput>
    create: XOR<SubjectCreateWithoutQaPairInput, SubjectUncheckedCreateWithoutQaPairInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutQaPairInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutQaPairInput, SubjectUncheckedUpdateWithoutQaPairInput>
  }

  export type SubjectUpdateManyWithWhereWithoutQaPairInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutQaPairInput>
  }

  export type PracticeExamUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: PracticeExamWhereUniqueInput
    update: XOR<PracticeExamUpdateWithoutQuestionsInput, PracticeExamUncheckedUpdateWithoutQuestionsInput>
    create: XOR<PracticeExamCreateWithoutQuestionsInput, PracticeExamUncheckedCreateWithoutQuestionsInput>
  }

  export type PracticeExamUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: PracticeExamWhereUniqueInput
    data: XOR<PracticeExamUpdateWithoutQuestionsInput, PracticeExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type PracticeExamUpdateManyWithWhereWithoutQuestionsInput = {
    where: PracticeExamScalarWhereInput
    data: XOR<PracticeExamUpdateManyMutationInput, PracticeExamUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type TopicCreateWithoutPracticeExamInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutPracticeExamInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutPracticeExamInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutPracticeExamInput, TopicUncheckedCreateWithoutPracticeExamInput>
  }

  export type TagCreateWithoutPracticeExamInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutPracticeExamInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutPracticeExamInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPracticeExamInput, TagUncheckedCreateWithoutPracticeExamInput>
  }

  export type SubjectCreateWithoutPracticeExamInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutPracticeExamInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutPracticeExamInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutPracticeExamInput, SubjectUncheckedCreateWithoutPracticeExamInput>
  }

  export type QAPairCreateWithoutPracticeExamInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    tags?: TagCreateNestedManyWithoutQAPairInput
    topics?: TopicCreateNestedManyWithoutQAPairInput
    subjects?: SubjectCreateNestedManyWithoutQaPairInput
  }

  export type QAPairUncheckedCreateWithoutPracticeExamInput = {
    id: string
    question: string
    answer: string
    description?: string | null
    secondaryLabel?: string | null
    correctCount?: number
    inCorrectCount?: number
    tags?: TagUncheckedCreateNestedManyWithoutQAPairInput
    topics?: TopicUncheckedCreateNestedManyWithoutQAPairInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutQaPairInput
  }

  export type QAPairCreateOrConnectWithoutPracticeExamInput = {
    where: QAPairWhereUniqueInput
    create: XOR<QAPairCreateWithoutPracticeExamInput, QAPairUncheckedCreateWithoutPracticeExamInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutPracticeExamInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutPracticeExamInput, TopicUncheckedUpdateWithoutPracticeExamInput>
    create: XOR<TopicCreateWithoutPracticeExamInput, TopicUncheckedCreateWithoutPracticeExamInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutPracticeExamInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutPracticeExamInput, TopicUncheckedUpdateWithoutPracticeExamInput>
  }

  export type TopicUpdateManyWithWhereWithoutPracticeExamInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutPracticeExamInput>
  }

  export type TagUpsertWithWhereUniqueWithoutPracticeExamInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutPracticeExamInput, TagUncheckedUpdateWithoutPracticeExamInput>
    create: XOR<TagCreateWithoutPracticeExamInput, TagUncheckedCreateWithoutPracticeExamInput>
  }

  export type TagUpdateWithWhereUniqueWithoutPracticeExamInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutPracticeExamInput, TagUncheckedUpdateWithoutPracticeExamInput>
  }

  export type TagUpdateManyWithWhereWithoutPracticeExamInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutPracticeExamInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutPracticeExamInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutPracticeExamInput, SubjectUncheckedUpdateWithoutPracticeExamInput>
    create: XOR<SubjectCreateWithoutPracticeExamInput, SubjectUncheckedCreateWithoutPracticeExamInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutPracticeExamInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutPracticeExamInput, SubjectUncheckedUpdateWithoutPracticeExamInput>
  }

  export type SubjectUpdateManyWithWhereWithoutPracticeExamInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutPracticeExamInput>
  }

  export type QAPairUpsertWithWhereUniqueWithoutPracticeExamInput = {
    where: QAPairWhereUniqueInput
    update: XOR<QAPairUpdateWithoutPracticeExamInput, QAPairUncheckedUpdateWithoutPracticeExamInput>
    create: XOR<QAPairCreateWithoutPracticeExamInput, QAPairUncheckedCreateWithoutPracticeExamInput>
  }

  export type QAPairUpdateWithWhereUniqueWithoutPracticeExamInput = {
    where: QAPairWhereUniqueInput
    data: XOR<QAPairUpdateWithoutPracticeExamInput, QAPairUncheckedUpdateWithoutPracticeExamInput>
  }

  export type QAPairUpdateManyWithWhereWithoutPracticeExamInput = {
    where: QAPairScalarWhereInput
    data: XOR<QAPairUpdateManyMutationInput, QAPairUncheckedUpdateManyWithoutPracticeExamInput>
  }

  export type MdxNoteCreateWithoutSequentialListInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteUncheckedCreateWithoutSequentialListInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutAssociatedNotesInput
  }

  export type MdxNoteCreateOrConnectWithoutSequentialListInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutSequentialListInput, MdxNoteUncheckedCreateWithoutSequentialListInput>
  }

  export type MdxNoteCreateManySequentialListInputEnvelope = {
    data: MdxNoteCreateManySequentialListInput | MdxNoteCreateManySequentialListInput[]
    skipDuplicates?: boolean
  }

  export type IpynbCreateWithoutSequentialListInput = {
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryCreateNestedManyWithoutIpynbNotesInput
    readingList?: ReadingListCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbUncheckedCreateWithoutSequentialListInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutIpynbNotesInput
    topics?: TopicUncheckedCreateNestedManyWithoutIpynbNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutIpynbNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutIpynbNotesInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutIpynbNotesInput
  }

  export type IpynbCreateOrConnectWithoutSequentialListInput = {
    where: IpynbWhereUniqueInput
    create: XOR<IpynbCreateWithoutSequentialListInput, IpynbUncheckedCreateWithoutSequentialListInput>
  }

  export type IpynbCreateManySequentialListInputEnvelope = {
    data: IpynbCreateManySequentialListInput | IpynbCreateManySequentialListInput[]
    skipDuplicates?: boolean
  }

  export type MdxNoteUpsertWithWhereUniqueWithoutSequentialListInput = {
    where: MdxNoteWhereUniqueInput
    update: XOR<MdxNoteUpdateWithoutSequentialListInput, MdxNoteUncheckedUpdateWithoutSequentialListInput>
    create: XOR<MdxNoteCreateWithoutSequentialListInput, MdxNoteUncheckedCreateWithoutSequentialListInput>
  }

  export type MdxNoteUpdateWithWhereUniqueWithoutSequentialListInput = {
    where: MdxNoteWhereUniqueInput
    data: XOR<MdxNoteUpdateWithoutSequentialListInput, MdxNoteUncheckedUpdateWithoutSequentialListInput>
  }

  export type MdxNoteUpdateManyWithWhereWithoutSequentialListInput = {
    where: MdxNoteScalarWhereInput
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyWithoutSequentialListInput>
  }

  export type IpynbUpsertWithWhereUniqueWithoutSequentialListInput = {
    where: IpynbWhereUniqueInput
    update: XOR<IpynbUpdateWithoutSequentialListInput, IpynbUncheckedUpdateWithoutSequentialListInput>
    create: XOR<IpynbCreateWithoutSequentialListInput, IpynbUncheckedCreateWithoutSequentialListInput>
  }

  export type IpynbUpdateWithWhereUniqueWithoutSequentialListInput = {
    where: IpynbWhereUniqueInput
    data: XOR<IpynbUpdateWithoutSequentialListInput, IpynbUncheckedUpdateWithoutSequentialListInput>
  }

  export type IpynbUpdateManyWithWhereWithoutSequentialListInput = {
    where: IpynbScalarWhereInput
    data: XOR<IpynbUpdateManyMutationInput, IpynbUncheckedUpdateManyWithoutSequentialListInput>
  }

  export type TopicCreateWithoutMdxNotesInput = {
    value: string
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutMdxNotesInput = {
    value: string
    kanbanId?: number | null
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutMdxNotesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutMdxNotesInput, TopicUncheckedCreateWithoutMdxNotesInput>
  }

  export type SubjectCreateWithoutMdxNotesInput = {
    value: string
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutMdxNotesInput = {
    value: string
    kanbanId?: number | null
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutMdxNotesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutMdxNotesInput, SubjectUncheckedCreateWithoutMdxNotesInput>
  }

  export type TagCreateWithoutMdxNotesInput = {
    value: string
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutMdxNotesInput = {
    value: string
    kanbanId?: number | null
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutMdxNotesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutMdxNotesInput, TagUncheckedCreateWithoutMdxNotesInput>
  }

  export type BibEntryCreateWithoutMdxNotesInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    Bib?: BibCreateNestedOneWithoutEntriesInput
    citationGroups?: CitationsGroupCreateNestedManyWithoutEntriesInput
    tags?: TagCreateNestedManyWithoutBibEntriesInput
    topics?: TopicCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectCreateNestedManyWithoutBibEntriesInput
    ipynbNotes?: IpynbCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUncheckedCreateWithoutMdxNotesInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput
    tags?: TagUncheckedCreateNestedManyWithoutBibEntriesInput
    topics?: TopicUncheckedCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBibEntriesInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryCreateOrConnectWithoutMdxNotesInput = {
    where: BibEntryWhereUniqueInput
    create: XOR<BibEntryCreateWithoutMdxNotesInput, BibEntryUncheckedCreateWithoutMdxNotesInput>
  }

  export type SequentialNoteListCreateWithoutMdxNoteInput = {
    sequentialKey: string
    Ipynb?: IpynbCreateNestedManyWithoutSequentialListInput
  }

  export type SequentialNoteListUncheckedCreateWithoutMdxNoteInput = {
    sequentialKey: string
    Ipynb?: IpynbUncheckedCreateNestedManyWithoutSequentialListInput
  }

  export type SequentialNoteListCreateOrConnectWithoutMdxNoteInput = {
    where: SequentialNoteListWhereUniqueInput
    create: XOR<SequentialNoteListCreateWithoutMdxNoteInput, SequentialNoteListUncheckedCreateWithoutMdxNoteInput>
  }

  export type ReadingListCreateWithoutMdxNotesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
    bibEntries?: BibEntryCreateNestedManyWithoutReadingListInput
    ipynbNotes?: IpynbCreateNestedManyWithoutReadingListInput
  }

  export type ReadingListUncheckedCreateWithoutMdxNotesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutReadingListInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutReadingListInput
  }

  export type ReadingListCreateOrConnectWithoutMdxNotesInput = {
    where: ReadingListWhereUniqueInput
    create: XOR<ReadingListCreateWithoutMdxNotesInput, ReadingListUncheckedCreateWithoutMdxNotesInput>
  }

  export type EquationCreateWithoutMdxNotesInput = {
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesCreateNestedManyWithoutEquationsInput
    tags?: TagCreateNestedManyWithoutEquationsInput
    topics?: TopicCreateNestedManyWithoutEquationsInput
    subjects?: SubjectCreateNestedManyWithoutEquationsInput
  }

  export type EquationUncheckedCreateWithoutMdxNotesInput = {
    id?: number
    equationId?: string | null
    title: string
    desc?: string | null
    content: string
    asPython?: string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationCreatevariablesInput | string[]
    keywords?: EquationCreatekeywordsInput | string[]
    createdAt?: Date | string
    relatedValues?: RelatedValuesUncheckedCreateNestedManyWithoutEquationsInput
    tags?: TagUncheckedCreateNestedManyWithoutEquationsInput
    topics?: TopicUncheckedCreateNestedManyWithoutEquationsInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutEquationsInput
  }

  export type EquationCreateOrConnectWithoutMdxNotesInput = {
    where: EquationWhereUniqueInput
    create: XOR<EquationCreateWithoutMdxNotesInput, EquationUncheckedCreateWithoutMdxNotesInput>
  }

  export type DefinitionCreateWithoutMdxNoteInput = {
    id: string
    label?: string | null
    content?: string | null
    alphabeticalLabel?: string | null
  }

  export type DefinitionUncheckedCreateWithoutMdxNoteInput = {
    id: string
    label?: string | null
    content?: string | null
    alphabeticalLabel?: string | null
  }

  export type DefinitionCreateOrConnectWithoutMdxNoteInput = {
    where: DefinitionWhereUniqueInput
    create: XOR<DefinitionCreateWithoutMdxNoteInput, DefinitionUncheckedCreateWithoutMdxNoteInput>
  }

  export type DefinitionCreateManyMdxNoteInputEnvelope = {
    data: DefinitionCreateManyMdxNoteInput | DefinitionCreateManyMdxNoteInput[]
    skipDuplicates?: boolean
  }

  export type ToDoCreateWithoutAssociatedNotesInput = {
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    tags?: TagCreateNestedManyWithoutToDoInput
    topics?: TopicCreateNestedManyWithoutToDoInput
    subjects?: SubjectCreateNestedManyWithoutToDoInput
    parent?: ToDoCreateNestedOneWithoutChildInput
    child?: ToDoCreateNestedManyWithoutParentInput
    ToDoList?: ToDoListCreateNestedOneWithoutTasksInput
  }

  export type ToDoUncheckedCreateWithoutAssociatedNotesInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
    tags?: TagUncheckedCreateNestedManyWithoutToDoInput
    topics?: TopicUncheckedCreateNestedManyWithoutToDoInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutToDoInput
    child?: ToDoUncheckedCreateNestedManyWithoutParentInput
  }

  export type ToDoCreateOrConnectWithoutAssociatedNotesInput = {
    where: ToDoWhereUniqueInput
    create: XOR<ToDoCreateWithoutAssociatedNotesInput, ToDoUncheckedCreateWithoutAssociatedNotesInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutMdxNotesInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutMdxNotesInput, TopicUncheckedUpdateWithoutMdxNotesInput>
    create: XOR<TopicCreateWithoutMdxNotesInput, TopicUncheckedCreateWithoutMdxNotesInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutMdxNotesInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutMdxNotesInput, TopicUncheckedUpdateWithoutMdxNotesInput>
  }

  export type TopicUpdateManyWithWhereWithoutMdxNotesInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutMdxNotesInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutMdxNotesInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutMdxNotesInput, SubjectUncheckedUpdateWithoutMdxNotesInput>
    create: XOR<SubjectCreateWithoutMdxNotesInput, SubjectUncheckedCreateWithoutMdxNotesInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutMdxNotesInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutMdxNotesInput, SubjectUncheckedUpdateWithoutMdxNotesInput>
  }

  export type SubjectUpdateManyWithWhereWithoutMdxNotesInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutMdxNotesInput>
  }

  export type TagUpsertWithWhereUniqueWithoutMdxNotesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutMdxNotesInput, TagUncheckedUpdateWithoutMdxNotesInput>
    create: XOR<TagCreateWithoutMdxNotesInput, TagUncheckedCreateWithoutMdxNotesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutMdxNotesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutMdxNotesInput, TagUncheckedUpdateWithoutMdxNotesInput>
  }

  export type TagUpdateManyWithWhereWithoutMdxNotesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutMdxNotesInput>
  }

  export type BibEntryUpsertWithWhereUniqueWithoutMdxNotesInput = {
    where: BibEntryWhereUniqueInput
    update: XOR<BibEntryUpdateWithoutMdxNotesInput, BibEntryUncheckedUpdateWithoutMdxNotesInput>
    create: XOR<BibEntryCreateWithoutMdxNotesInput, BibEntryUncheckedCreateWithoutMdxNotesInput>
  }

  export type BibEntryUpdateWithWhereUniqueWithoutMdxNotesInput = {
    where: BibEntryWhereUniqueInput
    data: XOR<BibEntryUpdateWithoutMdxNotesInput, BibEntryUncheckedUpdateWithoutMdxNotesInput>
  }

  export type BibEntryUpdateManyWithWhereWithoutMdxNotesInput = {
    where: BibEntryScalarWhereInput
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyWithoutMdxNotesInput>
  }

  export type SequentialNoteListUpsertWithoutMdxNoteInput = {
    update: XOR<SequentialNoteListUpdateWithoutMdxNoteInput, SequentialNoteListUncheckedUpdateWithoutMdxNoteInput>
    create: XOR<SequentialNoteListCreateWithoutMdxNoteInput, SequentialNoteListUncheckedCreateWithoutMdxNoteInput>
    where?: SequentialNoteListWhereInput
  }

  export type SequentialNoteListUpdateToOneWithWhereWithoutMdxNoteInput = {
    where?: SequentialNoteListWhereInput
    data: XOR<SequentialNoteListUpdateWithoutMdxNoteInput, SequentialNoteListUncheckedUpdateWithoutMdxNoteInput>
  }

  export type SequentialNoteListUpdateWithoutMdxNoteInput = {
    sequentialKey?: StringFieldUpdateOperationsInput | string
    Ipynb?: IpynbUpdateManyWithoutSequentialListNestedInput
  }

  export type SequentialNoteListUncheckedUpdateWithoutMdxNoteInput = {
    sequentialKey?: StringFieldUpdateOperationsInput | string
    Ipynb?: IpynbUncheckedUpdateManyWithoutSequentialListNestedInput
  }

  export type ReadingListUpsertWithWhereUniqueWithoutMdxNotesInput = {
    where: ReadingListWhereUniqueInput
    update: XOR<ReadingListUpdateWithoutMdxNotesInput, ReadingListUncheckedUpdateWithoutMdxNotesInput>
    create: XOR<ReadingListCreateWithoutMdxNotesInput, ReadingListUncheckedCreateWithoutMdxNotesInput>
  }

  export type ReadingListUpdateWithWhereUniqueWithoutMdxNotesInput = {
    where: ReadingListWhereUniqueInput
    data: XOR<ReadingListUpdateWithoutMdxNotesInput, ReadingListUncheckedUpdateWithoutMdxNotesInput>
  }

  export type ReadingListUpdateManyWithWhereWithoutMdxNotesInput = {
    where: ReadingListScalarWhereInput
    data: XOR<ReadingListUpdateManyMutationInput, ReadingListUncheckedUpdateManyWithoutMdxNotesInput>
  }

  export type EquationUpsertWithWhereUniqueWithoutMdxNotesInput = {
    where: EquationWhereUniqueInput
    update: XOR<EquationUpdateWithoutMdxNotesInput, EquationUncheckedUpdateWithoutMdxNotesInput>
    create: XOR<EquationCreateWithoutMdxNotesInput, EquationUncheckedCreateWithoutMdxNotesInput>
  }

  export type EquationUpdateWithWhereUniqueWithoutMdxNotesInput = {
    where: EquationWhereUniqueInput
    data: XOR<EquationUpdateWithoutMdxNotesInput, EquationUncheckedUpdateWithoutMdxNotesInput>
  }

  export type EquationUpdateManyWithWhereWithoutMdxNotesInput = {
    where: EquationScalarWhereInput
    data: XOR<EquationUpdateManyMutationInput, EquationUncheckedUpdateManyWithoutMdxNotesInput>
  }

  export type DefinitionUpsertWithWhereUniqueWithoutMdxNoteInput = {
    where: DefinitionWhereUniqueInput
    update: XOR<DefinitionUpdateWithoutMdxNoteInput, DefinitionUncheckedUpdateWithoutMdxNoteInput>
    create: XOR<DefinitionCreateWithoutMdxNoteInput, DefinitionUncheckedCreateWithoutMdxNoteInput>
  }

  export type DefinitionUpdateWithWhereUniqueWithoutMdxNoteInput = {
    where: DefinitionWhereUniqueInput
    data: XOR<DefinitionUpdateWithoutMdxNoteInput, DefinitionUncheckedUpdateWithoutMdxNoteInput>
  }

  export type DefinitionUpdateManyWithWhereWithoutMdxNoteInput = {
    where: DefinitionScalarWhereInput
    data: XOR<DefinitionUpdateManyMutationInput, DefinitionUncheckedUpdateManyWithoutMdxNoteInput>
  }

  export type DefinitionScalarWhereInput = {
    AND?: DefinitionScalarWhereInput | DefinitionScalarWhereInput[]
    OR?: DefinitionScalarWhereInput[]
    NOT?: DefinitionScalarWhereInput | DefinitionScalarWhereInput[]
    id?: StringFilter<"Definition"> | string
    label?: StringNullableFilter<"Definition"> | string | null
    content?: StringNullableFilter<"Definition"> | string | null
    alphabeticalLabel?: StringNullableFilter<"Definition"> | string | null
    mdxNoteId?: IntNullableFilter<"Definition"> | number | null
  }

  export type ToDoUpsertWithWhereUniqueWithoutAssociatedNotesInput = {
    where: ToDoWhereUniqueInput
    update: XOR<ToDoUpdateWithoutAssociatedNotesInput, ToDoUncheckedUpdateWithoutAssociatedNotesInput>
    create: XOR<ToDoCreateWithoutAssociatedNotesInput, ToDoUncheckedCreateWithoutAssociatedNotesInput>
  }

  export type ToDoUpdateWithWhereUniqueWithoutAssociatedNotesInput = {
    where: ToDoWhereUniqueInput
    data: XOR<ToDoUpdateWithoutAssociatedNotesInput, ToDoUncheckedUpdateWithoutAssociatedNotesInput>
  }

  export type ToDoUpdateManyWithWhereWithoutAssociatedNotesInput = {
    where: ToDoScalarWhereInput
    data: XOR<ToDoUpdateManyMutationInput, ToDoUncheckedUpdateManyWithoutAssociatedNotesInput>
  }

  export type TagCreateWithoutIpynbNotesInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutIpynbNotesInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutIpynbNotesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutIpynbNotesInput, TagUncheckedCreateWithoutIpynbNotesInput>
  }

  export type TopicCreateWithoutIpynbNotesInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutIpynbNotesInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutIpynbNotesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutIpynbNotesInput, TopicUncheckedCreateWithoutIpynbNotesInput>
  }

  export type SubjectCreateWithoutIpynbNotesInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutIpynbNotesInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutIpynbNotesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutIpynbNotesInput, SubjectUncheckedCreateWithoutIpynbNotesInput>
  }

  export type BibEntryCreateWithoutIpynbNotesInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    Bib?: BibCreateNestedOneWithoutEntriesInput
    citationGroups?: CitationsGroupCreateNestedManyWithoutEntriesInput
    tags?: TagCreateNestedManyWithoutBibEntriesInput
    topics?: TopicCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryUncheckedCreateWithoutIpynbNotesInput = {
    id: string
    BibId?: number | null
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
    citationGroups?: CitationsGroupUncheckedCreateNestedManyWithoutEntriesInput
    tags?: TagUncheckedCreateNestedManyWithoutBibEntriesInput
    topics?: TopicUncheckedCreateNestedManyWithoutBibEntriesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBibEntriesInput
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutCitationsInput
    readingList?: ReadingListUncheckedCreateNestedManyWithoutBibEntriesInput
  }

  export type BibEntryCreateOrConnectWithoutIpynbNotesInput = {
    where: BibEntryWhereUniqueInput
    create: XOR<BibEntryCreateWithoutIpynbNotesInput, BibEntryUncheckedCreateWithoutIpynbNotesInput>
  }

  export type SequentialNoteListCreateWithoutIpynbInput = {
    sequentialKey: string
    MdxNote?: MdxNoteCreateNestedManyWithoutSequentialListInput
  }

  export type SequentialNoteListUncheckedCreateWithoutIpynbInput = {
    sequentialKey: string
    MdxNote?: MdxNoteUncheckedCreateNestedManyWithoutSequentialListInput
  }

  export type SequentialNoteListCreateOrConnectWithoutIpynbInput = {
    where: SequentialNoteListWhereUniqueInput
    create: XOR<SequentialNoteListCreateWithoutIpynbInput, SequentialNoteListUncheckedCreateWithoutIpynbInput>
  }

  export type ReadingListCreateWithoutIpynbNotesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
    bibEntries?: BibEntryCreateNestedManyWithoutReadingListInput
    mdxNotes?: MdxNoteCreateNestedManyWithoutReadingListInput
  }

  export type ReadingListUncheckedCreateWithoutIpynbNotesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    lastUpdate?: Date | string
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutReadingListInput
    mdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutReadingListInput
  }

  export type ReadingListCreateOrConnectWithoutIpynbNotesInput = {
    where: ReadingListWhereUniqueInput
    create: XOR<ReadingListCreateWithoutIpynbNotesInput, ReadingListUncheckedCreateWithoutIpynbNotesInput>
  }

  export type TagUpsertWithWhereUniqueWithoutIpynbNotesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutIpynbNotesInput, TagUncheckedUpdateWithoutIpynbNotesInput>
    create: XOR<TagCreateWithoutIpynbNotesInput, TagUncheckedCreateWithoutIpynbNotesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutIpynbNotesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutIpynbNotesInput, TagUncheckedUpdateWithoutIpynbNotesInput>
  }

  export type TagUpdateManyWithWhereWithoutIpynbNotesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutIpynbNotesInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutIpynbNotesInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutIpynbNotesInput, TopicUncheckedUpdateWithoutIpynbNotesInput>
    create: XOR<TopicCreateWithoutIpynbNotesInput, TopicUncheckedCreateWithoutIpynbNotesInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutIpynbNotesInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutIpynbNotesInput, TopicUncheckedUpdateWithoutIpynbNotesInput>
  }

  export type TopicUpdateManyWithWhereWithoutIpynbNotesInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutIpynbNotesInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutIpynbNotesInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutIpynbNotesInput, SubjectUncheckedUpdateWithoutIpynbNotesInput>
    create: XOR<SubjectCreateWithoutIpynbNotesInput, SubjectUncheckedCreateWithoutIpynbNotesInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutIpynbNotesInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutIpynbNotesInput, SubjectUncheckedUpdateWithoutIpynbNotesInput>
  }

  export type SubjectUpdateManyWithWhereWithoutIpynbNotesInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutIpynbNotesInput>
  }

  export type BibEntryUpsertWithWhereUniqueWithoutIpynbNotesInput = {
    where: BibEntryWhereUniqueInput
    update: XOR<BibEntryUpdateWithoutIpynbNotesInput, BibEntryUncheckedUpdateWithoutIpynbNotesInput>
    create: XOR<BibEntryCreateWithoutIpynbNotesInput, BibEntryUncheckedCreateWithoutIpynbNotesInput>
  }

  export type BibEntryUpdateWithWhereUniqueWithoutIpynbNotesInput = {
    where: BibEntryWhereUniqueInput
    data: XOR<BibEntryUpdateWithoutIpynbNotesInput, BibEntryUncheckedUpdateWithoutIpynbNotesInput>
  }

  export type BibEntryUpdateManyWithWhereWithoutIpynbNotesInput = {
    where: BibEntryScalarWhereInput
    data: XOR<BibEntryUpdateManyMutationInput, BibEntryUncheckedUpdateManyWithoutIpynbNotesInput>
  }

  export type SequentialNoteListUpsertWithoutIpynbInput = {
    update: XOR<SequentialNoteListUpdateWithoutIpynbInput, SequentialNoteListUncheckedUpdateWithoutIpynbInput>
    create: XOR<SequentialNoteListCreateWithoutIpynbInput, SequentialNoteListUncheckedCreateWithoutIpynbInput>
    where?: SequentialNoteListWhereInput
  }

  export type SequentialNoteListUpdateToOneWithWhereWithoutIpynbInput = {
    where?: SequentialNoteListWhereInput
    data: XOR<SequentialNoteListUpdateWithoutIpynbInput, SequentialNoteListUncheckedUpdateWithoutIpynbInput>
  }

  export type SequentialNoteListUpdateWithoutIpynbInput = {
    sequentialKey?: StringFieldUpdateOperationsInput | string
    MdxNote?: MdxNoteUpdateManyWithoutSequentialListNestedInput
  }

  export type SequentialNoteListUncheckedUpdateWithoutIpynbInput = {
    sequentialKey?: StringFieldUpdateOperationsInput | string
    MdxNote?: MdxNoteUncheckedUpdateManyWithoutSequentialListNestedInput
  }

  export type ReadingListUpsertWithWhereUniqueWithoutIpynbNotesInput = {
    where: ReadingListWhereUniqueInput
    update: XOR<ReadingListUpdateWithoutIpynbNotesInput, ReadingListUncheckedUpdateWithoutIpynbNotesInput>
    create: XOR<ReadingListCreateWithoutIpynbNotesInput, ReadingListUncheckedCreateWithoutIpynbNotesInput>
  }

  export type ReadingListUpdateWithWhereUniqueWithoutIpynbNotesInput = {
    where: ReadingListWhereUniqueInput
    data: XOR<ReadingListUpdateWithoutIpynbNotesInput, ReadingListUncheckedUpdateWithoutIpynbNotesInput>
  }

  export type ReadingListUpdateManyWithWhereWithoutIpynbNotesInput = {
    where: ReadingListScalarWhereInput
    data: XOR<ReadingListUpdateManyMutationInput, ReadingListUncheckedUpdateManyWithoutIpynbNotesInput>
  }

  export type ToDoCreateWithoutToDoListInput = {
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    associatedNotes?: MdxNoteCreateNestedManyWithoutToDoInput
    tags?: TagCreateNestedManyWithoutToDoInput
    topics?: TopicCreateNestedManyWithoutToDoInput
    subjects?: SubjectCreateNestedManyWithoutToDoInput
    parent?: ToDoCreateNestedOneWithoutChildInput
    child?: ToDoCreateNestedManyWithoutParentInput
  }

  export type ToDoUncheckedCreateWithoutToDoListInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    associatedNotes?: MdxNoteUncheckedCreateNestedManyWithoutToDoInput
    tags?: TagUncheckedCreateNestedManyWithoutToDoInput
    topics?: TopicUncheckedCreateNestedManyWithoutToDoInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutToDoInput
    child?: ToDoUncheckedCreateNestedManyWithoutParentInput
  }

  export type ToDoCreateOrConnectWithoutToDoListInput = {
    where: ToDoWhereUniqueInput
    create: XOR<ToDoCreateWithoutToDoListInput, ToDoUncheckedCreateWithoutToDoListInput>
  }

  export type ToDoCreateManyToDoListInputEnvelope = {
    data: ToDoCreateManyToDoListInput | ToDoCreateManyToDoListInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutTodoListInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutTodoListInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutTodoListInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTodoListInput, TagUncheckedCreateWithoutTodoListInput>
  }

  export type TopicCreateWithoutTodoListInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutTodoListInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutTodoListInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutTodoListInput, TopicUncheckedCreateWithoutTodoListInput>
  }

  export type SubjectCreateWithoutTodoListInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutTodoListInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutTodoListInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTodoListInput, SubjectUncheckedCreateWithoutTodoListInput>
  }

  export type ToDoUpsertWithWhereUniqueWithoutToDoListInput = {
    where: ToDoWhereUniqueInput
    update: XOR<ToDoUpdateWithoutToDoListInput, ToDoUncheckedUpdateWithoutToDoListInput>
    create: XOR<ToDoCreateWithoutToDoListInput, ToDoUncheckedCreateWithoutToDoListInput>
  }

  export type ToDoUpdateWithWhereUniqueWithoutToDoListInput = {
    where: ToDoWhereUniqueInput
    data: XOR<ToDoUpdateWithoutToDoListInput, ToDoUncheckedUpdateWithoutToDoListInput>
  }

  export type ToDoUpdateManyWithWhereWithoutToDoListInput = {
    where: ToDoScalarWhereInput
    data: XOR<ToDoUpdateManyMutationInput, ToDoUncheckedUpdateManyWithoutToDoListInput>
  }

  export type TagUpsertWithWhereUniqueWithoutTodoListInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutTodoListInput, TagUncheckedUpdateWithoutTodoListInput>
    create: XOR<TagCreateWithoutTodoListInput, TagUncheckedCreateWithoutTodoListInput>
  }

  export type TagUpdateWithWhereUniqueWithoutTodoListInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutTodoListInput, TagUncheckedUpdateWithoutTodoListInput>
  }

  export type TagUpdateManyWithWhereWithoutTodoListInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTodoListInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutTodoListInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutTodoListInput, TopicUncheckedUpdateWithoutTodoListInput>
    create: XOR<TopicCreateWithoutTodoListInput, TopicUncheckedCreateWithoutTodoListInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutTodoListInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutTodoListInput, TopicUncheckedUpdateWithoutTodoListInput>
  }

  export type TopicUpdateManyWithWhereWithoutTodoListInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutTodoListInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutTodoListInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutTodoListInput, SubjectUncheckedUpdateWithoutTodoListInput>
    create: XOR<SubjectCreateWithoutTodoListInput, SubjectUncheckedCreateWithoutTodoListInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutTodoListInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutTodoListInput, SubjectUncheckedUpdateWithoutTodoListInput>
  }

  export type SubjectUpdateManyWithWhereWithoutTodoListInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutTodoListInput>
  }

  export type MdxNoteCreateWithoutToDoInput = {
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectCreateNestedManyWithoutMdxNotesInput
    tags?: TagCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryCreateNestedManyWithoutMdxNotesInput
    sequentialList?: SequentialNoteListCreateNestedOneWithoutMdxNoteInput
    ReadingList?: ReadingListCreateNestedManyWithoutMdxNotesInput
    equations?: EquationCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionCreateNestedManyWithoutMdxNoteInput
  }

  export type MdxNoteUncheckedCreateWithoutToDoInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialKey?: string | null
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutMdxNotesInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutMdxNotesInput
    tags?: TagUncheckedCreateNestedManyWithoutMdxNotesInput
    citations?: BibEntryUncheckedCreateNestedManyWithoutMdxNotesInput
    ReadingList?: ReadingListUncheckedCreateNestedManyWithoutMdxNotesInput
    equations?: EquationUncheckedCreateNestedManyWithoutMdxNotesInput
    definitions?: DefinitionUncheckedCreateNestedManyWithoutMdxNoteInput
  }

  export type MdxNoteCreateOrConnectWithoutToDoInput = {
    where: MdxNoteWhereUniqueInput
    create: XOR<MdxNoteCreateWithoutToDoInput, MdxNoteUncheckedCreateWithoutToDoInput>
  }

  export type TagCreateWithoutToDoInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    Kanban?: KanbanCreateNestedOneWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutToDoInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutToDoInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutToDoInput, TagUncheckedCreateWithoutToDoInput>
  }

  export type TopicCreateWithoutToDoInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    Kanban?: KanbanCreateNestedOneWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutToDoInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutToDoInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutToDoInput, TopicUncheckedCreateWithoutToDoInput>
  }

  export type SubjectCreateWithoutToDoInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    Kanban?: KanbanCreateNestedOneWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutToDoInput = {
    value: string
    kanbanId?: number | null
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutToDoInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutToDoInput, SubjectUncheckedCreateWithoutToDoInput>
  }

  export type ToDoCreateWithoutChildInput = {
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    associatedNotes?: MdxNoteCreateNestedManyWithoutToDoInput
    tags?: TagCreateNestedManyWithoutToDoInput
    topics?: TopicCreateNestedManyWithoutToDoInput
    subjects?: SubjectCreateNestedManyWithoutToDoInput
    parent?: ToDoCreateNestedOneWithoutChildInput
    ToDoList?: ToDoListCreateNestedOneWithoutTasksInput
  }

  export type ToDoUncheckedCreateWithoutChildInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
    associatedNotes?: MdxNoteUncheckedCreateNestedManyWithoutToDoInput
    tags?: TagUncheckedCreateNestedManyWithoutToDoInput
    topics?: TopicUncheckedCreateNestedManyWithoutToDoInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutToDoInput
  }

  export type ToDoCreateOrConnectWithoutChildInput = {
    where: ToDoWhereUniqueInput
    create: XOR<ToDoCreateWithoutChildInput, ToDoUncheckedCreateWithoutChildInput>
  }

  export type ToDoCreateWithoutParentInput = {
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    associatedNotes?: MdxNoteCreateNestedManyWithoutToDoInput
    tags?: TagCreateNestedManyWithoutToDoInput
    topics?: TopicCreateNestedManyWithoutToDoInput
    subjects?: SubjectCreateNestedManyWithoutToDoInput
    child?: ToDoCreateNestedManyWithoutParentInput
    ToDoList?: ToDoListCreateNestedOneWithoutTasksInput
  }

  export type ToDoUncheckedCreateWithoutParentInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
    associatedNotes?: MdxNoteUncheckedCreateNestedManyWithoutToDoInput
    tags?: TagUncheckedCreateNestedManyWithoutToDoInput
    topics?: TopicUncheckedCreateNestedManyWithoutToDoInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutToDoInput
    child?: ToDoUncheckedCreateNestedManyWithoutParentInput
  }

  export type ToDoCreateOrConnectWithoutParentInput = {
    where: ToDoWhereUniqueInput
    create: XOR<ToDoCreateWithoutParentInput, ToDoUncheckedCreateWithoutParentInput>
  }

  export type ToDoCreateManyParentInputEnvelope = {
    data: ToDoCreateManyParentInput | ToDoCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ToDoListCreateWithoutTasksInput = {
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tags?: TagCreateNestedManyWithoutTodoListInput
    topics?: TopicCreateNestedManyWithoutTodoListInput
    subjects?: SubjectCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListUncheckedCreateWithoutTasksInput = {
    id?: number
    label: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutTodoListInput
    topics?: TopicUncheckedCreateNestedManyWithoutTodoListInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutTodoListInput
  }

  export type ToDoListCreateOrConnectWithoutTasksInput = {
    where: ToDoListWhereUniqueInput
    create: XOR<ToDoListCreateWithoutTasksInput, ToDoListUncheckedCreateWithoutTasksInput>
  }

  export type MdxNoteUpsertWithWhereUniqueWithoutToDoInput = {
    where: MdxNoteWhereUniqueInput
    update: XOR<MdxNoteUpdateWithoutToDoInput, MdxNoteUncheckedUpdateWithoutToDoInput>
    create: XOR<MdxNoteCreateWithoutToDoInput, MdxNoteUncheckedCreateWithoutToDoInput>
  }

  export type MdxNoteUpdateWithWhereUniqueWithoutToDoInput = {
    where: MdxNoteWhereUniqueInput
    data: XOR<MdxNoteUpdateWithoutToDoInput, MdxNoteUncheckedUpdateWithoutToDoInput>
  }

  export type MdxNoteUpdateManyWithWhereWithoutToDoInput = {
    where: MdxNoteScalarWhereInput
    data: XOR<MdxNoteUpdateManyMutationInput, MdxNoteUncheckedUpdateManyWithoutToDoInput>
  }

  export type TagUpsertWithWhereUniqueWithoutToDoInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutToDoInput, TagUncheckedUpdateWithoutToDoInput>
    create: XOR<TagCreateWithoutToDoInput, TagUncheckedCreateWithoutToDoInput>
  }

  export type TagUpdateWithWhereUniqueWithoutToDoInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutToDoInput, TagUncheckedUpdateWithoutToDoInput>
  }

  export type TagUpdateManyWithWhereWithoutToDoInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutToDoInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutToDoInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutToDoInput, TopicUncheckedUpdateWithoutToDoInput>
    create: XOR<TopicCreateWithoutToDoInput, TopicUncheckedCreateWithoutToDoInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutToDoInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutToDoInput, TopicUncheckedUpdateWithoutToDoInput>
  }

  export type TopicUpdateManyWithWhereWithoutToDoInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutToDoInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutToDoInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutToDoInput, SubjectUncheckedUpdateWithoutToDoInput>
    create: XOR<SubjectCreateWithoutToDoInput, SubjectUncheckedCreateWithoutToDoInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutToDoInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutToDoInput, SubjectUncheckedUpdateWithoutToDoInput>
  }

  export type SubjectUpdateManyWithWhereWithoutToDoInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutToDoInput>
  }

  export type ToDoUpsertWithoutChildInput = {
    update: XOR<ToDoUpdateWithoutChildInput, ToDoUncheckedUpdateWithoutChildInput>
    create: XOR<ToDoCreateWithoutChildInput, ToDoUncheckedCreateWithoutChildInput>
    where?: ToDoWhereInput
  }

  export type ToDoUpdateToOneWithWhereWithoutChildInput = {
    where?: ToDoWhereInput
    data: XOR<ToDoUpdateWithoutChildInput, ToDoUncheckedUpdateWithoutChildInput>
  }

  export type ToDoUpdateWithoutChildInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    associatedNotes?: MdxNoteUpdateManyWithoutToDoNestedInput
    tags?: TagUpdateManyWithoutToDoNestedInput
    topics?: TopicUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUpdateManyWithoutToDoNestedInput
    parent?: ToDoUpdateOneWithoutChildNestedInput
    ToDoList?: ToDoListUpdateOneWithoutTasksNestedInput
  }

  export type ToDoUncheckedUpdateWithoutChildInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
    associatedNotes?: MdxNoteUncheckedUpdateManyWithoutToDoNestedInput
    tags?: TagUncheckedUpdateManyWithoutToDoNestedInput
    topics?: TopicUncheckedUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutToDoNestedInput
  }

  export type ToDoUpsertWithWhereUniqueWithoutParentInput = {
    where: ToDoWhereUniqueInput
    update: XOR<ToDoUpdateWithoutParentInput, ToDoUncheckedUpdateWithoutParentInput>
    create: XOR<ToDoCreateWithoutParentInput, ToDoUncheckedCreateWithoutParentInput>
  }

  export type ToDoUpdateWithWhereUniqueWithoutParentInput = {
    where: ToDoWhereUniqueInput
    data: XOR<ToDoUpdateWithoutParentInput, ToDoUncheckedUpdateWithoutParentInput>
  }

  export type ToDoUpdateManyWithWhereWithoutParentInput = {
    where: ToDoScalarWhereInput
    data: XOR<ToDoUpdateManyMutationInput, ToDoUncheckedUpdateManyWithoutParentInput>
  }

  export type ToDoListUpsertWithoutTasksInput = {
    update: XOR<ToDoListUpdateWithoutTasksInput, ToDoListUncheckedUpdateWithoutTasksInput>
    create: XOR<ToDoListCreateWithoutTasksInput, ToDoListUncheckedCreateWithoutTasksInput>
    where?: ToDoListWhereInput
  }

  export type ToDoListUpdateToOneWithWhereWithoutTasksInput = {
    where?: ToDoListWhereInput
    data: XOR<ToDoListUpdateWithoutTasksInput, ToDoListUncheckedUpdateWithoutTasksInput>
  }

  export type ToDoListUpdateWithoutTasksInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutTodoListNestedInput
    topics?: TopicUpdateManyWithoutTodoListNestedInput
    subjects?: SubjectUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutTodoListNestedInput
    topics?: TopicUncheckedUpdateManyWithoutTodoListNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutTodoListNestedInput
  }

  export type KanBanListCreateWithoutCardsInput = {
    indexWithinBoard: number
    title?: string | null
    Kanban?: KanbanCreateNestedOneWithoutListsInput
  }

  export type KanBanListUncheckedCreateWithoutCardsInput = {
    id?: number
    indexWithinBoard: number
    title?: string | null
    boardId?: number | null
  }

  export type KanBanListCreateOrConnectWithoutCardsInput = {
    where: KanBanListWhereUniqueInput
    create: XOR<KanBanListCreateWithoutCardsInput, KanBanListUncheckedCreateWithoutCardsInput>
  }

  export type KanBanListUpsertWithoutCardsInput = {
    update: XOR<KanBanListUpdateWithoutCardsInput, KanBanListUncheckedUpdateWithoutCardsInput>
    create: XOR<KanBanListCreateWithoutCardsInput, KanBanListUncheckedCreateWithoutCardsInput>
    where?: KanBanListWhereInput
  }

  export type KanBanListUpdateToOneWithWhereWithoutCardsInput = {
    where?: KanBanListWhereInput
    data: XOR<KanBanListUpdateWithoutCardsInput, KanBanListUncheckedUpdateWithoutCardsInput>
  }

  export type KanBanListUpdateWithoutCardsInput = {
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Kanban?: KanbanUpdateOneWithoutListsNestedInput
  }

  export type KanBanListUncheckedUpdateWithoutCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    boardId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KanBanCardCreateWithoutKanBanListInput = {
    indexWithinList: number
    label?: string | null
    details?: string | null
  }

  export type KanBanCardUncheckedCreateWithoutKanBanListInput = {
    id?: number
    indexWithinList: number
    label?: string | null
    details?: string | null
  }

  export type KanBanCardCreateOrConnectWithoutKanBanListInput = {
    where: KanBanCardWhereUniqueInput
    create: XOR<KanBanCardCreateWithoutKanBanListInput, KanBanCardUncheckedCreateWithoutKanBanListInput>
  }

  export type KanBanCardCreateManyKanBanListInputEnvelope = {
    data: KanBanCardCreateManyKanBanListInput | KanBanCardCreateManyKanBanListInput[]
    skipDuplicates?: boolean
  }

  export type KanbanCreateWithoutListsInput = {
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tags?: TagCreateNestedManyWithoutKanbanInput
    subjects?: SubjectCreateNestedManyWithoutKanbanInput
    topics?: TopicCreateNestedManyWithoutKanbanInput
  }

  export type KanbanUncheckedCreateWithoutListsInput = {
    id?: number
    title: string
    createdAt?: Date | string
    lastUpdate?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutKanbanInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutKanbanInput
    topics?: TopicUncheckedCreateNestedManyWithoutKanbanInput
  }

  export type KanbanCreateOrConnectWithoutListsInput = {
    where: KanbanWhereUniqueInput
    create: XOR<KanbanCreateWithoutListsInput, KanbanUncheckedCreateWithoutListsInput>
  }

  export type KanBanCardUpsertWithWhereUniqueWithoutKanBanListInput = {
    where: KanBanCardWhereUniqueInput
    update: XOR<KanBanCardUpdateWithoutKanBanListInput, KanBanCardUncheckedUpdateWithoutKanBanListInput>
    create: XOR<KanBanCardCreateWithoutKanBanListInput, KanBanCardUncheckedCreateWithoutKanBanListInput>
  }

  export type KanBanCardUpdateWithWhereUniqueWithoutKanBanListInput = {
    where: KanBanCardWhereUniqueInput
    data: XOR<KanBanCardUpdateWithoutKanBanListInput, KanBanCardUncheckedUpdateWithoutKanBanListInput>
  }

  export type KanBanCardUpdateManyWithWhereWithoutKanBanListInput = {
    where: KanBanCardScalarWhereInput
    data: XOR<KanBanCardUpdateManyMutationInput, KanBanCardUncheckedUpdateManyWithoutKanBanListInput>
  }

  export type KanBanCardScalarWhereInput = {
    AND?: KanBanCardScalarWhereInput | KanBanCardScalarWhereInput[]
    OR?: KanBanCardScalarWhereInput[]
    NOT?: KanBanCardScalarWhereInput | KanBanCardScalarWhereInput[]
    id?: IntFilter<"KanBanCard"> | number
    listId?: IntNullableFilter<"KanBanCard"> | number | null
    indexWithinList?: IntFilter<"KanBanCard"> | number
    label?: StringNullableFilter<"KanBanCard"> | string | null
    details?: StringNullableFilter<"KanBanCard"> | string | null
  }

  export type KanbanUpsertWithoutListsInput = {
    update: XOR<KanbanUpdateWithoutListsInput, KanbanUncheckedUpdateWithoutListsInput>
    create: XOR<KanbanCreateWithoutListsInput, KanbanUncheckedCreateWithoutListsInput>
    where?: KanbanWhereInput
  }

  export type KanbanUpdateToOneWithWhereWithoutListsInput = {
    where?: KanbanWhereInput
    data: XOR<KanbanUpdateWithoutListsInput, KanbanUncheckedUpdateWithoutListsInput>
  }

  export type KanbanUpdateWithoutListsInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutKanbanNestedInput
    subjects?: SubjectUpdateManyWithoutKanbanNestedInput
    topics?: TopicUpdateManyWithoutKanbanNestedInput
  }

  export type KanbanUncheckedUpdateWithoutListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutKanbanNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutKanbanNestedInput
    topics?: TopicUncheckedUpdateManyWithoutKanbanNestedInput
  }

  export type KanBanListCreateWithoutKanbanInput = {
    indexWithinBoard: number
    title?: string | null
    cards?: KanBanCardCreateNestedManyWithoutKanBanListInput
  }

  export type KanBanListUncheckedCreateWithoutKanbanInput = {
    id?: number
    indexWithinBoard: number
    title?: string | null
    cards?: KanBanCardUncheckedCreateNestedManyWithoutKanBanListInput
  }

  export type KanBanListCreateOrConnectWithoutKanbanInput = {
    where: KanBanListWhereUniqueInput
    create: XOR<KanBanListCreateWithoutKanbanInput, KanBanListUncheckedCreateWithoutKanbanInput>
  }

  export type KanBanListCreateManyKanbanInputEnvelope = {
    data: KanBanListCreateManyKanbanInput | KanBanListCreateManyKanbanInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutKanbanInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTagsInput
    QAPair?: QAPairCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTagsInput
    equations?: EquationCreateNestedManyWithoutTagsInput
    toDo?: ToDoCreateNestedManyWithoutTagsInput
    todoList?: ToDoListCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutKanbanInput = {
    value: string
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTagsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTagsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTagsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTagsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTagsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTagsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTagsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutKanbanInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutKanbanInput, TagUncheckedCreateWithoutKanbanInput>
  }

  export type TagCreateManyKanbanInputEnvelope = {
    data: TagCreateManyKanbanInput | TagCreateManyKanbanInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutKanbanInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryCreateNestedManyWithoutSubjectsInput
    equations?: EquationCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutKanbanInput = {
    value: string
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutSubjectsInput
    IpynbNotes?: IpynbUncheckedCreateNestedManyWithoutSubjectsInput
    QaPair?: QAPairUncheckedCreateNestedManyWithoutSubjectsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutSubjectsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutSubjectsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutSubjectsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutSubjectsInput
    equations?: EquationUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutKanbanInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutKanbanInput, SubjectUncheckedCreateWithoutKanbanInput>
  }

  export type SubjectCreateManyKanbanInputEnvelope = {
    data: SubjectCreateManyKanbanInput | SubjectCreateManyKanbanInput[]
    skipDuplicates?: boolean
  }

  export type TopicCreateWithoutKanbanInput = {
    value: string
    MdxNotes?: MdxNoteCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamCreateNestedManyWithoutTopicsInput
    toDo?: ToDoCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryCreateNestedManyWithoutTopicsInput
    equations?: EquationCreateNestedManyWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutKanbanInput = {
    value: string
    MdxNotes?: MdxNoteUncheckedCreateNestedManyWithoutTopicsInput
    ipynbNotes?: IpynbUncheckedCreateNestedManyWithoutTopicsInput
    QAPair?: QAPairUncheckedCreateNestedManyWithoutTopicsInput
    practiceExam?: PracticeExamUncheckedCreateNestedManyWithoutTopicsInput
    toDo?: ToDoUncheckedCreateNestedManyWithoutTopicsInput
    todoList?: ToDoListUncheckedCreateNestedManyWithoutTopicsInput
    bibEntries?: BibEntryUncheckedCreateNestedManyWithoutTopicsInput
    equations?: EquationUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicCreateOrConnectWithoutKanbanInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutKanbanInput, TopicUncheckedCreateWithoutKanbanInput>
  }

  export type TopicCreateManyKanbanInputEnvelope = {
    data: TopicCreateManyKanbanInput | TopicCreateManyKanbanInput[]
    skipDuplicates?: boolean
  }

  export type KanBanListUpsertWithWhereUniqueWithoutKanbanInput = {
    where: KanBanListWhereUniqueInput
    update: XOR<KanBanListUpdateWithoutKanbanInput, KanBanListUncheckedUpdateWithoutKanbanInput>
    create: XOR<KanBanListCreateWithoutKanbanInput, KanBanListUncheckedCreateWithoutKanbanInput>
  }

  export type KanBanListUpdateWithWhereUniqueWithoutKanbanInput = {
    where: KanBanListWhereUniqueInput
    data: XOR<KanBanListUpdateWithoutKanbanInput, KanBanListUncheckedUpdateWithoutKanbanInput>
  }

  export type KanBanListUpdateManyWithWhereWithoutKanbanInput = {
    where: KanBanListScalarWhereInput
    data: XOR<KanBanListUpdateManyMutationInput, KanBanListUncheckedUpdateManyWithoutKanbanInput>
  }

  export type KanBanListScalarWhereInput = {
    AND?: KanBanListScalarWhereInput | KanBanListScalarWhereInput[]
    OR?: KanBanListScalarWhereInput[]
    NOT?: KanBanListScalarWhereInput | KanBanListScalarWhereInput[]
    id?: IntFilter<"KanBanList"> | number
    indexWithinBoard?: IntFilter<"KanBanList"> | number
    title?: StringNullableFilter<"KanBanList"> | string | null
    boardId?: IntNullableFilter<"KanBanList"> | number | null
  }

  export type TagUpsertWithWhereUniqueWithoutKanbanInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutKanbanInput, TagUncheckedUpdateWithoutKanbanInput>
    create: XOR<TagCreateWithoutKanbanInput, TagUncheckedCreateWithoutKanbanInput>
  }

  export type TagUpdateWithWhereUniqueWithoutKanbanInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutKanbanInput, TagUncheckedUpdateWithoutKanbanInput>
  }

  export type TagUpdateManyWithWhereWithoutKanbanInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutKanbanInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutKanbanInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutKanbanInput, SubjectUncheckedUpdateWithoutKanbanInput>
    create: XOR<SubjectCreateWithoutKanbanInput, SubjectUncheckedCreateWithoutKanbanInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutKanbanInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutKanbanInput, SubjectUncheckedUpdateWithoutKanbanInput>
  }

  export type SubjectUpdateManyWithWhereWithoutKanbanInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutKanbanInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutKanbanInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutKanbanInput, TopicUncheckedUpdateWithoutKanbanInput>
    create: XOR<TopicCreateWithoutKanbanInput, TopicUncheckedCreateWithoutKanbanInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutKanbanInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutKanbanInput, TopicUncheckedUpdateWithoutKanbanInput>
  }

  export type TopicUpdateManyWithWhereWithoutKanbanInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutKanbanInput>
  }

  export type DietCreateWithoutPeriodsFollowedInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
    items?: DietaryItemCreateNestedManyWithoutDietInput
    HealthReport?: HealthReportCreateNestedManyWithoutCurrentDietInput
  }

  export type DietUncheckedCreateWithoutPeriodsFollowedInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
    items?: DietaryItemUncheckedCreateNestedManyWithoutDietInput
    HealthReport?: HealthReportUncheckedCreateNestedManyWithoutCurrentDietInput
  }

  export type DietCreateOrConnectWithoutPeriodsFollowedInput = {
    where: DietWhereUniqueInput
    create: XOR<DietCreateWithoutPeriodsFollowedInput, DietUncheckedCreateWithoutPeriodsFollowedInput>
  }

  export type DietUpsertWithoutPeriodsFollowedInput = {
    update: XOR<DietUpdateWithoutPeriodsFollowedInput, DietUncheckedUpdateWithoutPeriodsFollowedInput>
    create: XOR<DietCreateWithoutPeriodsFollowedInput, DietUncheckedCreateWithoutPeriodsFollowedInput>
    where?: DietWhereInput
  }

  export type DietUpdateToOneWithWhereWithoutPeriodsFollowedInput = {
    where?: DietWhereInput
    data: XOR<DietUpdateWithoutPeriodsFollowedInput, DietUncheckedUpdateWithoutPeriodsFollowedInput>
  }

  export type DietUpdateWithoutPeriodsFollowedInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DietaryItemUpdateManyWithoutDietNestedInput
    HealthReport?: HealthReportUpdateManyWithoutCurrentDietNestedInput
  }

  export type DietUncheckedUpdateWithoutPeriodsFollowedInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DietaryItemUncheckedUpdateManyWithoutDietNestedInput
    HealthReport?: HealthReportUncheckedUpdateManyWithoutCurrentDietNestedInput
  }

  export type DietaryItemCreateWithoutDietInput = {
    name: string
    barcode?: string | null
    gi?: number | null
    calsPerOz?: number | null
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: number
    Serving?: ServingCreateNestedManyWithoutItemInput
  }

  export type DietaryItemUncheckedCreateWithoutDietInput = {
    id?: number
    name: string
    barcode?: string | null
    gi?: number | null
    calsPerOz?: number | null
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: number
    Serving?: ServingUncheckedCreateNestedManyWithoutItemInput
  }

  export type DietaryItemCreateOrConnectWithoutDietInput = {
    where: DietaryItemWhereUniqueInput
    create: XOR<DietaryItemCreateWithoutDietInput, DietaryItemUncheckedCreateWithoutDietInput>
  }

  export type TimePeriodCreateWithoutDietInput = {
    start?: Date | string
    end?: Date | string | null
  }

  export type TimePeriodUncheckedCreateWithoutDietInput = {
    id?: number
    start?: Date | string
    end?: Date | string | null
  }

  export type TimePeriodCreateOrConnectWithoutDietInput = {
    where: TimePeriodWhereUniqueInput
    create: XOR<TimePeriodCreateWithoutDietInput, TimePeriodUncheckedCreateWithoutDietInput>
  }

  export type TimePeriodCreateManyDietInputEnvelope = {
    data: TimePeriodCreateManyDietInput | TimePeriodCreateManyDietInput[]
    skipDuplicates?: boolean
  }

  export type HealthReportCreateWithoutCurrentDietInput = {
    title?: string | null
    summary?: string | null
    overall?: number
    skin?: number
    bloat?: number
    weight_feeling?: number
    fullness?: number
    weight?: number | null
    cardiacCapacity?: number
    jawLine?: number
    joints?: number
    flexibility?: number
    anxiety?: number
    anxiety_desc?: string | null
    mood_desc?: string | null
    mood?: number
    sexDrive?: number
    intruisiveThoughts?: number
    caffeineIntake?: number
    glutenIntake?: number
    sugarIntake?: number
    artificialSweetenerIntake?: number
    artificalDyes?: number
    sleepQuality?: number
    hydration?: number
    twitching?: number
    sleepHours?: number | null
    calorie_est?: number | null
    times_meals_more_than_gap_apart?: number | null
    estHoursInExcessFast?: number | null
    created?: Date | string
  }

  export type HealthReportUncheckedCreateWithoutCurrentDietInput = {
    id?: number
    title?: string | null
    summary?: string | null
    overall?: number
    skin?: number
    bloat?: number
    weight_feeling?: number
    fullness?: number
    weight?: number | null
    cardiacCapacity?: number
    jawLine?: number
    joints?: number
    flexibility?: number
    anxiety?: number
    anxiety_desc?: string | null
    mood_desc?: string | null
    mood?: number
    sexDrive?: number
    intruisiveThoughts?: number
    caffeineIntake?: number
    glutenIntake?: number
    sugarIntake?: number
    artificialSweetenerIntake?: number
    artificalDyes?: number
    sleepQuality?: number
    hydration?: number
    twitching?: number
    sleepHours?: number | null
    calorie_est?: number | null
    times_meals_more_than_gap_apart?: number | null
    estHoursInExcessFast?: number | null
    created?: Date | string
  }

  export type HealthReportCreateOrConnectWithoutCurrentDietInput = {
    where: HealthReportWhereUniqueInput
    create: XOR<HealthReportCreateWithoutCurrentDietInput, HealthReportUncheckedCreateWithoutCurrentDietInput>
  }

  export type HealthReportCreateManyCurrentDietInputEnvelope = {
    data: HealthReportCreateManyCurrentDietInput | HealthReportCreateManyCurrentDietInput[]
    skipDuplicates?: boolean
  }

  export type DietaryItemUpsertWithWhereUniqueWithoutDietInput = {
    where: DietaryItemWhereUniqueInput
    update: XOR<DietaryItemUpdateWithoutDietInput, DietaryItemUncheckedUpdateWithoutDietInput>
    create: XOR<DietaryItemCreateWithoutDietInput, DietaryItemUncheckedCreateWithoutDietInput>
  }

  export type DietaryItemUpdateWithWhereUniqueWithoutDietInput = {
    where: DietaryItemWhereUniqueInput
    data: XOR<DietaryItemUpdateWithoutDietInput, DietaryItemUncheckedUpdateWithoutDietInput>
  }

  export type DietaryItemUpdateManyWithWhereWithoutDietInput = {
    where: DietaryItemScalarWhereInput
    data: XOR<DietaryItemUpdateManyMutationInput, DietaryItemUncheckedUpdateManyWithoutDietInput>
  }

  export type DietaryItemScalarWhereInput = {
    AND?: DietaryItemScalarWhereInput | DietaryItemScalarWhereInput[]
    OR?: DietaryItemScalarWhereInput[]
    NOT?: DietaryItemScalarWhereInput | DietaryItemScalarWhereInput[]
    id?: IntFilter<"DietaryItem"> | number
    name?: StringFilter<"DietaryItem"> | string
    barcode?: StringNullableFilter<"DietaryItem"> | string | null
    gi?: IntNullableFilter<"DietaryItem"> | number | null
    calsPerOz?: FloatNullableFilter<"DietaryItem"> | number | null
    glutenFree?: BoolFilter<"DietaryItem"> | boolean
    minimalFructose?: BoolFilter<"DietaryItem"> | boolean
    natural?: BoolFilter<"DietaryItem"> | boolean
    organic?: BoolFilter<"DietaryItem"> | boolean
    impactScore?: FloatFilter<"DietaryItem"> | number
  }

  export type TimePeriodUpsertWithWhereUniqueWithoutDietInput = {
    where: TimePeriodWhereUniqueInput
    update: XOR<TimePeriodUpdateWithoutDietInput, TimePeriodUncheckedUpdateWithoutDietInput>
    create: XOR<TimePeriodCreateWithoutDietInput, TimePeriodUncheckedCreateWithoutDietInput>
  }

  export type TimePeriodUpdateWithWhereUniqueWithoutDietInput = {
    where: TimePeriodWhereUniqueInput
    data: XOR<TimePeriodUpdateWithoutDietInput, TimePeriodUncheckedUpdateWithoutDietInput>
  }

  export type TimePeriodUpdateManyWithWhereWithoutDietInput = {
    where: TimePeriodScalarWhereInput
    data: XOR<TimePeriodUpdateManyMutationInput, TimePeriodUncheckedUpdateManyWithoutDietInput>
  }

  export type TimePeriodScalarWhereInput = {
    AND?: TimePeriodScalarWhereInput | TimePeriodScalarWhereInput[]
    OR?: TimePeriodScalarWhereInput[]
    NOT?: TimePeriodScalarWhereInput | TimePeriodScalarWhereInput[]
    id?: IntFilter<"TimePeriod"> | number
    start?: DateTimeFilter<"TimePeriod"> | Date | string
    end?: DateTimeNullableFilter<"TimePeriod"> | Date | string | null
    dietId?: StringNullableFilter<"TimePeriod"> | string | null
  }

  export type HealthReportUpsertWithWhereUniqueWithoutCurrentDietInput = {
    where: HealthReportWhereUniqueInput
    update: XOR<HealthReportUpdateWithoutCurrentDietInput, HealthReportUncheckedUpdateWithoutCurrentDietInput>
    create: XOR<HealthReportCreateWithoutCurrentDietInput, HealthReportUncheckedCreateWithoutCurrentDietInput>
  }

  export type HealthReportUpdateWithWhereUniqueWithoutCurrentDietInput = {
    where: HealthReportWhereUniqueInput
    data: XOR<HealthReportUpdateWithoutCurrentDietInput, HealthReportUncheckedUpdateWithoutCurrentDietInput>
  }

  export type HealthReportUpdateManyWithWhereWithoutCurrentDietInput = {
    where: HealthReportScalarWhereInput
    data: XOR<HealthReportUpdateManyMutationInput, HealthReportUncheckedUpdateManyWithoutCurrentDietInput>
  }

  export type HealthReportScalarWhereInput = {
    AND?: HealthReportScalarWhereInput | HealthReportScalarWhereInput[]
    OR?: HealthReportScalarWhereInput[]
    NOT?: HealthReportScalarWhereInput | HealthReportScalarWhereInput[]
    id?: IntFilter<"HealthReport"> | number
    title?: StringNullableFilter<"HealthReport"> | string | null
    summary?: StringNullableFilter<"HealthReport"> | string | null
    overall?: FloatFilter<"HealthReport"> | number
    skin?: FloatFilter<"HealthReport"> | number
    bloat?: FloatFilter<"HealthReport"> | number
    weight_feeling?: FloatFilter<"HealthReport"> | number
    fullness?: FloatFilter<"HealthReport"> | number
    weight?: FloatNullableFilter<"HealthReport"> | number | null
    cardiacCapacity?: FloatFilter<"HealthReport"> | number
    jawLine?: FloatFilter<"HealthReport"> | number
    joints?: FloatFilter<"HealthReport"> | number
    flexibility?: FloatFilter<"HealthReport"> | number
    anxiety?: FloatFilter<"HealthReport"> | number
    anxiety_desc?: StringNullableFilter<"HealthReport"> | string | null
    mood_desc?: StringNullableFilter<"HealthReport"> | string | null
    mood?: FloatFilter<"HealthReport"> | number
    sexDrive?: FloatFilter<"HealthReport"> | number
    intruisiveThoughts?: FloatFilter<"HealthReport"> | number
    caffeineIntake?: FloatFilter<"HealthReport"> | number
    glutenIntake?: FloatFilter<"HealthReport"> | number
    sugarIntake?: FloatFilter<"HealthReport"> | number
    artificialSweetenerIntake?: FloatFilter<"HealthReport"> | number
    artificalDyes?: FloatFilter<"HealthReport"> | number
    sleepQuality?: FloatFilter<"HealthReport"> | number
    hydration?: FloatFilter<"HealthReport"> | number
    twitching?: FloatFilter<"HealthReport"> | number
    sleepHours?: FloatNullableFilter<"HealthReport"> | number | null
    calorie_est?: IntNullableFilter<"HealthReport"> | number | null
    times_meals_more_than_gap_apart?: IntNullableFilter<"HealthReport"> | number | null
    estHoursInExcessFast?: FloatNullableFilter<"HealthReport"> | number | null
    dietId?: StringNullableFilter<"HealthReport"> | string | null
    created?: DateTimeFilter<"HealthReport"> | Date | string
  }

  export type DietaryItemCreateWithoutServingInput = {
    name: string
    barcode?: string | null
    gi?: number | null
    calsPerOz?: number | null
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: number
    Diet?: DietCreateNestedManyWithoutItemsInput
  }

  export type DietaryItemUncheckedCreateWithoutServingInput = {
    id?: number
    name: string
    barcode?: string | null
    gi?: number | null
    calsPerOz?: number | null
    glutenFree?: boolean
    minimalFructose?: boolean
    natural?: boolean
    organic?: boolean
    impactScore?: number
    Diet?: DietUncheckedCreateNestedManyWithoutItemsInput
  }

  export type DietaryItemCreateOrConnectWithoutServingInput = {
    where: DietaryItemWhereUniqueInput
    create: XOR<DietaryItemCreateWithoutServingInput, DietaryItemUncheckedCreateWithoutServingInput>
  }

  export type DietaryItemUpsertWithoutServingInput = {
    update: XOR<DietaryItemUpdateWithoutServingInput, DietaryItemUncheckedUpdateWithoutServingInput>
    create: XOR<DietaryItemCreateWithoutServingInput, DietaryItemUncheckedCreateWithoutServingInput>
    where?: DietaryItemWhereInput
  }

  export type DietaryItemUpdateToOneWithWhereWithoutServingInput = {
    where?: DietaryItemWhereInput
    data: XOR<DietaryItemUpdateWithoutServingInput, DietaryItemUncheckedUpdateWithoutServingInput>
  }

  export type DietaryItemUpdateWithoutServingInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
    Diet?: DietUpdateManyWithoutItemsNestedInput
  }

  export type DietaryItemUncheckedUpdateWithoutServingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
    Diet?: DietUncheckedUpdateManyWithoutItemsNestedInput
  }

  export type DietCreateWithoutItemsInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
    periodsFollowed?: TimePeriodCreateNestedManyWithoutDietInput
    HealthReport?: HealthReportCreateNestedManyWithoutCurrentDietInput
  }

  export type DietUncheckedCreateWithoutItemsInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
    periodsFollowed?: TimePeriodUncheckedCreateNestedManyWithoutDietInput
    HealthReport?: HealthReportUncheckedCreateNestedManyWithoutCurrentDietInput
  }

  export type DietCreateOrConnectWithoutItemsInput = {
    where: DietWhereUniqueInput
    create: XOR<DietCreateWithoutItemsInput, DietUncheckedCreateWithoutItemsInput>
  }

  export type ServingCreateWithoutItemInput = {
    quant_oz?: number | null
    quant_guess?: $Enums.QUANTITY_GUESS | null
  }

  export type ServingUncheckedCreateWithoutItemInput = {
    id?: number
    quant_oz?: number | null
    quant_guess?: $Enums.QUANTITY_GUESS | null
  }

  export type ServingCreateOrConnectWithoutItemInput = {
    where: ServingWhereUniqueInput
    create: XOR<ServingCreateWithoutItemInput, ServingUncheckedCreateWithoutItemInput>
  }

  export type ServingCreateManyItemInputEnvelope = {
    data: ServingCreateManyItemInput | ServingCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type DietUpsertWithWhereUniqueWithoutItemsInput = {
    where: DietWhereUniqueInput
    update: XOR<DietUpdateWithoutItemsInput, DietUncheckedUpdateWithoutItemsInput>
    create: XOR<DietCreateWithoutItemsInput, DietUncheckedCreateWithoutItemsInput>
  }

  export type DietUpdateWithWhereUniqueWithoutItemsInput = {
    where: DietWhereUniqueInput
    data: XOR<DietUpdateWithoutItemsInput, DietUncheckedUpdateWithoutItemsInput>
  }

  export type DietUpdateManyWithWhereWithoutItemsInput = {
    where: DietScalarWhereInput
    data: XOR<DietUpdateManyMutationInput, DietUncheckedUpdateManyWithoutItemsInput>
  }

  export type DietScalarWhereInput = {
    AND?: DietScalarWhereInput | DietScalarWhereInput[]
    OR?: DietScalarWhereInput[]
    NOT?: DietScalarWhereInput | DietScalarWhereInput[]
    name?: StringFilter<"Diet"> | string
    summary?: StringNullableFilter<"Diet"> | string | null
    activelyFollowing?: BoolFilter<"Diet"> | boolean
    gf?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFilter<"Diet"> | boolean
    pescatarian?: BoolFilter<"Diet"> | boolean
    vegetarian?: BoolFilter<"Diet"> | boolean
    fasting?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFilter<"Diet"> | $Enums.TERTIARY_TOGGLE
    carb?: FloatNullableFilter<"Diet"> | number | null
    pro?: FloatNullableFilter<"Diet"> | number | null
    fat?: FloatNullableFilter<"Diet"> | number | null
    goals?: EnumDIETARY_GOALNullableListFilter<"Diet">
    created?: DateTimeFilter<"Diet"> | Date | string
    lastUpdate?: DateTimeFilter<"Diet"> | Date | string
  }

  export type ServingUpsertWithWhereUniqueWithoutItemInput = {
    where: ServingWhereUniqueInput
    update: XOR<ServingUpdateWithoutItemInput, ServingUncheckedUpdateWithoutItemInput>
    create: XOR<ServingCreateWithoutItemInput, ServingUncheckedCreateWithoutItemInput>
  }

  export type ServingUpdateWithWhereUniqueWithoutItemInput = {
    where: ServingWhereUniqueInput
    data: XOR<ServingUpdateWithoutItemInput, ServingUncheckedUpdateWithoutItemInput>
  }

  export type ServingUpdateManyWithWhereWithoutItemInput = {
    where: ServingScalarWhereInput
    data: XOR<ServingUpdateManyMutationInput, ServingUncheckedUpdateManyWithoutItemInput>
  }

  export type ServingScalarWhereInput = {
    AND?: ServingScalarWhereInput | ServingScalarWhereInput[]
    OR?: ServingScalarWhereInput[]
    NOT?: ServingScalarWhereInput | ServingScalarWhereInput[]
    id?: IntFilter<"Serving"> | number
    dietaryItemId?: IntFilter<"Serving"> | number
    quant_oz?: FloatNullableFilter<"Serving"> | number | null
    quant_guess?: EnumQUANTITY_GUESSNullableFilter<"Serving"> | $Enums.QUANTITY_GUESS | null
  }

  export type DietCreateWithoutHealthReportInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
    items?: DietaryItemCreateNestedManyWithoutDietInput
    periodsFollowed?: TimePeriodCreateNestedManyWithoutDietInput
  }

  export type DietUncheckedCreateWithoutHealthReportInput = {
    name: string
    summary?: string | null
    activelyFollowing?: boolean
    gf?: $Enums.TERTIARY_TOGGLE
    vegan?: boolean
    pescatarian?: boolean
    vegetarian?: boolean
    fasting?: $Enums.TERTIARY_TOGGLE
    cardioTraining?: $Enums.TERTIARY_TOGGLE
    weightTraining?: $Enums.TERTIARY_TOGGLE
    carb?: number | null
    pro?: number | null
    fat?: number | null
    goals?: DietCreategoalsInput | $Enums.DIETARY_GOAL[]
    created?: Date | string
    lastUpdate?: Date | string
    items?: DietaryItemUncheckedCreateNestedManyWithoutDietInput
    periodsFollowed?: TimePeriodUncheckedCreateNestedManyWithoutDietInput
  }

  export type DietCreateOrConnectWithoutHealthReportInput = {
    where: DietWhereUniqueInput
    create: XOR<DietCreateWithoutHealthReportInput, DietUncheckedCreateWithoutHealthReportInput>
  }

  export type DietUpsertWithoutHealthReportInput = {
    update: XOR<DietUpdateWithoutHealthReportInput, DietUncheckedUpdateWithoutHealthReportInput>
    create: XOR<DietCreateWithoutHealthReportInput, DietUncheckedCreateWithoutHealthReportInput>
    where?: DietWhereInput
  }

  export type DietUpdateToOneWithWhereWithoutHealthReportInput = {
    where?: DietWhereInput
    data: XOR<DietUpdateWithoutHealthReportInput, DietUncheckedUpdateWithoutHealthReportInput>
  }

  export type DietUpdateWithoutHealthReportInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DietaryItemUpdateManyWithoutDietNestedInput
    periodsFollowed?: TimePeriodUpdateManyWithoutDietNestedInput
  }

  export type DietUncheckedUpdateWithoutHealthReportInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DietaryItemUncheckedUpdateManyWithoutDietNestedInput
    periodsFollowed?: TimePeriodUncheckedUpdateManyWithoutDietNestedInput
  }

  export type MdxNoteUpdateWithoutSubjectsInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpynbUpdateWithoutSubjectsInput = {
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUpdateManyWithoutIpynbNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutIpynbNestedInput
    readingList?: ReadingListUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutIpynbNotesNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAPairUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    tags?: TagUpdateManyWithoutQAPairNestedInput
    topics?: TopicUpdateManyWithoutQAPairNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutQuestionsNestedInput
  }

  export type QAPairUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutQAPairNestedInput
    topics?: TopicUncheckedUpdateManyWithoutQAPairNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QAPairUncheckedUpdateManyWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
  }

  export type PracticeExamUpdateWithoutSubjectsInput = {
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutPracticeExamNestedInput
    tags?: TagUpdateManyWithoutPracticeExamNestedInput
    questions?: QAPairUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutPracticeExamNestedInput
    tags?: TagUncheckedUpdateManyWithoutPracticeExamNestedInput
    questions?: QAPairUncheckedUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToDoListUpdateWithoutSubjectsInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ToDoUpdateManyWithoutToDoListNestedInput
    tags?: TagUpdateManyWithoutTodoListNestedInput
    topics?: TopicUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ToDoUncheckedUpdateManyWithoutToDoListNestedInput
    tags?: TagUncheckedUpdateManyWithoutTodoListNestedInput
    topics?: TopicUncheckedUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToDoUpdateWithoutSubjectsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    associatedNotes?: MdxNoteUpdateManyWithoutToDoNestedInput
    tags?: TagUpdateManyWithoutToDoNestedInput
    topics?: TopicUpdateManyWithoutToDoNestedInput
    parent?: ToDoUpdateOneWithoutChildNestedInput
    child?: ToDoUpdateManyWithoutParentNestedInput
    ToDoList?: ToDoListUpdateOneWithoutTasksNestedInput
  }

  export type ToDoUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
    associatedNotes?: MdxNoteUncheckedUpdateManyWithoutToDoNestedInput
    tags?: TagUncheckedUpdateManyWithoutToDoNestedInput
    topics?: TopicUncheckedUpdateManyWithoutToDoNestedInput
    child?: ToDoUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ToDoUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BibEntryUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    Bib?: BibUpdateOneWithoutEntriesNestedInput
    citationGroups?: CitationsGroupUpdateManyWithoutEntriesNestedInput
    tags?: TagUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateManyWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquationUpdateWithoutSubjectsInput = {
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUpdateManyWithoutEquationsNestedInput
    tags?: TagUpdateManyWithoutEquationsNestedInput
    topics?: TopicUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUncheckedUpdateManyWithoutEquationsNestedInput
    tags?: TagUncheckedUpdateManyWithoutEquationsNestedInput
    topics?: TopicUncheckedUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUncheckedUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MdxNoteUpdateWithoutTopicsInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateManyWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpynbUpdateWithoutTopicsInput = {
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUpdateManyWithoutIpynbNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutIpynbNestedInput
    readingList?: ReadingListUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutIpynbNotesNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateManyWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAPairUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    tags?: TagUpdateManyWithoutQAPairNestedInput
    subjects?: SubjectUpdateManyWithoutQaPairNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutQuestionsNestedInput
  }

  export type QAPairUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutQAPairNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutQaPairNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QAPairUncheckedUpdateManyWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
  }

  export type PracticeExamUpdateWithoutTopicsInput = {
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutPracticeExamNestedInput
    subjects?: SubjectUpdateManyWithoutPracticeExamNestedInput
    questions?: QAPairUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutPracticeExamNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutPracticeExamNestedInput
    questions?: QAPairUncheckedUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateManyWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToDoUpdateWithoutTopicsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    associatedNotes?: MdxNoteUpdateManyWithoutToDoNestedInput
    tags?: TagUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUpdateManyWithoutToDoNestedInput
    parent?: ToDoUpdateOneWithoutChildNestedInput
    child?: ToDoUpdateManyWithoutParentNestedInput
    ToDoList?: ToDoListUpdateOneWithoutTasksNestedInput
  }

  export type ToDoUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
    associatedNotes?: MdxNoteUncheckedUpdateManyWithoutToDoNestedInput
    tags?: TagUncheckedUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutToDoNestedInput
    child?: ToDoUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ToDoUncheckedUpdateManyWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ToDoListUpdateWithoutTopicsInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ToDoUpdateManyWithoutToDoListNestedInput
    tags?: TagUpdateManyWithoutTodoListNestedInput
    subjects?: SubjectUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ToDoUncheckedUpdateManyWithoutToDoListNestedInput
    tags?: TagUncheckedUpdateManyWithoutTodoListNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListUncheckedUpdateManyWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibEntryUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    Bib?: BibUpdateOneWithoutEntriesNestedInput
    citationGroups?: CitationsGroupUpdateManyWithoutEntriesNestedInput
    tags?: TagUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateManyWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquationUpdateWithoutTopicsInput = {
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUpdateManyWithoutEquationsNestedInput
    tags?: TagUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUncheckedUpdateManyWithoutEquationsNestedInput
    tags?: TagUncheckedUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUncheckedUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateManyWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MdxNoteUpdateWithoutTagsInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibEntryUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    Bib?: BibUpdateOneWithoutEntriesNestedInput
    citationGroups?: CitationsGroupUpdateManyWithoutEntriesNestedInput
    topics?: TopicUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpynbUpdateWithoutTagsInput = {
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUpdateManyWithoutIpynbNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutIpynbNestedInput
    readingList?: ReadingListUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutIpynbNotesNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAPairUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    topics?: TopicUpdateManyWithoutQAPairNestedInput
    subjects?: SubjectUpdateManyWithoutQaPairNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutQuestionsNestedInput
  }

  export type QAPairUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    topics?: TopicUncheckedUpdateManyWithoutQAPairNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutQaPairNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QAPairUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
  }

  export type PracticeExamUpdateWithoutTagsInput = {
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutPracticeExamNestedInput
    subjects?: SubjectUpdateManyWithoutPracticeExamNestedInput
    questions?: QAPairUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutPracticeExamNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutPracticeExamNestedInput
    questions?: QAPairUncheckedUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquationUpdateWithoutTagsInput = {
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUpdateManyWithoutEquationsNestedInput
    topics?: TopicUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUncheckedUpdateManyWithoutEquationsNestedInput
    topics?: TopicUncheckedUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUncheckedUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToDoUpdateWithoutTagsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    associatedNotes?: MdxNoteUpdateManyWithoutToDoNestedInput
    topics?: TopicUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUpdateManyWithoutToDoNestedInput
    parent?: ToDoUpdateOneWithoutChildNestedInput
    child?: ToDoUpdateManyWithoutParentNestedInput
    ToDoList?: ToDoListUpdateOneWithoutTasksNestedInput
  }

  export type ToDoUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
    associatedNotes?: MdxNoteUncheckedUpdateManyWithoutToDoNestedInput
    topics?: TopicUncheckedUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutToDoNestedInput
    child?: ToDoUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ToDoUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ToDoListUpdateWithoutTagsInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ToDoUpdateManyWithoutToDoListNestedInput
    topics?: TopicUpdateManyWithoutTodoListNestedInput
    subjects?: SubjectUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ToDoUncheckedUpdateManyWithoutToDoListNestedInput
    topics?: TopicUncheckedUpdateManyWithoutTodoListNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutTodoListNestedInput
  }

  export type ToDoListUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibEntryUpdateWithoutReadingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    Bib?: BibUpdateOneWithoutEntriesNestedInput
    citationGroups?: CitationsGroupUpdateManyWithoutEntriesNestedInput
    tags?: TagUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutCitationsNestedInput
  }

  export type BibEntryUncheckedUpdateWithoutReadingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutCitationsNestedInput
  }

  export type BibEntryUncheckedUpdateManyWithoutReadingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MdxNoteUpdateWithoutReadingListInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutReadingListInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateManyWithoutReadingListInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpynbUpdateWithoutReadingListInput = {
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUpdateManyWithoutIpynbNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutIpynbNestedInput
  }

  export type IpynbUncheckedUpdateWithoutReadingListInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateManyWithoutReadingListInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationsGroupUpdateWithoutEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CitationsGroupUncheckedUpdateWithoutEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CitationsGroupUncheckedUpdateManyWithoutEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUpdateWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TopicUpdateWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubjectUpdateWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutBibEntriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MdxNoteUpdateWithoutCitationsInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutCitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateManyWithoutCitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpynbUpdateWithoutCitationsInput = {
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUpdateManyWithoutIpynbNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutIpynbNestedInput
    readingList?: ReadingListUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateWithoutCitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutIpynbNotesNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateManyWithoutCitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingListUpdateWithoutBibEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    mdxNotes?: MdxNoteUpdateManyWithoutReadingListNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutReadingListNestedInput
  }

  export type ReadingListUncheckedUpdateWithoutBibEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    mdxNotes?: MdxNoteUncheckedUpdateManyWithoutReadingListNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutReadingListNestedInput
  }

  export type ReadingListUncheckedUpdateManyWithoutBibEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibEntryUpdateWithoutCitationGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    Bib?: BibUpdateOneWithoutEntriesNestedInput
    tags?: TagUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateWithoutCitationGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateManyWithoutCitationGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BibEntryCreateManyBibInput = {
    id: string
    OwnWork?: boolean
    ColleaguesWork?: boolean
    read?: boolean
    htmlCitation?: string | null
    PdfPath?: string | null
    address?: string | null
    annote?: string | null
    author?: string | null
    booktitle?: string | null
    chapter?: string | null
    crossref?: string | null
    doi?: string | null
    edition?: string | null
    editor?: string | null
    email?: string | null
    howpublished?: string | null
    institution?: string | null
    journal?: string | null
    month?: string | null
    note?: string | null
    number?: string | null
    organization?: string | null
    pages?: string | null
    publisher?: string | null
    school?: string | null
    series?: string | null
    title?: string | null
    volume?: string | null
    type?: string | null
    year?: string | null
    numpages?: string | null
    url?: string | null
    issue?: string | null
    issn?: string | null
    abstract?: string | null
    urldate?: string | null
    keywords?: string | null
    copyright?: string | null
    added?: Date | string
  }

  export type BibEntryUpdateWithoutBibInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUpdateManyWithoutEntriesNestedInput
    tags?: TagUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateWithoutBibInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateManyWithoutBibInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquationUpdateWithoutRelatedValuesInput = {
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutEquationsNestedInput
    topics?: TopicUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateWithoutRelatedValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutEquationsNestedInput
    topics?: TopicUncheckedUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutEquationsNestedInput
    mdxNotes?: MdxNoteUncheckedUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateManyWithoutRelatedValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelatedValuesUpdateWithoutEquationsInput = {
    input?: JsonNullValueInput | InputJsonValue
    output?: FloatFieldUpdateOperationsInput | number
    equationId?: RelatedValuesUpdateequationIdInput | number[]
  }

  export type RelatedValuesUncheckedUpdateWithoutEquationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: FloatFieldUpdateOperationsInput | number
    equationId?: RelatedValuesUpdateequationIdInput | number[]
  }

  export type RelatedValuesUncheckedUpdateManyWithoutEquationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: FloatFieldUpdateOperationsInput | number
    equationId?: RelatedValuesUpdateequationIdInput | number[]
  }

  export type TagUpdateWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TopicUpdateWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubjectUpdateWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutEquationsInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MdxNoteUpdateWithoutEquationsInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutEquationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateManyWithoutEquationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutQAPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutQAPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutQAPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TopicUpdateWithoutQAPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutQAPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutQAPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubjectUpdateWithoutQaPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutQaPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutQaPairInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PracticeExamUpdateWithoutQuestionsInput = {
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutPracticeExamNestedInput
    tags?: TagUpdateManyWithoutPracticeExamNestedInput
    subjects?: SubjectUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutPracticeExamNestedInput
    tags?: TagUncheckedUpdateManyWithoutPracticeExamNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutPracticeExamNestedInput
  }

  export type PracticeExamUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    timeLimitInSeconds?: IntFieldUpdateOperationsInput | number
    timeCompletedInSeconds?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUpdateWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagUpdateWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubjectUpdateWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutPracticeExamInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QAPairUpdateWithoutPracticeExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    tags?: TagUpdateManyWithoutQAPairNestedInput
    topics?: TopicUpdateManyWithoutQAPairNestedInput
    subjects?: SubjectUpdateManyWithoutQaPairNestedInput
  }

  export type QAPairUncheckedUpdateWithoutPracticeExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutQAPairNestedInput
    topics?: TopicUncheckedUpdateManyWithoutQAPairNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutQaPairNestedInput
  }

  export type QAPairUncheckedUpdateManyWithoutPracticeExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryLabel?: NullableStringFieldUpdateOperationsInput | string | null
    correctCount?: IntFieldUpdateOperationsInput | number
    inCorrectCount?: IntFieldUpdateOperationsInput | number
  }

  export type MdxNoteCreateManySequentialListInput = {
    id?: number
    isProtected?: boolean | null
    dietSummaryKey?: string | null
    title: string
    latexTitle?: string | null
    rootRelativePath: string
    noteType: string
    content: string
    formatted?: string | null
    summary?: string | null
    citationsListOrder?: MdxNoteCreatecitationsListOrderInput | string[]
    importantValues?: MdxNoteCreateimportantValuesInput | number[]
    imageSrc?: string | null
    href: string
    sequentialIndex?: number | null
    floatImages?: boolean
    remoteUrl?: string | null
    trackRemote?: boolean
    outgoingQuickLinks?: MdxNoteCreateoutgoingQuickLinksInput | string[]
    quickLink?: string | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type IpynbCreateManySequentialListInput = {
    id?: number
    rootRelativePath: string
    isProtected?: boolean | null
    title: string
    latexTitle?: string | null
    citationsListOrder?: IpynbCreatecitationsListOrderInput | string[]
    importantValues?: IpynbCreateimportantValuesInput | number[]
    href: string
    outgoingQuickLinks?: IpynbCreateoutgoingQuickLinksInput | string[]
    raw: Buffer
    sequentialIndex?: number | null
    bookmarked?: boolean
    firstSync?: Date | string
    lastSync?: Date | string
  }

  export type MdxNoteUpdateWithoutSequentialListInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutSequentialListInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutAssociatedNotesNestedInput
  }

  export type MdxNoteUncheckedUpdateManyWithoutSequentialListInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpynbUpdateWithoutSequentialListInput = {
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUpdateManyWithoutIpynbNotesNestedInput
    readingList?: ReadingListUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateWithoutSequentialListInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutIpynbNotesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutIpynbNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutIpynbNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutIpynbNotesNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutIpynbNotesNestedInput
  }

  export type IpynbUncheckedUpdateManyWithoutSequentialListInput = {
    id?: IntFieldUpdateOperationsInput | number
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: IpynbUpdatecitationsListOrderInput | string[]
    importantValues?: IpynbUpdateimportantValuesInput | number[]
    href?: StringFieldUpdateOperationsInput | string
    outgoingQuickLinks?: IpynbUpdateoutgoingQuickLinksInput | string[]
    raw?: BytesFieldUpdateOperationsInput | Buffer
    sequentialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefinitionCreateManyMdxNoteInput = {
    id: string
    label?: string | null
    content?: string | null
    alphabeticalLabel?: string | null
  }

  export type TopicUpdateWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubjectUpdateWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagUpdateWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutMdxNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BibEntryUpdateWithoutMdxNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    Bib?: BibUpdateOneWithoutEntriesNestedInput
    citationGroups?: CitationsGroupUpdateManyWithoutEntriesNestedInput
    tags?: TagUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUpdateManyWithoutBibEntriesNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateWithoutMdxNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateManyWithoutMdxNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingListUpdateWithoutMdxNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bibEntries?: BibEntryUpdateManyWithoutReadingListNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutReadingListNestedInput
  }

  export type ReadingListUncheckedUpdateWithoutMdxNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bibEntries?: BibEntryUncheckedUpdateManyWithoutReadingListNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutReadingListNestedInput
  }

  export type ReadingListUncheckedUpdateManyWithoutMdxNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquationUpdateWithoutMdxNotesInput = {
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUpdateManyWithoutEquationsNestedInput
    tags?: TagUpdateManyWithoutEquationsNestedInput
    topics?: TopicUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateWithoutMdxNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedValues?: RelatedValuesUncheckedUpdateManyWithoutEquationsNestedInput
    tags?: TagUncheckedUpdateManyWithoutEquationsNestedInput
    topics?: TopicUncheckedUpdateManyWithoutEquationsNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutEquationsNestedInput
  }

  export type EquationUncheckedUpdateManyWithoutMdxNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    equationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asPython?: NullableStringFieldUpdateOperationsInput | string | null
    variableLegend?: NullableJsonNullValueInput | InputJsonValue
    variables?: EquationUpdatevariablesInput | string[]
    keywords?: EquationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefinitionUpdateWithoutMdxNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    alphabeticalLabel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DefinitionUncheckedUpdateWithoutMdxNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    alphabeticalLabel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DefinitionUncheckedUpdateManyWithoutMdxNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    alphabeticalLabel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ToDoUpdateWithoutAssociatedNotesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    tags?: TagUpdateManyWithoutToDoNestedInput
    topics?: TopicUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUpdateManyWithoutToDoNestedInput
    parent?: ToDoUpdateOneWithoutChildNestedInput
    child?: ToDoUpdateManyWithoutParentNestedInput
    ToDoList?: ToDoListUpdateOneWithoutTasksNestedInput
  }

  export type ToDoUncheckedUpdateWithoutAssociatedNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: TagUncheckedUpdateManyWithoutToDoNestedInput
    topics?: TopicUncheckedUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutToDoNestedInput
    child?: ToDoUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ToDoUncheckedUpdateManyWithoutAssociatedNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagUpdateWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TopicUpdateWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubjectUpdateWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutIpynbNotesInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BibEntryUpdateWithoutIpynbNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    Bib?: BibUpdateOneWithoutEntriesNestedInput
    citationGroups?: CitationsGroupUpdateManyWithoutEntriesNestedInput
    tags?: TagUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateWithoutIpynbNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
    citationGroups?: CitationsGroupUncheckedUpdateManyWithoutEntriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutBibEntriesNestedInput
    topics?: TopicUncheckedUpdateManyWithoutBibEntriesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBibEntriesNestedInput
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutCitationsNestedInput
    readingList?: ReadingListUncheckedUpdateManyWithoutBibEntriesNestedInput
  }

  export type BibEntryUncheckedUpdateManyWithoutIpynbNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    BibId?: NullableIntFieldUpdateOperationsInput | number | null
    OwnWork?: BoolFieldUpdateOperationsInput | boolean
    ColleaguesWork?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    htmlCitation?: NullableStringFieldUpdateOperationsInput | string | null
    PdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    annote?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    booktitle?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: NullableStringFieldUpdateOperationsInput | string | null
    crossref?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    howpublished?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    numpages?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    issn?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    urldate?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    added?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingListUpdateWithoutIpynbNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bibEntries?: BibEntryUpdateManyWithoutReadingListNestedInput
    mdxNotes?: MdxNoteUpdateManyWithoutReadingListNestedInput
  }

  export type ReadingListUncheckedUpdateWithoutIpynbNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    bibEntries?: BibEntryUncheckedUpdateManyWithoutReadingListNestedInput
    mdxNotes?: MdxNoteUncheckedUpdateManyWithoutReadingListNestedInput
  }

  export type ReadingListUncheckedUpdateManyWithoutIpynbNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToDoCreateManyToDoListInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    parentId?: number | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
  }

  export type ToDoUpdateWithoutToDoListInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    associatedNotes?: MdxNoteUpdateManyWithoutToDoNestedInput
    tags?: TagUpdateManyWithoutToDoNestedInput
    topics?: TopicUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUpdateManyWithoutToDoNestedInput
    parent?: ToDoUpdateOneWithoutChildNestedInput
    child?: ToDoUpdateManyWithoutParentNestedInput
  }

  export type ToDoUncheckedUpdateWithoutToDoListInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    associatedNotes?: MdxNoteUncheckedUpdateManyWithoutToDoNestedInput
    tags?: TagUncheckedUpdateManyWithoutToDoNestedInput
    topics?: TopicUncheckedUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutToDoNestedInput
    child?: ToDoUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ToDoUncheckedUpdateManyWithoutToDoListInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type TagUpdateWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TopicUpdateWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubjectUpdateWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutTodoListInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ToDoCreateManyParentInput = {
    id?: number
    createdAt?: Date | string
    task: string
    dueAt?: Date | string | null
    details?: string | null
    category?: $Enums.TaskCategory | null
    bookmarked?: boolean
    status?: $Enums.ToDoListStatus
    priority?: number
    toDoListId?: number | null
  }

  export type MdxNoteUpdateWithoutToDoInput = {
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUpdateManyWithoutMdxNotesNestedInput
    sequentialList?: SequentialNoteListUpdateOneWithoutMdxNoteNestedInput
    ReadingList?: ReadingListUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUpdateManyWithoutMdxNoteNestedInput
  }

  export type MdxNoteUncheckedUpdateWithoutToDoInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutMdxNotesNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutMdxNotesNestedInput
    tags?: TagUncheckedUpdateManyWithoutMdxNotesNestedInput
    citations?: BibEntryUncheckedUpdateManyWithoutMdxNotesNestedInput
    ReadingList?: ReadingListUncheckedUpdateManyWithoutMdxNotesNestedInput
    equations?: EquationUncheckedUpdateManyWithoutMdxNotesNestedInput
    definitions?: DefinitionUncheckedUpdateManyWithoutMdxNoteNestedInput
  }

  export type MdxNoteUncheckedUpdateManyWithoutToDoInput = {
    id?: IntFieldUpdateOperationsInput | number
    isProtected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dietSummaryKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    latexTitle?: NullableStringFieldUpdateOperationsInput | string | null
    rootRelativePath?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    formatted?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    citationsListOrder?: MdxNoteUpdatecitationsListOrderInput | string[]
    importantValues?: MdxNoteUpdateimportantValuesInput | number[]
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    href?: StringFieldUpdateOperationsInput | string
    sequentialKey?: NullableStringFieldUpdateOperationsInput | string | null
    sequentialIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    floatImages?: BoolFieldUpdateOperationsInput | boolean
    remoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trackRemote?: BoolFieldUpdateOperationsInput | boolean
    outgoingQuickLinks?: MdxNoteUpdateoutgoingQuickLinksInput | string[]
    quickLink?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    firstSync?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    Kanban?: KanbanUpdateOneWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TopicUpdateWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    Kanban?: KanbanUpdateOneWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubjectUpdateWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    Kanban?: KanbanUpdateOneWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutToDoInput = {
    value?: StringFieldUpdateOperationsInput | string
    kanbanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ToDoUpdateWithoutParentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    associatedNotes?: MdxNoteUpdateManyWithoutToDoNestedInput
    tags?: TagUpdateManyWithoutToDoNestedInput
    topics?: TopicUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUpdateManyWithoutToDoNestedInput
    child?: ToDoUpdateManyWithoutParentNestedInput
    ToDoList?: ToDoListUpdateOneWithoutTasksNestedInput
  }

  export type ToDoUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
    associatedNotes?: MdxNoteUncheckedUpdateManyWithoutToDoNestedInput
    tags?: TagUncheckedUpdateManyWithoutToDoNestedInput
    topics?: TopicUncheckedUpdateManyWithoutToDoNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutToDoNestedInput
    child?: ToDoUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ToDoUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableEnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory | null
    bookmarked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumToDoListStatusFieldUpdateOperationsInput | $Enums.ToDoListStatus
    priority?: IntFieldUpdateOperationsInput | number
    toDoListId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KanBanCardCreateManyKanBanListInput = {
    id?: number
    indexWithinList: number
    label?: string | null
    details?: string | null
  }

  export type KanBanCardUpdateWithoutKanBanListInput = {
    indexWithinList?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KanBanCardUncheckedUpdateWithoutKanBanListInput = {
    id?: IntFieldUpdateOperationsInput | number
    indexWithinList?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KanBanCardUncheckedUpdateManyWithoutKanBanListInput = {
    id?: IntFieldUpdateOperationsInput | number
    indexWithinList?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KanBanListCreateManyKanbanInput = {
    id?: number
    indexWithinBoard: number
    title?: string | null
  }

  export type TagCreateManyKanbanInput = {
    value: string
  }

  export type SubjectCreateManyKanbanInput = {
    value: string
  }

  export type TopicCreateManyKanbanInput = {
    value: string
  }

  export type KanBanListUpdateWithoutKanbanInput = {
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    cards?: KanBanCardUpdateManyWithoutKanBanListNestedInput
  }

  export type KanBanListUncheckedUpdateWithoutKanbanInput = {
    id?: IntFieldUpdateOperationsInput | number
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    cards?: KanBanCardUncheckedUpdateManyWithoutKanBanListNestedInput
  }

  export type KanBanListUncheckedUpdateManyWithoutKanbanInput = {
    id?: IntFieldUpdateOperationsInput | number
    indexWithinBoard?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUpdateWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTagsNestedInput
    equations?: EquationUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTagsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTagsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTagsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTagsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTagsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTagsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTagsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectUpdateWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutSubjectsNestedInput
    IpynbNotes?: IpynbUncheckedUpdateManyWithoutSubjectsNestedInput
    QaPair?: QAPairUncheckedUpdateManyWithoutSubjectsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutSubjectsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutSubjectsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutSubjectsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutSubjectsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUpdateWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUpdateManyWithoutTopicsNestedInput
    equations?: EquationUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
    MdxNotes?: MdxNoteUncheckedUpdateManyWithoutTopicsNestedInput
    ipynbNotes?: IpynbUncheckedUpdateManyWithoutTopicsNestedInput
    QAPair?: QAPairUncheckedUpdateManyWithoutTopicsNestedInput
    practiceExam?: PracticeExamUncheckedUpdateManyWithoutTopicsNestedInput
    toDo?: ToDoUncheckedUpdateManyWithoutTopicsNestedInput
    todoList?: ToDoListUncheckedUpdateManyWithoutTopicsNestedInput
    bibEntries?: BibEntryUncheckedUpdateManyWithoutTopicsNestedInput
    equations?: EquationUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutKanbanInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TimePeriodCreateManyDietInput = {
    id?: number
    start?: Date | string
    end?: Date | string | null
  }

  export type HealthReportCreateManyCurrentDietInput = {
    id?: number
    title?: string | null
    summary?: string | null
    overall?: number
    skin?: number
    bloat?: number
    weight_feeling?: number
    fullness?: number
    weight?: number | null
    cardiacCapacity?: number
    jawLine?: number
    joints?: number
    flexibility?: number
    anxiety?: number
    anxiety_desc?: string | null
    mood_desc?: string | null
    mood?: number
    sexDrive?: number
    intruisiveThoughts?: number
    caffeineIntake?: number
    glutenIntake?: number
    sugarIntake?: number
    artificialSweetenerIntake?: number
    artificalDyes?: number
    sleepQuality?: number
    hydration?: number
    twitching?: number
    sleepHours?: number | null
    calorie_est?: number | null
    times_meals_more_than_gap_apart?: number | null
    estHoursInExcessFast?: number | null
    created?: Date | string
  }

  export type DietaryItemUpdateWithoutDietInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
    Serving?: ServingUpdateManyWithoutItemNestedInput
  }

  export type DietaryItemUncheckedUpdateWithoutDietInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
    Serving?: ServingUncheckedUpdateManyWithoutItemNestedInput
  }

  export type DietaryItemUncheckedUpdateManyWithoutDietInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    gi?: NullableIntFieldUpdateOperationsInput | number | null
    calsPerOz?: NullableFloatFieldUpdateOperationsInput | number | null
    glutenFree?: BoolFieldUpdateOperationsInput | boolean
    minimalFructose?: BoolFieldUpdateOperationsInput | boolean
    natural?: BoolFieldUpdateOperationsInput | boolean
    organic?: BoolFieldUpdateOperationsInput | boolean
    impactScore?: FloatFieldUpdateOperationsInput | number
  }

  export type TimePeriodUpdateWithoutDietInput = {
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimePeriodUncheckedUpdateWithoutDietInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimePeriodUncheckedUpdateManyWithoutDietInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HealthReportUpdateWithoutCurrentDietInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    overall?: FloatFieldUpdateOperationsInput | number
    skin?: FloatFieldUpdateOperationsInput | number
    bloat?: FloatFieldUpdateOperationsInput | number
    weight_feeling?: FloatFieldUpdateOperationsInput | number
    fullness?: FloatFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cardiacCapacity?: FloatFieldUpdateOperationsInput | number
    jawLine?: FloatFieldUpdateOperationsInput | number
    joints?: FloatFieldUpdateOperationsInput | number
    flexibility?: FloatFieldUpdateOperationsInput | number
    anxiety?: FloatFieldUpdateOperationsInput | number
    anxiety_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: FloatFieldUpdateOperationsInput | number
    sexDrive?: FloatFieldUpdateOperationsInput | number
    intruisiveThoughts?: FloatFieldUpdateOperationsInput | number
    caffeineIntake?: FloatFieldUpdateOperationsInput | number
    glutenIntake?: FloatFieldUpdateOperationsInput | number
    sugarIntake?: FloatFieldUpdateOperationsInput | number
    artificialSweetenerIntake?: FloatFieldUpdateOperationsInput | number
    artificalDyes?: FloatFieldUpdateOperationsInput | number
    sleepQuality?: FloatFieldUpdateOperationsInput | number
    hydration?: FloatFieldUpdateOperationsInput | number
    twitching?: FloatFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    calorie_est?: NullableIntFieldUpdateOperationsInput | number | null
    times_meals_more_than_gap_apart?: NullableIntFieldUpdateOperationsInput | number | null
    estHoursInExcessFast?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthReportUncheckedUpdateWithoutCurrentDietInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    overall?: FloatFieldUpdateOperationsInput | number
    skin?: FloatFieldUpdateOperationsInput | number
    bloat?: FloatFieldUpdateOperationsInput | number
    weight_feeling?: FloatFieldUpdateOperationsInput | number
    fullness?: FloatFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cardiacCapacity?: FloatFieldUpdateOperationsInput | number
    jawLine?: FloatFieldUpdateOperationsInput | number
    joints?: FloatFieldUpdateOperationsInput | number
    flexibility?: FloatFieldUpdateOperationsInput | number
    anxiety?: FloatFieldUpdateOperationsInput | number
    anxiety_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: FloatFieldUpdateOperationsInput | number
    sexDrive?: FloatFieldUpdateOperationsInput | number
    intruisiveThoughts?: FloatFieldUpdateOperationsInput | number
    caffeineIntake?: FloatFieldUpdateOperationsInput | number
    glutenIntake?: FloatFieldUpdateOperationsInput | number
    sugarIntake?: FloatFieldUpdateOperationsInput | number
    artificialSweetenerIntake?: FloatFieldUpdateOperationsInput | number
    artificalDyes?: FloatFieldUpdateOperationsInput | number
    sleepQuality?: FloatFieldUpdateOperationsInput | number
    hydration?: FloatFieldUpdateOperationsInput | number
    twitching?: FloatFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    calorie_est?: NullableIntFieldUpdateOperationsInput | number | null
    times_meals_more_than_gap_apart?: NullableIntFieldUpdateOperationsInput | number | null
    estHoursInExcessFast?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthReportUncheckedUpdateManyWithoutCurrentDietInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    overall?: FloatFieldUpdateOperationsInput | number
    skin?: FloatFieldUpdateOperationsInput | number
    bloat?: FloatFieldUpdateOperationsInput | number
    weight_feeling?: FloatFieldUpdateOperationsInput | number
    fullness?: FloatFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cardiacCapacity?: FloatFieldUpdateOperationsInput | number
    jawLine?: FloatFieldUpdateOperationsInput | number
    joints?: FloatFieldUpdateOperationsInput | number
    flexibility?: FloatFieldUpdateOperationsInput | number
    anxiety?: FloatFieldUpdateOperationsInput | number
    anxiety_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood_desc?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: FloatFieldUpdateOperationsInput | number
    sexDrive?: FloatFieldUpdateOperationsInput | number
    intruisiveThoughts?: FloatFieldUpdateOperationsInput | number
    caffeineIntake?: FloatFieldUpdateOperationsInput | number
    glutenIntake?: FloatFieldUpdateOperationsInput | number
    sugarIntake?: FloatFieldUpdateOperationsInput | number
    artificialSweetenerIntake?: FloatFieldUpdateOperationsInput | number
    artificalDyes?: FloatFieldUpdateOperationsInput | number
    sleepQuality?: FloatFieldUpdateOperationsInput | number
    hydration?: FloatFieldUpdateOperationsInput | number
    twitching?: FloatFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    calorie_est?: NullableIntFieldUpdateOperationsInput | number | null
    times_meals_more_than_gap_apart?: NullableIntFieldUpdateOperationsInput | number | null
    estHoursInExcessFast?: NullableFloatFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServingCreateManyItemInput = {
    id?: number
    quant_oz?: number | null
    quant_guess?: $Enums.QUANTITY_GUESS | null
  }

  export type DietUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodsFollowed?: TimePeriodUpdateManyWithoutDietNestedInput
    HealthReport?: HealthReportUpdateManyWithoutCurrentDietNestedInput
  }

  export type DietUncheckedUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodsFollowed?: TimePeriodUncheckedUpdateManyWithoutDietNestedInput
    HealthReport?: HealthReportUncheckedUpdateManyWithoutCurrentDietNestedInput
  }

  export type DietUncheckedUpdateManyWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    activelyFollowing?: BoolFieldUpdateOperationsInput | boolean
    gf?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    vegan?: BoolFieldUpdateOperationsInput | boolean
    pescatarian?: BoolFieldUpdateOperationsInput | boolean
    vegetarian?: BoolFieldUpdateOperationsInput | boolean
    fasting?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    cardioTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    weightTraining?: EnumTERTIARY_TOGGLEFieldUpdateOperationsInput | $Enums.TERTIARY_TOGGLE
    carb?: NullableFloatFieldUpdateOperationsInput | number | null
    pro?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: DietUpdategoalsInput | $Enums.DIETARY_GOAL[]
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServingUpdateWithoutItemInput = {
    quant_oz?: NullableFloatFieldUpdateOperationsInput | number | null
    quant_guess?: NullableEnumQUANTITY_GUESSFieldUpdateOperationsInput | $Enums.QUANTITY_GUESS | null
  }

  export type ServingUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    quant_oz?: NullableFloatFieldUpdateOperationsInput | number | null
    quant_guess?: NullableEnumQUANTITY_GUESSFieldUpdateOperationsInput | $Enums.QUANTITY_GUESS | null
  }

  export type ServingUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    quant_oz?: NullableFloatFieldUpdateOperationsInput | number | null
    quant_guess?: NullableEnumQUANTITY_GUESSFieldUpdateOperationsInput | $Enums.QUANTITY_GUESS | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SubjectCountOutputTypeDefaultArgs instead
     */
    export type SubjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicCountOutputTypeDefaultArgs instead
     */
    export type TopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReadingListCountOutputTypeDefaultArgs instead
     */
    export type ReadingListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReadingListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BibEntryCountOutputTypeDefaultArgs instead
     */
    export type BibEntryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BibEntryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CitationsGroupCountOutputTypeDefaultArgs instead
     */
    export type CitationsGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CitationsGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BibCountOutputTypeDefaultArgs instead
     */
    export type BibCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BibCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelatedValuesCountOutputTypeDefaultArgs instead
     */
    export type RelatedValuesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelatedValuesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquationCountOutputTypeDefaultArgs instead
     */
    export type EquationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QAPairCountOutputTypeDefaultArgs instead
     */
    export type QAPairCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QAPairCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PracticeExamCountOutputTypeDefaultArgs instead
     */
    export type PracticeExamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PracticeExamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SequentialNoteListCountOutputTypeDefaultArgs instead
     */
    export type SequentialNoteListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SequentialNoteListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MdxNoteCountOutputTypeDefaultArgs instead
     */
    export type MdxNoteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MdxNoteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IpynbCountOutputTypeDefaultArgs instead
     */
    export type IpynbCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IpynbCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ToDoListCountOutputTypeDefaultArgs instead
     */
    export type ToDoListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ToDoListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ToDoCountOutputTypeDefaultArgs instead
     */
    export type ToDoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ToDoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KanBanListCountOutputTypeDefaultArgs instead
     */
    export type KanBanListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KanBanListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KanbanCountOutputTypeDefaultArgs instead
     */
    export type KanbanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KanbanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DietCountOutputTypeDefaultArgs instead
     */
    export type DietCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DietCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DietaryItemCountOutputTypeDefaultArgs instead
     */
    export type DietaryItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DietaryItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeatureRequestDefaultArgs instead
     */
    export type FeatureRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeatureRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaitlistRequestDefaultArgs instead
     */
    export type WaitlistRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaitlistRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubjectDefaultArgs instead
     */
    export type SubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicDefaultArgs instead
     */
    export type TopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteDefaultArgs instead
     */
    export type QuoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyFocusDefaultArgs instead
     */
    export type DailyFocusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyFocusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutoSettingDefaultArgs instead
     */
    export type AutoSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutoSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReadingListDefaultArgs instead
     */
    export type ReadingListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReadingListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BibEntryDefaultArgs instead
     */
    export type BibEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BibEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CitationsGroupDefaultArgs instead
     */
    export type CitationsGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CitationsGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BibDefaultArgs instead
     */
    export type BibArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BibDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoogleCalendarAuthDefaultArgs instead
     */
    export type GoogleCalendarAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoogleCalendarAuthDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SnippetDefaultArgs instead
     */
    export type SnippetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SnippetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelatedValuesDefaultArgs instead
     */
    export type RelatedValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelatedValuesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquationDefaultArgs instead
     */
    export type EquationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefinitionDefaultArgs instead
     */
    export type DefinitionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefinitionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingsDefaultArgs instead
     */
    export type SettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingsAppendixDefaultArgs instead
     */
    export type SettingsAppendixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingsAppendixDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RandomImageDefaultArgs instead
     */
    export type RandomImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RandomImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteTypeDefaultArgs instead
     */
    export type NoteTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QAPairDefaultArgs instead
     */
    export type QAPairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QAPairDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PracticeExamDefaultArgs instead
     */
    export type PracticeExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PracticeExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SequentialNoteListDefaultArgs instead
     */
    export type SequentialNoteListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SequentialNoteListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MdxNoteDefaultArgs instead
     */
    export type MdxNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MdxNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IpynbDefaultArgs instead
     */
    export type IpynbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IpynbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ToDoListDefaultArgs instead
     */
    export type ToDoListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ToDoListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ToDoDefaultArgs instead
     */
    export type ToDoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ToDoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KanBanCardDefaultArgs instead
     */
    export type KanBanCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KanBanCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KanBanListDefaultArgs instead
     */
    export type KanBanListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KanBanListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KanbanDefaultArgs instead
     */
    export type KanbanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KanbanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimePeriodDefaultArgs instead
     */
    export type TimePeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimePeriodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DietDefaultArgs instead
     */
    export type DietArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DietDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServingDefaultArgs instead
     */
    export type ServingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DietaryItemDefaultArgs instead
     */
    export type DietaryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DietaryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthReportDefaultArgs instead
     */
    export type HealthReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhiteboardDefaultArgs instead
     */
    export type WhiteboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhiteboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DJTDefaultArgs instead
     */
    export type DJTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DJTDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
