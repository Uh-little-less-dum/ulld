import { SupportedDatabaseType } from "@ulld/configschema/types";
import { ShellManager } from "./baseClasses/shell";
import { TargetPaths } from "./paths";
import dotenv from "dotenv";
import fs from "fs";
import path from "path";
import { FileManager } from "./baseClasses/fileManager";

type SupportedEnvVariableId =
    | "postgresUri"
    | "postgresNonPooling"
    | "databaseSchemaLocation"
    | "sqliteUri"
    | "additionalSources";

interface EnvItem {
    id: SupportedEnvVariableId;
    variable: string;
    value?: string | ((_paths: TargetPaths) => string);
}

let envItems: EnvItem[] = [
    {
        id: "postgresUri",
        value: process.env.ULLD_POSTGRES_URL,
        variable: "ULLD_POSTGRES_URL",
    },
    {
        id: "sqliteUri",
        value: process.env.ULLD_SQLITE_URL,
        variable: "ULLD_SQLITE_URL",
    },
    {
        id: "postgresNonPooling",
        value: process.env.ULLD_POSTGRES_URL_NON_POOLING,
        variable: "ULLD_POSTGRES_URL_NON_POOLING",
    },
    {
        id: "additionalSources",
        value: process.env.ULLD_ADDITIONAL_SOURCES,
        variable: "ULLD_ADDITIONAL_SOURCES",
    },
    {
        id: "databaseSchemaLocation",
        value: (p) => p.joinPath("projectRoot", "src/database/generated"),
        variable: "AUTOGENERATED_ULLD_DATABASE_CLIENT_PATH",
    },
];

export class EnvManager extends ShellManager {
    preferLocal: boolean = true;
    envItems: EnvItem[] = envItems;
    globalEnvFileContent?: string;
    globalEnvParedFileData?: object;
    globalEnvPath?: string;
    glovalEnvFileExists: boolean = false;
    constructor(public paths: TargetPaths) {
        super();
        let additionalSources = this.getEnvItemById("additionalSources");
        let additionalSourcesPath = this.getPathItem(additionalSources.value)
        if (additionalSourcesPath) {
            this.globalEnvPath = path.join(additionalSourcesPath, ".env");
            this.glovalEnvFileExists = fs.existsSync(this.globalEnvPath);
            if (this.glovalEnvFileExists) {
                this.globalEnvFileContent = fs.readFileSync(this.globalEnvPath, {
                    encoding: "utf-8",
                });
                this.globalEnvParedFileData = dotenv.parse(this.globalEnvFileContent);
            }
        }
        this.applyGlobalConfigOverrides();
    }
    getPathItem(p: EnvItem["value"]): string | undefined {
        return typeof p === "function" ? p(this.paths) : p
    }
    getDatabaseUriVariable(dbType: SupportedDatabaseType) {
        let dbTypeMap: Record<SupportedDatabaseType, SupportedEnvVariableId> = {
            postgres: "postgresUri",
            sqlite: "sqliteUri",
        };
        return this.getEnvItemById(dbTypeMap[dbType]);
    }
    hasVariable(id: SupportedEnvVariableId) {
        return Boolean(this.getEnvItemById(id).value);
    }
    applyGlobalConfigOverrides() {
        if (!this.globalEnvParedFileData) {
            return;
        }
        for (const variable in this.globalEnvParedFileData) {
            this.envItems = this.envItems.map((existingItem) => {
                let existingItemValue = this.getPathItem(existingItem.value)
                if (existingItem.variable !== variable) {
                    return existingItem;
                }
                if (this.preferLocal && Boolean(existingItemValue)) {
                    return existingItem;
                }
                return {
                    ...existingItem,
                    value:
                        this.globalEnvParedFileData?.[
                        variable as keyof typeof this.globalEnvParedFileData
                        ],
                };
            });
        }
    }
    toJson() {
        let d: Record<string, string> = {};
        for (const variable of this.envItems) {
            let val = this.getPathItem(variable.value)
            if (val) {
                d[variable.variable] = val
            }
        }
        return d;
    }
    writeEnvLocal() {
        let target = FileManager.fromPathKey("envLocal", this.paths);
        let json = this.toJson();
        let exists = target.exists();
        let data = exists
            ? {
                ...json,
                ...dotenv.parse(target.getContent()),
            }
            : json;
        let asString = "";
        for (const n in data) {
            asString += `${n}="${data[n]}"\n`;
        }
        target.writeContent(asString);
    }
    getEnvItemById(id: SupportedEnvVariableId) {
        let item = this.envItems.find((f) => f.id === id);
        if (!item) {
            throw new Error(
                `No env entry found for ${id}. This should not happen, even if the env variable is not present.`,
            );
        }
        return item;
    }
}
