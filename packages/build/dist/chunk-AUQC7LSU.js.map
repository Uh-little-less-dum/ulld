{"version":3,"sources":["../src/classes/additionalSources.ts"],"sourcesContent":["import { TargetPaths } from \"./paths.js\";\nimport {\n  type FileItemWithRootGlob,\n  getFlattenedFileItems,\n} from \"@ulld/utilities/additionalSources\";\nimport { globSync } from \"glob\";\nimport buildData from \"@ulld/utilities/buildStaticData.json\" with {type: \"json\"};\nimport fs from \"fs\";\nimport path from \"path\";\nimport { FileManager } from \"./baseClasses/fileManager.js\";\nimport { UlldGlob } from \"@ulld/utilities/glob\";\nimport { UlldAppConfigManager } from \"./appConfig.js\";\n\ninterface FoundItem extends FileItemWithRootGlob {\n  filePath: string;\n  type: \"file\";\n}\n\ninterface FoundDirContent extends FileItemWithRootGlob {\n  dirPath: string;\n  childPaths: string[];\n  type: \"dir\";\n}\n\ntype FoundVal = FoundItem | FoundDirContent;\n\ntype ItemData = {\n  /** Absolute path */\n  input: string;\n  /** Absolute path */\n  output: string;\n};\n\nexport class AdditionalSources {\n  sourcesDir?: string;\n  allowedRootDirItems: FileItemWithRootGlob[];\n  hasContent: boolean = false;\n  appendedCssPaths: string[] = [];\n  constructor(public paths: TargetPaths) {\n    this.sourcesDir = process.env.ULLD_ADDITIONAL_SOURCES;\n    this.hasContent = Boolean(this.sourcesDir);\n    this.allowedRootDirItems = getFlattenedFileItems();\n  }\n  getAppConfig() {\n    if (!this.hasContent || !this.sourcesDir) {\n      return;\n    }\n    let file = FileManager.fromAbsolutePath(\n      path.join(this.sourcesDir, \"appConfig.ulld.json\"),\n      this.paths,\n      false,\n    );\n    if (file.exists()) {\n      return new UlldAppConfigManager(\n        this.paths.projectRoot,\n        false,\n        this.paths,\n      );\n    }\n  }\n  private validateSearch(search: string): {\n    search: string;\n    ignore?: string[];\n  } {\n    if (search === \"<NOT_EXISTING_PUBLIC_DIR>\") {\n      return {\n        search: \"*/**\",\n        ignore: buildData.reservedPublicDirs.map((p) => `/${p}**`),\n      };\n    }\n    return {\n      search,\n    };\n  }\n  private glob(search: string, includeDirectories: boolean = true) {\n    let s = this.validateSearch(search);\n    let vals = globSync(s.search, {\n      cwd: this.sourcesDir,\n      ignore: s.ignore,\n    });\n    if (includeDirectories) {\n      return vals;\n    }\n    return vals.filter((f) =>\n      fs.statSync(path.join(this.sourcesDir!, f)).isFile(),\n    );\n  }\n  private getItemData(\n    item: FileItemWithRootGlob,\n  ): FoundItem[] | FoundDirContent[] | undefined {\n    let files = this.glob(item.rootGlob, false);\n    if (item.validate) {\n      if (!item.validate(files)) {\n        return;\n      }\n    }\n    if (item.includeDirContents && files.length) {\n      if (!item.dirPath) {\n        throw new Error(\n          `Attempted to gather directory contents without a provided dirPath.`,\n        );\n      }\n      return [\n        {\n          ...item,\n          type: \"dir\",\n          dirPath: item.dirPath,\n          childPaths: files,\n        },\n      ];\n    }\n    if (item.allowMultiple) {\n      return files.map((f) => ({\n        ...item,\n        type: \"file\",\n        filePath: f,\n      }));\n    }\n    if (files.length === 1) {\n      return [\n        {\n          ...item,\n          type: \"file\",\n          filePath: files[0],\n        },\n      ];\n    }\n  }\n  private getPaths(item: FoundVal): ItemData[] {\n    let itemData: ItemData[] = [];\n    let items: string[] =\n      item.type === \"dir\" ? item.childPaths : [item.filePath];\n    for (const d of items) {\n      itemData.push({\n        input: path.join(this.sourcesDir!, d),\n        output: path.join(this.paths.projectRoot, (item as any).getOutputPath(d)),\n      });\n    }\n    return itemData;\n  }\n  private getItems() {\n    let items: FoundVal[] = [];\n    for (const f of this.allowedRootDirItems) {\n      let x = this.getItemData(f);\n      if (x) {\n        items = items.concat(x);\n      }\n    }\n    return items;\n  }\n  private copyPath(item: ItemData) {\n    const f = FileManager.fromAbsolutePath(item.input, this.paths, false);\n    f.copyToFile(item.output);\n  }\n  private generateIndexScssFile() {\n    let glob = new UlldGlob(this.paths.userDefinedStyles);\n    let files = glob.glob(\"**/*.scss\");\n    let importString = files\n      .map((f) => {\n        let s = path.relative(this.paths.unifiedUserDefinedScss, f);\n        return `@use \"${s.slice(0, s.lastIndexOf(\".\"))}\";`;\n      })\n      .join(\"\\n\");\n    let outputFile = FileManager.fromAbsolutePath(\n      this.paths.unifiedUserDefinedScss,\n      this.paths,\n      false,\n    );\n    outputFile.writeContent(importString);\n  }\n  write() {\n    if (!this.sourcesDir) {\n      return;\n    }\n    const items = this.getItems();\n    for (const foundVal of items) {\n      let pathData = this.getPaths(foundVal);\n      for (const itemData of pathData) {\n        this.copyPath(itemData);\n      }\n    }\n    this.generateIndexScssFile();\n  }\n}\n"],"mappings":"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","names":[]}