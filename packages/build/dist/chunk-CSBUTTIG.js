import {
  FileManager
} from "./chunk-ZUXBWQVK.js";
import {
  ShellManager
} from "./chunk-2NXHCBFZ.js";
import {
  init_esm_shims
} from "./chunk-ZRREZ4KQ.js";

// src/classes/envManager.ts
init_esm_shims();
import dotenv from "dotenv";
import fs from "fs";
import path from "path";
var envItems = [
  {
    id: "postgresUri",
    value: process.env.ULLD_POSTGRES_URL,
    variable: "ULLD_POSTGRES_URL"
  },
  {
    id: "sqliteUri",
    value: process.env.ULLD_SQLITE_URL,
    variable: "ULLD_SQLITE_URL"
  },
  {
    id: "postgresNonPooling",
    value: process.env.ULLD_POSTGRES_URL_NON_POOLING,
    variable: "ULLD_POSTGRES_URL_NON_POOLING"
  },
  {
    id: "additionalSources",
    value: process.env.ULLD_ADDITIONAL_SOURCES,
    variable: "ULLD_ADDITIONAL_SOURCES"
  },
  {
    id: "databaseSchemaLocation",
    value: (p) => p.joinPath("projectRoot", "src/database/generated"),
    variable: "AUTOGENERATED_ULLD_DATABASE_CLIENT_PATH"
  }
];
var EnvManager = class extends ShellManager {
  constructor(paths) {
    super();
    this.paths = paths;
    let additionalSources = this.getEnvItemById("additionalSources");
    let additionalSourcesPath = this.getPathItem(additionalSources.value);
    if (additionalSourcesPath) {
      this.globalEnvPath = path.join(additionalSourcesPath, ".env");
      this.glovalEnvFileExists = fs.existsSync(this.globalEnvPath);
      if (this.glovalEnvFileExists) {
        this.globalEnvFileContent = fs.readFileSync(this.globalEnvPath, {
          encoding: "utf-8"
        });
        this.globalEnvParedFileData = dotenv.parse(this.globalEnvFileContent);
      }
    }
    this.applyGlobalConfigOverrides();
  }
  preferLocal = true;
  envItems = envItems;
  globalEnvFileContent;
  globalEnvParedFileData;
  globalEnvPath;
  glovalEnvFileExists = false;
  getPathItem(p) {
    return typeof p === "function" ? p(this.paths) : p;
  }
  getDatabaseUriVariable(dbType) {
    let dbTypeMap = {
      postgres: "postgresUri",
      sqlite: "sqliteUri"
    };
    return this.getEnvItemById(dbTypeMap[dbType]);
  }
  hasVariable(id) {
    return Boolean(this.getEnvItemById(id).value);
  }
  applyGlobalConfigOverrides() {
    if (!this.globalEnvParedFileData) {
      return;
    }
    for (const variable in this.globalEnvParedFileData) {
      this.envItems = this.envItems.map((existingItem) => {
        let existingItemValue = this.getPathItem(existingItem.value);
        if (existingItem.variable !== variable) {
          return existingItem;
        }
        if (this.preferLocal && Boolean(existingItemValue)) {
          return existingItem;
        }
        return {
          ...existingItem,
          value: this.globalEnvParedFileData?.[variable]
        };
      });
    }
  }
  toJson() {
    let d = {};
    for (const variable of this.envItems) {
      let val = this.getPathItem(variable.value);
      if (val) {
        d[variable.variable] = val;
      }
    }
    return d;
  }
  writeEnvLocal() {
    this.logVerbose("Writing env file...");
    let target = FileManager.fromPathKey("envLocal", this.paths);
    let json = this.toJson();
    let exists = target.exists();
    let data = exists ? {
      ...json,
      ...dotenv.parse(target.getContent())
    } : json;
    let asString = "";
    for (const n in data) {
      asString += `${n}="${data[n]}"
`;
    }
    target.writeContent(asString);
  }
  getEnvItemById(id) {
    let item = this.envItems.find((f) => f.id === id);
    if (!item) {
      throw new Error(
        `No env entry found for ${id}. This should not happen, even if the env variable is not present.`
      );
    }
    return item;
  }
};

export {
  EnvManager
};
//# sourceMappingURL=chunk-CSBUTTIG.js.map