{"version":3,"sources":["../src/classes/envManager.ts"],"sourcesContent":["import dotenv from \"dotenv\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { ShellManager } from \"./baseClasses/shell.js\";\nimport { TargetPaths } from \"./paths.js\";\nimport { FileManager } from \"./baseClasses/fileManager.js\";\nimport { AppConfigSchemaOutput } from \"@ulld/configschema/zod/main\";\n\n\ntype SupportedDatabaseType = AppConfigSchemaOutput[\"build\"][\"database\"][\"type\"]\n\ntype SupportedEnvVariableId =\n    | \"postgresUri\"\n    | \"postgresNonPooling\"\n    | \"databaseSchemaLocation\"\n    | \"sqliteUri\"\n    | \"additionalSources\";\n\ninterface EnvItem {\n    id: SupportedEnvVariableId;\n    variable: string;\n    value?: string | ((_paths: TargetPaths) => string);\n}\n\nlet envItems: EnvItem[] = [\n    {\n        id: \"postgresUri\",\n        value: process.env.ULLD_POSTGRES_URL,\n        variable: \"ULLD_POSTGRES_URL\",\n    },\n    {\n        id: \"sqliteUri\",\n        value: process.env.ULLD_SQLITE_URL,\n        variable: \"ULLD_SQLITE_URL\",\n    },\n    {\n        id: \"postgresNonPooling\",\n        value: process.env.ULLD_POSTGRES_URL_NON_POOLING,\n        variable: \"ULLD_POSTGRES_URL_NON_POOLING\",\n    },\n    {\n        id: \"additionalSources\",\n        value: process.env.ULLD_ADDITIONAL_SOURCES,\n        variable: \"ULLD_ADDITIONAL_SOURCES\",\n    },\n    {\n        id: \"databaseSchemaLocation\",\n        value: (p) => p.joinPath(\"projectRoot\", \"src/database/generated\"),\n        variable: \"AUTOGENERATED_ULLD_DATABASE_CLIENT_PATH\",\n    },\n];\n\nexport class EnvManager extends ShellManager {\n    preferLocal: boolean = true;\n    envItems: EnvItem[] = envItems;\n    globalEnvFileContent?: string;\n    globalEnvParedFileData?: object;\n    globalEnvPath?: string;\n    glovalEnvFileExists: boolean = false;\n    constructor(public paths: TargetPaths) {\n        super();\n        let additionalSources = this.getEnvItemById(\"additionalSources\");\n        let additionalSourcesPath = this.getPathItem(additionalSources.value)\n        if (additionalSourcesPath) {\n            this.globalEnvPath = path.join(additionalSourcesPath, \".env\");\n            this.glovalEnvFileExists = fs.existsSync(this.globalEnvPath);\n            if (this.glovalEnvFileExists) {\n                this.globalEnvFileContent = fs.readFileSync(this.globalEnvPath, {\n                    encoding: \"utf-8\",\n                });\n                this.globalEnvParedFileData = dotenv.parse(this.globalEnvFileContent);\n            }\n        }\n        this.applyGlobalConfigOverrides();\n    }\n    getPathItem(p: EnvItem[\"value\"]): string | undefined {\n        return typeof p === \"function\" ? p(this.paths) : p\n    }\n    getDatabaseUriVariable(dbType: SupportedDatabaseType) {\n        let dbTypeMap: Record<SupportedDatabaseType, SupportedEnvVariableId> = {\n            postgres: \"postgresUri\",\n            sqlite: \"sqliteUri\",\n        };\n        return this.getEnvItemById(dbTypeMap[dbType]);\n    }\n    hasVariable(id: SupportedEnvVariableId) {\n        return Boolean(this.getEnvItemById(id).value);\n    }\n    applyGlobalConfigOverrides() {\n        if (!this.globalEnvParedFileData) {\n            return;\n        }\n        for (const variable in this.globalEnvParedFileData) {\n            this.envItems = this.envItems.map((existingItem) => {\n                let existingItemValue = this.getPathItem(existingItem.value)\n                if (existingItem.variable !== variable) {\n                    return existingItem;\n                }\n                if (this.preferLocal && Boolean(existingItemValue)) {\n                    return existingItem;\n                }\n                return {\n                    ...existingItem,\n                    value:\n                        this.globalEnvParedFileData?.[\n                        variable as keyof typeof this.globalEnvParedFileData\n                        ],\n                };\n            });\n        }\n    }\n    toJson() {\n        let d: Record<string, string> = {};\n        for (const variable of this.envItems) {\n            let val = this.getPathItem(variable.value)\n            if (val) {\n                d[variable.variable] = val\n            }\n        }\n        return d;\n    }\n    writeEnvLocal() {\n        this.logVerbose(\"Writing env file...\")\n        let target = FileManager.fromPathKey(\"envLocal\", this.paths);\n        let json = this.toJson();\n        let exists = target.exists();\n        let data = exists\n            ? {\n                ...json,\n                ...dotenv.parse(target.getContent()),\n            }\n            : json;\n        let asString = \"\";\n        for (const n in data) {\n            asString += `${n}=\"${data[n]}\"\\n`;\n        }\n        target.writeContent(asString);\n    }\n    getEnvItemById(id: SupportedEnvVariableId) {\n        let item = this.envItems.find((f) => f.id === id);\n        if (!item) {\n            throw new Error(\n                `No env entry found for ${id}. This should not happen, even if the env variable is not present.`,\n            );\n        }\n        return item;\n    }\n}\n"],"mappings":"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","names":[]}