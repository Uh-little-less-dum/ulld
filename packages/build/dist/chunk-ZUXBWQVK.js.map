{"version":3,"sources":["../src/classes/baseClasses/fileManager.ts"],"sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport { TargetPaths } from \"../paths.js\";\nimport { ShellManager } from \"./shell.js\";\nimport type { TargetPathKeys } from \"@ulld/utilities/buildTypes\";\n\ninterface LineItem {\n    content: string;\n    index: number;\n    appendLine?: boolean;\n}\n\nexport class FileManager extends ShellManager {\n    content?: string;\n    asJson: boolean;\n    path: string;\n    dirname: string;\n    DO_NOT_WRITE_FILE_CONTENT: boolean = process.env.ULLD_INTERNAL_DEVELOPMENT === \"true\";\n    constructor(\n        public subPath: string,\n        public paths: TargetPaths,\n        isDir?: boolean\n    ) {\n        super();  \n        this.path = path.join(paths.projectRoot, subPath);\n        this.dirname = this.getDirname(isDir)\n        this.asJson = this.subPath.endsWith(\".json\");\n    }\n    getStat(){\n        return fs.statSync(this.path)\n    }\n    isDir(){\n       let s = this.getStat() \n        return Boolean(s?.isDirectory())\n    }\n    getDirname(isDir?: boolean){\n        let _isDir = typeof isDir === \"boolean\" ? isDir : this.isDir()\n        if(_isDir){\n            return this.path\n        } \n        return path.dirname(this.path)\n    }\n    setPath(newPath: string, isDir?: boolean) {\n        this.path = newPath;\n        this.dirname = this.getDirname(isDir)\n    }\n    mkdirIfNotExists() {\n        if (!fs.existsSync(this.dirname)) {\n            fs.mkdirSync(this.dirname, { recursive: true });\n        }\n    }\n    writeContent(content?: string) {\n        console.log(`Writing content to ${this.subPath}`)\n        let newContent = content || this.content;\n        if (!newContent) {\n            return this.logDebug(\n                `Not writing file content to ${this.subPath}. No content was read from file and none was provided.`,\n            );\n        }\n        if (this.DO_NOT_WRITE_FILE_CONTENT) {\n            this.log(`\n--- Begin File ---\n\n${newContent}\n\n--- End File ---\n`);\n        } else {\n            this.mkdirIfNotExists()\n            this.logVerbose(`Writing content to ${this.path}`);\n            fs.writeFileSync(this.path, newContent, { encoding: \"utf-8\" });\n        }\n    }\n    exists() {\n        return fs.existsSync(this.path);\n    }\n    throwIfNotExists() {\n        let exists = this.exists();\n        if (!exists) {\n            this.logError(`No file exists at ${this.subPath}. Aborting.`)\n            throw new Error(`No file exists at ${this.subPath}. Aborting.`);\n        }\n    }\n    getAsJson() {\n        return JSON.parse(this.getContent());\n    }\n    replaceLinesByIndex(lineItems: LineItem[]) {\n        let lines = this.getLines();\n        for (const k of lineItems) {\n            if (k.appendLine) {\n                lines = [\n                    ...lines.slice(0, k.index + 1),\n                    k.content,\n                    ...lines.slice(k.index + 1),\n                ];\n            } else {\n                lines[k.index] = k.content;\n            }\n        }\n        this.content = lines.join(\"\\n\");\n    }\n    getContent() {\n        if (this.content) return this.content;\n        let data = fs.readFileSync(this.path, { encoding: \"utf-8\" });\n        this.content = data;\n        return data;\n    }\n    copyToFile(path: string, throwIfNotExists: boolean = false){\n        let content = this.getContent()\n        const output = FileManager.fromAbsolutePath(path, this.paths, false)\n        if(throwIfNotExists){\n            output.throwIfNotExists()\n        }\n        output.writeContent(content)\n        this.logVerbose(`Copied ${this.path} to ${output.path}`)\n    }\n    getLines() {\n        return this.getContent().split(\"\\n\");\n    }\n    filterLines(cb: (lineContent: string) => boolean) {\n        let lines = this.getLines().filter((l) => cb(l));\n        this.content = lines.join(\"\\n\");\n    }\n    getImportLines() {\n        let lines = this.getLines();\n        let lineData: LineItem[] = [];\n        lines.forEach((l, i) => {\n            let trimmed = l.trim()\n            if (trimmed.startsWith(\"import\")) {\n                lineData.push({ content: trimmed, index: i });\n            }\n        });\n        return lineData;\n    }\n    static fromPathKey(pathKey: TargetPathKeys, paths: TargetPaths) {\n        const path = paths[pathKey as keyof typeof paths] as string;\n        return new FileManager(paths.makeSubPath(path), paths);\n    }\n    static fromAbsolutePath(path: string, paths: TargetPaths, isDir?: boolean) {\n        let item = new FileManager(\"\", paths, isDir);\n        item.setPath(path, isDir)\n        return item;\n    }\n}\n"],"mappings":"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","names":["path"]}