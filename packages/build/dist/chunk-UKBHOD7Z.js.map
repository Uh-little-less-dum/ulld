{"version":3,"sources":["../src/utils/slotMapUtils.ts"],"sourcesContent":["import fullSlotMap from \"@ulld/utilities/slotMap.json\"  with {type: \"json\"};\nimport type {SlotMapOfType} from \"@ulld/configschema/slotMapInternalType\"\nimport type { AnySubSlotKey, PluginSlotKey } from \"@ulld/configschema/slotMapType\";\n\nexport const walkSlotMap = <T extends unknown, J extends unknown>(\n    slotMap: SlotMapOfType<T>,\n    getData: (val: T, slot: PluginSlotKey, subSlot: AnySubSlotKey) => J,\n) => {\n    let s: SlotMapOfType<J> = {} as SlotMapOfType<J>;\n    for (const k in slotMap) {\n        for (const l in slotMap[k as keyof typeof slotMap]) {\n            if (!s[k as PluginSlotKey]) {\n                s[k as PluginSlotKey] = {} as any;\n            }\n            /* @ts-ignore */\n            s[k as keyof typeof s][l as any] = getData(slotMap[k as keyof typeof slotMap][l as any] as T, k as PluginSlotKey, l as AnySubSlotKey)\n        }\n    }\n    return s\n};\n\ntype FlattenedSlotMap<T extends unknown> = {slot: PluginSlotKey, subSlot: AnySubSlotKey, data: T}[]\n\nexport const flattenSlotMap = <T extends unknown>(slotMap: SlotMapOfType<T>): FlattenedSlotMap<T> => {\n    let d: FlattenedSlotMap<T> = []\n    for (const k in slotMap) {\n        for (const l in slotMap[k as keyof typeof slotMap]) {\n           d.push({\n                slot: k as PluginSlotKey,\n                subSlot: l as AnySubSlotKey,\n                /* @ts-ignore */\n                data: slotMap[k as keyof typeof slotMap][l as any] as T\n            }) \n        }\n    }\n    return d\n}\n\n\nexport const forceFullSlotMap = <T extends unknown, J extends unknown>(slotMap: SlotMapOfType<T>, defaultValue: J = false as any): SlotMapOfType<T | J> => {\n\n    /* @ts-ignore */\n    return walkSlotMap(fullSlotMap, (val, slot, subSlot) => slotMap[slot]?.[subSlot] ? slotMap[slot][subSlot] : defaultValue) as SlotMapOfType<T | J>\n}\n\n\nexport const generateSlotMapOfType = <T extends unknown>(cb: (slot: PluginSlotKey, subSlot: AnySubSlotKey) => T): SlotMapOfType<T> => {\n    let d: SlotMapOfType<T> = {} as SlotMapOfType<T>\n\n    for (const slot in fullSlotMap) {\n        for (const subSlot in fullSlotMap[slot as keyof typeof fullSlotMap]) {\n           if(!d[slot as keyof typeof d]){\n                d[slot as keyof typeof d] = {} as any\n            } \n            /* @ts-ignore */\n            d[slot as keyof typeof d][subSlot as any] = cb(slot as PluginSlotKey, subSlot as AnySubSlotKey)\n        }\n    }\n    return d\n}\n\n\nexport const getSlotMapData = <T extends PluginSlotKey>(parentSlot: T, subSlot: keyof typeof fullSlotMap[T]) => {\n    return fullSlotMap[parentSlot][subSlot]\n}\n"],"mappings":";;;;;AAAA;AAAA,OAAO,iBAAiB;AAIjB,IAAM,cAAc,CACvB,SACA,YACC;AACD,MAAI,IAAsB,CAAC;AAC3B,aAAW,KAAK,SAAS;AACrB,eAAW,KAAK,QAAQ,CAAyB,GAAG;AAChD,UAAI,CAAC,EAAE,CAAkB,GAAG;AACxB,UAAE,CAAkB,IAAI,CAAC;AAAA,MAC7B;AAEA,QAAE,CAAmB,EAAE,CAAQ,IAAI,QAAQ,QAAQ,CAAyB,EAAE,CAAQ,GAAQ,GAAoB,CAAkB;AAAA,IACxI;AAAA,EACJ;AACA,SAAO;AACX;AAIO,IAAM,iBAAiB,CAAoB,YAAmD;AACjG,MAAI,IAAyB,CAAC;AAC9B,aAAW,KAAK,SAAS;AACrB,eAAW,KAAK,QAAQ,CAAyB,GAAG;AACjD,QAAE,KAAK;AAAA,QACF,MAAM;AAAA,QACN,SAAS;AAAA;AAAA,QAET,MAAM,QAAQ,CAAyB,EAAE,CAAQ;AAAA,MACrD,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;AAGO,IAAM,mBAAmB,CAAuC,SAA2B,eAAkB,UAAuC;AAGvJ,SAAO,YAAY,aAAa,CAAC,KAAK,MAAM,YAAY,QAAQ,IAAI,IAAI,OAAO,IAAI,QAAQ,IAAI,EAAE,OAAO,IAAI,YAAY;AAC5H;AAGO,IAAM,wBAAwB,CAAoB,OAA6E;AAClI,MAAI,IAAsB,CAAC;AAE3B,aAAW,QAAQ,aAAa;AAC5B,eAAW,WAAW,YAAY,IAAgC,GAAG;AAClE,UAAG,CAAC,EAAE,IAAsB,GAAE;AACzB,UAAE,IAAsB,IAAI,CAAC;AAAA,MACjC;AAEA,QAAE,IAAsB,EAAE,OAAc,IAAI,GAAG,MAAuB,OAAwB;AAAA,IAClG;AAAA,EACJ;AACA,SAAO;AACX;AAGO,IAAM,iBAAiB,CAA0B,YAAe,YAAyC;AAC5G,SAAO,YAAY,UAAU,EAAE,OAAO;AAC1C;","names":[]}