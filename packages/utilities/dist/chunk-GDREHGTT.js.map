{"version":3,"sources":["../src/utils/stringUtils.ts"],"names":[],"mappings":";;;;;AACA,OAAO,cAAc;AAEd,IAAM,aAAa,CAAC,QACvB,GAAG,IAAI,CAAC,EAAE,YAAY,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC;AAGnC,IAAM,YAAY,CAAC,QAAgB;AACtC,SAAO,IACF,WAAW,WAAW,GAAG,EACzB,MAAM,GAAG,EACT,IAAI,CAAC,GAAG,MAAO,MAAM,IAAI,EAAE,YAAY,IAAI,WAAW,CAAC,CAAE,EACzD,KAAK,EAAE;AAChB;AAGO,IAAM,mBAAmB,CAAC,SAAiB;AAC3C,SAAO,KAAK,SAAS,GAAG,IAAI,KAAK,MAAM,KAAK,YAAY,GAAG,CAAC,IAAI;AACnE;AAGG,IAAM,mBAAmB,CAAC,SAAiB;AAC9C,MAAI,MAAM,iBAAiB,IAAI;AAC/B,SAAO,QAAQ,OAAO,IAAI,SAAS,KAAK,IAAI,UAAU,CAAC;AAC3D;AAEO,IAAM,kBAAkB,CAAC,MAAc,cAA4B;AACtE,SAAO,iBAAiB,IAAI,IAAI,OAAO,GAAG,IAAI,GAAG,SAAS;AAC9D;AAGO,IAAM,wBAAwB,CAAC,OAAe;AACjD,MAAI,IAAI,GAAG,KAAK;AAChB,MACI,EAAE,WAAW,IAAI,KACjB,EAAE,SAAS,IAAI,KACf,mBAAmB,GAAG,QAAQ,EAAE,WAAW,GAC7C;AACE,WAAO,EAAE,WAAW,MAAM,EAAE,EAAE,KAAK;AAAA,EACvC;AACA,MACI,EAAE,WAAW,GAAG,KAChB,EAAE,SAAS,GAAG,KACd,mBAAmB,GAAG,MAAM,EAAE,WAAW,GAC3C;AACE,WAAO,EAAE,WAAW,KAAK,EAAE,EAAE,KAAK;AAAA,EACtC;AACA,SAAO;AACX;AAGO,IAAM,0BAA0B,CAAC,cAAsB,MAAgB,gBAAyB,UAAU;AAC7G,SAAO,KAAK,IAAI,CAAC,OAAO;AAAA;AAAA,IAEpB,YAAY,SAAS,cAAc,GAAG;AAAA,MAClC;AAAA,IACJ,CAAC;AAAA,IACD,OAAO;AAAA,EACX,EAAE,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,aAAa,EAAE,aAAa,IAAI,EAAE,aAAa,EAAE,aAAa,KAAK,CAAC;AAC7F;AAGO,IAAM,uBAAuB,CAAC,cAAsB,MAAgB,gBAAyB,UAAU;AACvG,SAAO,wBAAwB,cAAc,MAAM,aAAa,EAAE,CAAC,EAAE;AAC5E","sourcesContent":["import { getAllRegexMatches } from \"./getAllRegexMatches.js\";\nimport distance from \"jaro-winkler\"\n\nexport const capitalize = (val: string) =>\n    `${val[0].toUpperCase()}${val.slice(1)}`;\n\n\nexport const camelCase = (val: string) => {\n    return val\n        .replaceAll(/\\-|\\_/gm, \" \")\n        .split(\" \")\n        .map((l, i) => (i === 0 ? l.toLowerCase() : capitalize(l)))\n        .join(\"\");\n};\n\n\nexport const getFileExtension = (path: string) => {\n       return path.includes(\".\") ? path.slice(path.lastIndexOf(\".\")) : undefined\n    }\n\n// TODO: Improve this method. Create a server only variant and use the path node module.\nexport const pathHasExtension = (path: string) => {\n    let ext = getFileExtension(path)\n    return Boolean(ext && ext.length > 0 && ext.length <= 4)\n}\n\nexport const applyFileSuffix = (path: string, extension: `.${string}`) => {\n    return pathHasExtension(path) ? path : `${path}${extension}`;\n};\n\n\nexport const removeMathDollarSigns = (_s: string) => {\n    let s = _s.trim();\n    if (\n        s.startsWith(\"$$\") &&\n        s.endsWith(\"$$\") &&\n        getAllRegexMatches(s, /\\$\\$/gm).length === 2\n    ) {\n        return s.replaceAll(\"$$\", \"\").trim()\n    }\n    if(\n        s.startsWith(\"$\") &&\n        s.endsWith(\"$\") &&\n        getAllRegexMatches(s, /\\$/gm).length === 2\n    ) {\n        return s.replaceAll(\"$\", \"\").trim()\n    }\n    return s\n};\n\n\nexport const sortStringsBySimilarity = (searchString: string, opts: string[], caseSensitive: boolean = false) => {\n    return opts.map((x) => ({\n        /* @ts-ignore */\n        similarity: distance(searchString, x, {\n            caseSensitive\n        }),\n        value: x\n    })).sort((a, b) => a.similarity < b.similarity ? 1 : a.similarity > b.similarity ? -1 : 0)\n}\n\n\nexport const getMostSimilarString = (searchString: string, opts: string[], caseSensitive: boolean = false) => {\n       return sortStringsBySimilarity(searchString, opts, caseSensitive)[0].value\n}\n"]}