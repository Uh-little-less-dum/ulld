{"version":3,"sources":["../../src/navigation/getTocFromContent.ts","../../src/additionalParsers/mdx/getContentHeadings.ts"],"names":[],"mappings":";AAAA,SAAS,0BAAuC;;;ACEhD,IAAM,iBAAiB,CAAC,MAAc;AAClC,MAAI,EAAE,SAAS,IAAI,KAAK,EAAE,SAAS,GAAG,GAAG;AACrC,WAAO,EAAE,MAAM,GAAG,EAAE,YAAY,GAAG,CAAC;AAAA,EACxC;AACA,SAAO;AACX;AAEA,IAAM,sBAAsB,CAAC,MAAsB;AAC/C,MAAI,EAAE,WAAW,GAAG,GAAG;AACnB,WAAO,oBAAoB,EAAE,MAAM,CAAC,CAAC;AAAA,EACzC;AACA,SAAO;AACX;AAEA,IAAM,sCAAsC,CAAC,MAAc;AACvD,MAAI,KAAK;AACT,SAAO,EAAE,QAAQ,IAAI,MAAM;AAC/B;AAEA,IAAM,qBAAqB,CAAC,MAAc;AACtC,SAAO,EAAE,WAAW,KAAK,EAAE;AAC/B;AAEA,IAAM,QAAmC;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAMO,IAAM,qBAAqB,CAAC,MAAc;AAC7C,MAAI,MAAM;AACV,aAAW,KAAK,OAAO;AACnB,UAAM,EAAE,GAAG;AAAA,EACf;AACA,SAAO;AACX;;;ADnCO,IAAM,qBAAqB,CAC9B,MAAqB,CAAC,GACtB,YACC;AACD,MAAI,SAAS,QAAQ,MAAM,IAAI,EAAE,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,WAAW,GAAG,CAAC;AACvE,MAAI,IAAoB,CAAC;AACzB,MAAI,IAAI,WAAW,OAAO,QAAQ;AAC9B,YAAQ;AAAA,MACJ,uDAAuD,IAAI,MAAM,2BAA2B,OAAO,MAAM;AAAA,IAC7G;AAAA,EACJ;AACA,MAAI,QAAQ,CAAC,OAAO,MAAM;AACtB,UAAM,WAAW,OAAO,CAAC,EAAE,KAAK;AAChC,MAAE,KAAK;AAAA,MACH,GAAG;AAAA,MACH,OAAO,mBAAmB,QAAQ;AAAA;AAAA;AAAA;AAAA,IAItC,CAAC;AAAA,EACL,CAAC;AACD,SAAO;AACX;AAMO,IAAM,oBAAoB,OAAO,YAAoB;AACxD,MAAI,WAAW,MAAM,mBAAmB,OAAO;AAC/C,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ","sourcesContent":["import { getTableOfContents, TOCItemType } from 'fumadocs-core/server';\nimport { parseMarkdownTitle } from '../additionalParsers/mdx/getContentHeadings.js';\n\n\nexport type { TOCItemType }\n\n\nexport const getLatexTocEntries = (\n    toc: TOCItemType[] = [],\n    content: string,\n) => { \n    let titles = content.split(\"\\n\").filter((f) => f.trim().startsWith(\"#\"));\n    let t: TOCItemType[]  = [];\n    if (toc.length !== titles.length) {\n        console.error(\n            `Found different lengths for the toc. Fumadocs found ${toc.length} entries, and you found ${titles.length}.`,\n        );\n    }\n    toc.forEach((entry, i) => {\n        const newTitle = titles[i].trim();\n        t.push({\n            ...entry,\n            title: parseMarkdownTitle(newTitle),\n            // Removed this. No longer checking for validity and relying only on index. THe validity check was unreliable previously, but if this causes new issues revisit this.\n            // let s = Array(entry.depth).fill(\"#\").join(\"\");\n            // title: titles[i].startsWith(s) ? parseTitle(newTitle) : entry.title,\n        });\n    });\n    return t;\n};\n\n\n\n\n\nexport const getTocFromContent = async (content: string) => {\n    let tocItems = await getTableOfContents(content)\n    return getLatexTocEntries(\n        tocItems,\n        content\n    )\n}\n","import { ContentHeading } from \"../../types/mdxStructure.js\";\n\nconst removeIdSyntax = (s: string) => {\n    if (s.includes(\"[#\") && s.endsWith(\"]\")) {\n        return s.slice(0, s.lastIndexOf(\"[\"));\n    }\n    return s;\n};\n\nconst removeLeadingPounds = (s: string): string => {\n    if (s.startsWith(\"#\")) {\n        return removeLeadingPounds(s.slice(1));\n    }\n    return s;\n};\n\nconst temporaryReplaceLogoAsTextWithEntry = (s: string) => {\n    let re = /\\<LogoAsText[^/]*\\/\\>/gm;\n    return s.replace(re, \"ULLD\");\n};\n\nconst replaceCodeStrings = (s: string) => {\n    return s.replaceAll(\"`\", \"\");\n};\n\nconst funcs: ((s: string) => string)[] = [\n    removeLeadingPounds,\n    removeIdSyntax,\n    temporaryReplaceLogoAsTextWithEntry,\n    replaceCodeStrings,\n];\n\nconst getMarkdownTitleDepth = (val: string) => {\n    return val.indexOf(\" \") as ContentHeading[\"depth\"];\n};\n\nexport const parseMarkdownTitle = (s: string) => {\n    let val = s;\n    for (const f of funcs) {\n        val = f(val);\n    }\n    return val;\n};\n\n// TODO: Make this more consistent once things are building properly by tapping into the way id's are created through the remark plugin directly.\nexport const getMarkdownTitleId = (s: string): string | undefined => {\n    let re = /.*\\[\\#(?<content>[^\\]]*)\\]/gm;\n    let m = re.exec(s);\n    return m?.groups?.content;\n};\n\nexport const getContentHeadings = (rawContent: string): ContentHeading[] => {\n    let titles = rawContent.split(\"\\n\").filter((f) => f.trim().startsWith(\"#\"));\n    let items: ContentHeading[] = titles.map((t) => {\n        let id = getMarkdownTitleId(t);\n        return {\n            title: parseMarkdownTitle(t),\n            depth: getMarkdownTitleDepth(t),\n            url: id ? `#${id}` : \"\",\n        };\n    });\n    return items;\n};\n"]}