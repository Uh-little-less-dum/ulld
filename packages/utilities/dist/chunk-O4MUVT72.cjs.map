{"version":3,"sources":["../src/utils/arrayUtilities.ts"],"names":["_ArrayUtilities","list","index","take","items","i","N","dimensions","d","l","b","a","j","f","axisData","values","val","func","data","caseInsensitive","s","validate","start","end","diff","t","k","first","tester","mapAdjustment","arr","comparison","equalityCheck","replacer","initial","additional","comparer","item","x","targetIndex","maxItems","shouldRun","newArray","ArrayUtilities"],"mappings":"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","sourcesContent":["import { Tag, Topic, Subject } from \"@ulld/database/internalDatabaseTypes\";\nimport { Row } from \"@tanstack/react-table\";\n\n// TEST:  Test this properly asap.\nexport class ArrayUtilities {\n    constructor() { }\n    static itemFromListWithLoop<T extends unknown>(list: T[], index: number): T {\n        if (index < list.length - 1) {\n            return list[index];\n        }\n        return list[index % list.length];\n    }\n\n    static listFromListWithLoop<T extends unknown>(list: T[], take: number): T[] {\n        let items: T[] = [];\n        for (var i = 0; i < take; i++) {\n            items.push(ArrayUtilities.itemFromListWithLoop<T>(list, i));\n        }\n        return items;\n    }\n    // TODO: Look up how to type n-dimensional arrays and apply that everywhere this is called\n    static meshGrid<T>(N: number[], dimensions: number) {\n        let d = N;\n        let l = 0;\n        let b: number[][] | number[] = [];\n        for (var i = 0; i < dimensions - 1; i++) {\n            let a = d.flat(dimensions).map(() => N);\n            do {\n                let j = a.slice(l, l + N.length);\n                if (j.length > 0) {\n                    // @ts-ignore\n                    b.length > 0 ? b.push(j) : (b = j);\n                }\n                l += N.length;\n            } while (l < a.length - N.length);\n        }\n        return b as T;\n    }\n\n    static randomFromList<T extends unknown>(list: T[]) {\n        list[Math.floor(Math.random() * list.length)];\n    }\n\n    static compute1DIfNotNull(f: (n: number) => number, axisData: number[]) {\n        let values: number[][] = [[], []];\n        axisData.forEach((n) => {\n            let val = f(n);\n            if (n) {\n                values[0].push(n);\n                values[1].push(val);\n            }\n        });\n        return values;\n    }\n\n    static generateData(func: (n: number) => number) {\n        let data: [number, number][] = [];\n        for (let i = -200; i <= 200; i += 0.1) {\n            data.push([i, func(i)]);\n        }\n        return data;\n    }\n\n    static doesOverlap<T extends unknown>(\n        a: Array<T>,\n        b: Array<T>,\n        caseInsensitive: boolean = false,\n    ): boolean {\n        if (caseInsensitive) {\n            /// @ts-ignore\n            a = a.map((s) => s.toLowerCase());\n        }\n        for (var i = 0; i < b.length; i++) {\n            /// @ts-ignore\n            if (a.indexOf(caseInsensitive ? b[i].toLowerCase() : b[i]) >= 0)\n                return true;\n        }\n        return false;\n    }\n\n    static containsAll<T extends unknown>(a: Array<T>, b: Array<T>): boolean {\n        `Returns true if a contains all elements of b`;\n        for (var i = 0; i < b.length; i++) {\n            if (a.indexOf(b[i]) === -1) return false;\n        }\n        return true;\n    }\n\n    static arrayTruthy(a: any) {\n        Boolean(Array.isArray(a) && a.length > 0);\n    }\n\n    static arrayOrItem<T>(\n        a?: T | T[] | null,\n        validate:\n            | \"nullIfMoreThanOne\"\n            | \"firstIfMoreThanOne\"\n            | \"arrayIfMoreThanOne\"\n            | \"arrayIfExists\"\n            | \"alwaysReturnArray\" = \"arrayIfMoreThanOne\",\n    ): T | null | T[] {\n        if (!a) return validate === \"alwaysReturnArray\" ? [] : null;\n        if (validate === \"alwaysReturnArray\") return Array.isArray(a) ? a : [a];\n        if (Array.isArray(a)) {\n            if (validate === \"arrayIfMoreThanOne\") return a as T[];\n            if (validate === \"firstIfMoreThanOne\") return a[0] as T;\n            if (validate === \"nullIfMoreThanOne\") return a.length === 1 ? a[0] : null;\n            if (validate === \"arrayIfExists\") return a;\n        }\n        return validate === \"arrayIfExists\" ? ([a] as T[]) : (a as T);\n    }\n\n    static asArray = (a: any | any[] | undefined | null) =>\n        Boolean(a) ? (Array.isArray(a) ? a : [a]) : [];\n\n    static arrayStrictBoolean(a: any) {\n        return Array.isArray(a) && a.length > 0;\n    }\n\n    static arange(start: number = 0, end: number = 10, diff: number = 1) {\n        let data = [start];\n        do {\n            data.push(data[data.length - 1] + diff);\n        } while (data[data.length - 1] + diff <= end);\n        return data;\n    }\n\n    static stringArrayToTagSubjectOrTopicConnectOrCreate<\n        T extends Tag | Topic | Subject,\n    >(\n        items: string[],\n    ) {\n        return items.map((t) => ({\n            where: {\n                value: t as string,\n            },\n            create: {\n                value: t as string,\n            },\n        }));\n    }\n\n    static fieldArrayIsSame<\n        T extends { [k: string]: unknown },\n        K extends keyof T,\n    >(a: Row<T>[], k: K): T[K] | undefined {\n        if (!a.length) return;\n        let first = a[0].getValue(k as string) as T[K];\n        return a.every((l) => l.getValue(k as string) === first)\n            ? first\n            : undefined;\n    }\n\n    static toggleItemInArray<T extends unknown>(\n        items: T[],\n        val: T,\n        tester?: (v1: T, v2: T) => boolean,\n        mapAdjustment?: (item: T) => string | number,\n    ) {\n        let _items = mapAdjustment ? items.map(mapAdjustment) : items;\n        return _items.includes(mapAdjustment ? mapAdjustment(val) : (val as any))\n            ? items.filter((a) => {\n                if (mapAdjustment) {\n                    return mapAdjustment(a) !== mapAdjustment(val);\n                } else {\n                    return a !== val;\n                }\n            })\n            : [...items, val];\n    }\n\n    static replaceSelfInArray<T extends unknown, H extends string | number>(\n        arr: T[],\n        comparison: H,\n        equalityCheck: (a: T) => H,\n        replacer: (val: T) => T | any,\n    ) {\n        return arr.map((a) => (equalityCheck(a) === comparison ? replacer(a) : a));\n    }\n    static beArray<T extends unknown>(val: T | T[]): T[] {\n        return Array.isArray(val) ? val : [val]\n    }\n    static concatWithoutDuplicates<T extends unknown>(initial: T[], additional: T[], comparer?: (a: T, b: T) => boolean): T[] {\n        let items = initial\n        for (const item of additional) {\n            if(comparer && !items.some((x) => comparer(x, item))){\n                items.push(item)\n            } else {\n                if(!items.includes(item)){\n                    items.push(item)\n                }\n            }\n        }\n        return items\n    }\n\n    static sliceAroundIndex<T>(data: T[], targetIndex: number, maxItems: number) {\n        let items: T[] = [data[targetIndex]]\n        let i = 1\n        let shouldRun = true\n        do {\n           if(items.length <= targetIndex + i) {\n                items.push(data[targetIndex + i])\n            } \n            if((items.length < maxItems) && (targetIndex - i >= 0)){\n                items.push(data[targetIndex - i])\n            }\n            if(items.length < maxItems && (i + 1 + targetIndex < data.length || targetIndex - (i + 1) > 0)){\n                i++\n            } else {\n                shouldRun = false\n            }\n        } while (shouldRun);\n        return items\n    }\n    static clampInArray<T extends unknown>(arr: T[], index: number): T {\n        return index >= arr.length ? arr[index % arr.length] : arr[index]\n    }\n    static concatWithOptionalArray<T extends unknown>(arr: T[] | undefined | null, newArray: T[]): T[] {\n        return (arr || [] as T[]).concat(newArray)\n    }\n}\n"]}