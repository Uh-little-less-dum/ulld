{"version":3,"sources":["../src/classes/file/main.ts"],"names":["fs","path","FileData","_isDir","s","isDir","data","cb","lines","l","lineData","i","content","newContent"],"mappings":"AAAA,OAAOA,MAAQ,KACf,OAAOC,MAAU,OAEV,IAAMC,EAAN,KAAe,CAGlB,YACWD,EACAE,EACT,CAFS,UAAAF,EACA,YAAAE,EAEP,KAAK,QAAU,KAAK,WAAWA,CAAM,CACzC,CACA,aAAc,CAEV,OADQF,EAAK,SAAS,KAAK,IAAI,EAAE,MAAM,GAAG,EACjC,CAAC,CACd,CACA,cAAe,CACX,IAAIG,EAAIH,EAAK,SAAS,KAAK,IAAI,EAAE,MAAM,GAAG,EAC1C,MAAO,IAAIG,EAAEA,EAAE,OAAS,CAAC,CAAC,EAC9B,CACA,SAAU,CACN,OAAOJ,EAAG,SAAS,KAAK,IAAI,CAChC,CACA,OAAQ,CAEJ,MAAO,EADC,KAAK,QAAQ,GACH,YAAY,CAClC,CACA,WAAWK,EAAiB,CAExB,GADa,OAAOA,GAAU,UAAYA,EAAQ,KAAK,MAAM,EAEzD,OAAO,KAAK,KAEhB,GAAI,CACA,OAAOJ,EAAK,QAAQ,KAAK,IAAI,CACjC,MAAc,CACV,eAAQ,MACJ,wDAAwD,KAAK,IAAI,EACrE,EACO,KAAK,IAChB,CACJ,CACA,kBAAmB,CACVD,EAAG,WAAW,KAAK,OAAO,GAC3BA,EAAG,UAAU,KAAK,QAAS,CAAE,UAAW,EAAK,CAAC,CAEtD,CACA,YAAa,CACT,GAAI,KAAK,QAAS,OAAO,KAAK,QAC9B,IAAIM,EAAON,EAAG,aAAa,KAAK,KAAM,CAAE,SAAU,OAAQ,CAAC,EAC3D,YAAK,QAAUM,EACRA,CACX,CACA,QAAS,CACL,OAAON,EAAG,WAAW,KAAK,IAAI,CAClC,CACA,UAAW,CACP,OAAO,KAAK,WAAW,EAAE,MAAM;AAAA,CAAI,CACvC,CACA,YAAYO,EAAsC,CAC9C,IAAIC,EAAQ,KAAK,SAAS,EAAE,OAAQC,GAAMF,EAAGE,CAAC,CAAC,EAC/C,KAAK,QAAUD,EAAM,KAAK;AAAA,CAAI,CAClC,CACA,gBAAiB,CACb,IAAIA,EAAQ,KAAK,SAAS,EACtBE,EAAiD,CAAC,EACtD,OAAAF,EAAM,QAAQ,CAACC,EAAGE,IAAM,CAChBF,EAAE,KAAK,EAAE,WAAW,QAAQ,GAC5BC,EAAS,KAAK,CAAE,QAASD,EAAG,MAAOE,CAAE,CAAC,CAE9C,CAAC,EACMD,CACX,CACA,kBAAmB,CAEf,GAAI,CADS,KAAK,OAAO,EAErB,MAAM,IAAI,MAAM,qBAAqB,KAAK,IAAI,aAAa,CAEnE,CACA,WAAY,CACR,OAAO,KAAK,MAAM,KAAK,WAAW,CAAC,CACvC,CACA,aAAaE,EAAkB,CAC3B,IAAIC,EAAaD,GAAW,KAAK,QACjC,GAAI,CAACC,EACD,OAAO,QAAQ,MAAM,iDAAiD,EAE1E,KAAK,iBAAiB,EACtBb,EAAG,cAAc,KAAK,KAAMa,EAAY,CAAE,SAAU,OAAQ,CAAC,CACjE,CACJ","sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\n\nexport class FileData {\n    dirname: string;\n    content?: string;\n    constructor(\n        public path: string,\n        public _isDir?: boolean,\n    ) {\n        this.dirname = this.getDirname(_isDir);\n    }\n    getFileName() {\n        let s = path.basename(this.path).split(\".\");\n        return s[0];\n    }\n    getExtension() {\n        let s = path.basename(this.path).split(\".\");\n        return `.${s[s.length - 1]}`;\n    }\n    getStat() {\n        return fs.statSync(this.path);\n    }\n    isDir() {\n        let s = this.getStat();\n        return Boolean(s?.isDirectory());\n    }\n    getDirname(isDir?: boolean) {\n        let _isDir = typeof isDir === \"boolean\" ? isDir : this.isDir();\n        if (_isDir) {\n            return this.path;\n        }\n        try {\n            return path.dirname(this.path);\n        } catch (err) {\n            console.error(\n                `Could not get dirname. Path likely does not exist at ${this.path}`,\n            );\n            return this.path\n        }\n    }\n    mkdirIfNotExists() {\n        if (!fs.existsSync(this.dirname)) {\n            fs.mkdirSync(this.dirname, { recursive: true });\n        }\n    }\n    getContent() {\n        if (this.content) return this.content;\n        let data = fs.readFileSync(this.path, { encoding: \"utf-8\" });\n        this.content = data;\n        return data;\n    }\n    exists() {\n        return fs.existsSync(this.path);\n    }\n    getLines() {\n        return this.getContent().split(\"\\n\");\n    }\n    filterLines(cb: (lineContent: string) => boolean) {\n        let lines = this.getLines().filter((l) => cb(l));\n        this.content = lines.join(\"\\n\");\n    }\n    getImportLines() {\n        let lines = this.getLines();\n        let lineData: { content: string; index: number }[] = [];\n        lines.forEach((l, i) => {\n            if (l.trim().startsWith(\"import\")) {\n                lineData.push({ content: l, index: i });\n            }\n        });\n        return lineData;\n    }\n    throwIfNotExists() {\n        let exists = this.exists();\n        if (!exists) {\n            throw new Error(`No file exists at ${this.path}. Aborting.`);\n        }\n    }\n    getAsJson() {\n        return JSON.parse(this.getContent());\n    }\n    writeContent(content?: string) {\n        let newContent = content || this.content;\n        if (!newContent) {\n            return console.error(\"Could not write file content as none was found.\");\n        }\n        this.mkdirIfNotExists();\n        fs.writeFileSync(this.path, newContent, { encoding: \"utf-8\" });\n    }\n}\n"]}