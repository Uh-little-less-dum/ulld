{"version":3,"sources":["../src/developmentUtilities/convertPackageJsonExportFields.ts"],"names":["fs","path","replaceExtension","l","extension","newL","getPath","dir","getFileType","filePath","props","_tsPath","tsPath","_tsxPath","tsxPath","_jsonPath","convertExportItem","item","to","value","convertPackageJsonExports","packagePath","content","exportItems","k","newItems"],"mappings":"AAAA,OAAOA,MAAQ,KACf,OAAOC,MAAU,OAyBjB,IAAMC,EAAmB,CAACC,EAAWC,IAA4B,CAC7D,IAAIC,EAAOF,EACX,OAAIA,EAAE,SAAS,OAAO,EAClBE,EAAOA,EAAK,MAAM,EAAGA,EAAK,OAAS,CAAC,EAEpCA,EAAOA,EAAK,MAAM,EAAGA,EAAK,YAAY,GAAG,CAAC,EAEvC,GAAGA,CAAI,GAAGD,CAAS,EAC9B,EAEME,EAAU,CAACH,EAAWI,EAAqBH,IAA4B,CACzE,IAAIC,EAAOF,EACX,OAAII,IAAQ,OAASF,EAAK,WAAW,QAAQ,EACzCA,EAAOA,EAAK,QAAQ,SAAU,OAAO,EAC9BE,IAAQ,QAAUF,EAAK,WAAW,OAAO,IAChDA,EAAOA,EAAK,QAAQ,QAAS,QAAQ,GAElCH,EAAiBG,EAAMD,CAAS,CAC3C,EAEMI,EAAc,CAChBC,EACAC,IACC,CACD,QAAQ,IAAI,aAAcD,CAAQ,EAClC,IAAIE,EAAUT,EAAiBO,EAAU,KAAK,EAC1CG,EAASX,EAAK,KAAKS,EAAM,QAASC,CAAO,EACzCE,EAAWX,EAAiBO,EAAU,MAAM,EAC5CK,EAAUb,EAAK,KAAKS,EAAM,QAASG,CAAQ,EAC/C,GAAIb,EAAG,WAAWY,CAAM,EACpB,OAAOD,EAEX,GAAIX,EAAG,WAAWc,CAAO,EACrB,OAAOD,EAGX,IAAIE,EAAYb,EAAiBO,EAAU,OAAO,EAElD,GAAIT,EAAG,WAAWC,EAAK,KAAKS,EAAM,QAASK,CAAS,CAAC,EACjD,OAAOA,EAGX,MAAM,IAAI,MAAM,8CAA8CN,CAAQ,EAAE,CAC5E,EAEMO,EAAoB,CACtBC,EACAC,EACAR,IACa,CACb,GAAIQ,IAAO,kBACP,OAAO,OAAOD,EAAK,OAAU,SACvBA,EACA,CACE,GAAGA,EACH,MAAO,CACH,MAAOX,EAAQW,EAAK,MAAO,OAAQ,OAAO,EAC1C,OAAQX,EAAQW,EAAK,MAAO,OAAQ,KAAK,EACzC,QAASX,EAAQW,EAAK,MAAO,OAAQ,MAAM,CAC/C,CACJ,EAER,GAAIC,IAAO,iBAAkB,CACzB,IAAIC,EAAQ,OAAOF,EAAK,OAAU,SAAWA,EAAK,MAAQT,EAAYF,EAAQW,EAAK,MAAM,OAAQ,MAAO,KAAK,EAAGP,CAAK,EACrH,GAAG,CAACS,EACA,MAAM,IAAI,MAAM,2BAA2BF,EAAK,KAAK,EAAE,EAE3D,OAAO,OAAOA,EAAK,OAAU,SACvBA,EACA,CACE,GAAGA,EACH,MAAAE,CACJ,CACR,CACA,OAAOF,CACX,EAEaG,EACTV,GACC,CACD,IAAMW,EAAcpB,EAAK,QAAQS,EAAM,QAAS,gBAAgB,EAChE,GAAI,CAACV,EAAG,WAAWqB,CAAW,EAC1B,MAAM,IAAI,MACN,sDAAsDA,CAAW,EACrE,EAEJ,IAAIC,EAAU,KAAK,MACftB,EAAG,aAAaqB,EAAa,CAAE,SAAU,OAAQ,CAAC,CACtD,EACA,GAAI,CAACC,EAAQ,QACT,OAEJ,IAAIC,EAA4B,CAAC,EAEjC,QAAWC,KAAKF,EAAQ,QACpBC,EAAY,KAAK,CACb,IAAKC,EACL,MAAOF,EAAQ,QAAQE,CAAC,EACxB,KACI,OAAOF,EAAQ,QAAQE,CAAC,GAAM,SACxB,iBACA,iBACd,CAAC,EAEL,IAAIC,EAAWF,EAAY,IAAKpB,GAAMa,EAAkBb,EAAGO,EAAM,GAAIA,CAAK,CAAC,CAC/E","sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\n\n// TODO: Delete this. This was moved to the developer cli.\n\ntype ExportTypeKeys = \"src dir string\" | \"dist dir object\";\n\nexport interface ConvertPackageJsonExportsProps {\n    dirname: string;\n    to: ExportTypeKeys;\n}\n\ntype ExportType =\n    | string\n    | {\n        types: string;\n        import: string;\n        require: string;\n    };\n\ninterface ExportItem {\n    key: string;\n    value: ExportType;\n    type: ExportTypeKeys;\n}\n\nconst replaceExtension = (l: string, extension: `.${string}`) => {\n    let newL = l;\n    if (l.endsWith(\".d.ts\")) {\n        newL = newL.slice(0, newL.length - 5);\n    } else {\n        newL = newL.slice(0, newL.lastIndexOf(\".\"));\n    }\n    return `${newL}${extension}`;\n};\n\nconst getPath = (l: string, dir: \"src\" | \"dist\", extension: `.${string}`) => {\n    let newL = l;\n    if (dir === \"src\" && newL.startsWith(\"./dist\")) {\n        newL = newL.replace(\"./dist\", \"./src\");\n    } else if (dir === \"dist\" && newL.startsWith(\"./src\")) {\n        newL = newL.replace(\"./src\", \"./dist\");\n    }\n    return replaceExtension(newL, extension);\n};\n\nconst getFileType = (\n    filePath: string,\n    props: ConvertPackageJsonExportsProps,\n) => {\n    console.log(\"filePath: \", filePath)\n    let _tsPath = replaceExtension(filePath, \".ts\");\n    let tsPath = path.join(props.dirname, _tsPath);\n    let _tsxPath = replaceExtension(filePath, \".tsx\");\n    let tsxPath = path.join(props.dirname, _tsxPath);\n    if (fs.existsSync(tsPath)) {\n        return _tsPath;\n    }\n    if (fs.existsSync(tsxPath)) {\n        return _tsxPath;\n    }\n\n    let _jsonPath = replaceExtension(filePath, \".json\");\n\n    if (fs.existsSync(path.join(props.dirname, _jsonPath))) {\n        return _jsonPath;\n    }\n\n    throw new Error(`Could not find a path that exists for file ${filePath}`);\n};\n\nconst convertExportItem = (\n    item: ExportItem,\n    to: ExportTypeKeys,\n    props: ConvertPackageJsonExportsProps\n): ExportItem => {\n    if (to === \"dist dir object\") {\n        return typeof item.value === \"object\"\n            ? item\n            : {\n                ...item,\n                value: {\n                    types: getPath(item.value, \"dist\", \".d.ts\"),\n                    import: getPath(item.value, \"dist\", \".js\"),\n                    require: getPath(item.value, \"dist\", \".cjs\"),\n                },\n            };\n    }\n    if (to === \"src dir string\") {\n        let value = typeof item.value === \"string\" ? item.value : getFileType(getPath(item.value.import, \"src\", \".ts\"), props)\n        if(!value){\n            throw new Error(`Could not find file for ${item.value}`)\n        }\n        return typeof item.value === \"string\"\n            ? item\n            : {\n                ...item,\n                value,\n            };\n    }\n    return item\n};\n\nexport const convertPackageJsonExports = (\n    props: ConvertPackageJsonExportsProps,\n) => {\n    const packagePath = path.resolve(props.dirname, \"./package.json\");\n    if (!fs.existsSync(packagePath)) {\n        throw new Error(\n            `Cannot modify package.json exports. Could not find ${packagePath}`,\n        );\n    }\n    let content = JSON.parse(\n        fs.readFileSync(packagePath, { encoding: \"utf-8\" }),\n    ) as { exports: Record<string, ExportType> };\n    if (!content.exports) {\n        return;\n    }\n    let exportItems: ExportItem[] = [];\n\n    for (const k in content.exports) {\n        exportItems.push({\n            key: k,\n            value: content.exports[k],\n            type:\n                typeof content.exports[k] === \"string\"\n                    ? \"src dir string\"\n                    : \"dist dir object\",\n        });\n    }\n    let newItems = exportItems.map((l) => convertExportItem(l, props.to, props))\n};\n"]}