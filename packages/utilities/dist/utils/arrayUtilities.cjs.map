{"version":3,"sources":["../../src/utils/arrayUtilities.ts"],"names":[],"mappings":";AAIO,IAAM,kBAAN,MAAM,gBAAe;AAAA,EACxB,cAAc;AAAA,EAAE;AAAA,EAChB,OAAO,qBAAwC,MAAW,OAAkB;AACxE,QAAI,QAAQ,KAAK,SAAS,GAAG;AACzB,aAAO,KAAK,KAAK;AAAA,IACrB;AACA,WAAO,KAAK,QAAQ,KAAK,MAAM;AAAA,EACnC;AAAA,EAEA,OAAO,qBAAwC,MAAW,MAAmB;AACzE,QAAI,QAAa,CAAC;AAClB,aAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC3B,YAAM,KAAK,gBAAe,qBAAwB,MAAM,CAAC,CAAC;AAAA,IAC9D;AACA,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,OAAO,SAAY,GAAa,YAAoB;AAChD,QAAI,IAAI;AACR,QAAI,IAAI;AACR,QAAI,IAA2B,CAAC;AAChC,aAAS,IAAI,GAAG,IAAI,aAAa,GAAG,KAAK;AACrC,UAAI,IAAI,EAAE,KAAK,UAAU,EAAE,IAAI,MAAM,CAAC;AACtC,SAAG;AACC,YAAI,IAAI,EAAE,MAAM,GAAG,IAAI,EAAE,MAAM;AAC/B,YAAI,EAAE,SAAS,GAAG;AAEd,YAAE,SAAS,IAAI,EAAE,KAAK,CAAC,IAAK,IAAI;AAAA,QACpC;AACA,aAAK,EAAE;AAAA,MACX,SAAS,IAAI,EAAE,SAAS,EAAE;AAAA,IAC9B;AACA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,eAAkC,MAAW;AAChD,SAAK,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK,MAAM,CAAC;AAAA,EAChD;AAAA,EAEA,OAAO,mBAAmB,GAA0B,UAAoB;AACpE,QAAI,SAAqB,CAAC,CAAC,GAAG,CAAC,CAAC;AAChC,aAAS,QAAQ,CAAC,MAAM;AACpB,UAAI,MAAM,EAAE,CAAC;AACb,UAAI,GAAG;AACH,eAAO,CAAC,EAAE,KAAK,CAAC;AAChB,eAAO,CAAC,EAAE,KAAK,GAAG;AAAA,MACtB;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,aAAa,MAA6B;AAC7C,QAAI,OAA2B,CAAC;AAChC,aAAS,IAAI,MAAM,KAAK,KAAK,KAAK,KAAK;AACnC,WAAK,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;AAAA,IAC1B;AACA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,YACH,GACA,GACA,kBAA2B,OACpB;AACP,QAAI,iBAAiB;AAEjB,UAAI,EAAE,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC;AAAA,IACpC;AACA,aAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAE/B,UAAI,EAAE,QAAQ,kBAAkB,EAAE,CAAC,EAAE,YAAY,IAAI,EAAE,CAAC,CAAC,KAAK;AAC1D,eAAO;AAAA,IACf;AACA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,YAA+B,GAAa,GAAsB;AACrE;AACA,aAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAC/B,UAAI,EAAE,QAAQ,EAAE,CAAC,CAAC,MAAM;AAAI,eAAO;AAAA,IACvC;AACA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,YAAY,GAAQ;AACvB,YAAQ,MAAM,QAAQ,CAAC,KAAK,EAAE,SAAS,CAAC;AAAA,EAC5C;AAAA,EAEA,OAAO,YACH,GACA,WAK4B,sBACd;AACd,QAAI,CAAC;AAAG,aAAO,aAAa,sBAAsB,CAAC,IAAI;AACvD,QAAI,aAAa;AAAqB,aAAO,MAAM,QAAQ,CAAC,IAAI,IAAI,CAAC,CAAC;AACtE,QAAI,MAAM,QAAQ,CAAC,GAAG;AAClB,UAAI,aAAa;AAAsB,eAAO;AAC9C,UAAI,aAAa;AAAsB,eAAO,EAAE,CAAC;AACjD,UAAI,aAAa;AAAqB,eAAO,EAAE,WAAW,IAAI,EAAE,CAAC,IAAI;AACrE,UAAI,aAAa;AAAiB,eAAO;AAAA,IAC7C;AACA,WAAO,aAAa,kBAAmB,CAAC,CAAC,IAAa;AAAA,EAC1D;AAAA,EAKA,OAAO,mBAAmB,GAAQ;AAC9B,WAAO,MAAM,QAAQ,CAAC,KAAK,EAAE,SAAS;AAAA,EAC1C;AAAA,EAEA,OAAO,OAAO,QAAgB,GAAG,MAAc,IAAI,OAAe,GAAG;AACjE,QAAI,OAAO,CAAC,KAAK;AACjB,OAAG;AACC,WAAK,KAAK,KAAK,KAAK,SAAS,CAAC,IAAI,IAAI;AAAA,IAC1C,SAAS,KAAK,KAAK,SAAS,CAAC,IAAI,QAAQ;AACzC,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,8CAGH,OACF;AACE,WAAO,MAAM,IAAI,CAAC,OAAO;AAAA,MACrB,OAAO;AAAA,QACH,OAAO;AAAA,MACX;AAAA,MACA,QAAQ;AAAA,QACJ,OAAO;AAAA,MACX;AAAA,IACJ,EAAE;AAAA,EACN;AAAA,EAEA,OAAO,iBAGL,GAAa,GAAwB;AACnC,QAAI,CAAC,EAAE;AAAQ;AACf,QAAI,QAAQ,EAAE,CAAC,EAAE,SAAS,CAAW;AACrC,WAAO,EAAE,MAAM,CAAC,MAAM,EAAE,SAAS,CAAW,MAAM,KAAK,IACjD,QACA;AAAA,EACV;AAAA,EAEA,OAAO,kBACH,OACA,KACA,QACA,eACF;AACE,QAAI,SAAS,gBAAgB,MAAM,IAAI,aAAa,IAAI;AACxD,WAAO,OAAO,SAAS,gBAAgB,cAAc,GAAG,IAAK,GAAW,IAClE,MAAM,OAAO,CAAC,MAAM;AAClB,UAAI,eAAe;AACf,eAAO,cAAc,CAAC,MAAM,cAAc,GAAG;AAAA,MACjD,OAAO;AACH,eAAO,MAAM;AAAA,MACjB;AAAA,IACJ,CAAC,IACC,CAAC,GAAG,OAAO,GAAG;AAAA,EACxB;AAAA,EAEA,OAAO,mBACH,KACA,YACA,eACA,UACF;AACE,WAAO,IAAI,IAAI,CAAC,MAAO,cAAc,CAAC,MAAM,aAAa,SAAS,CAAC,IAAI,CAAE;AAAA,EAC7E;AAAA,EACA,OAAO,QAA2B,KAAmB;AACjD,WAAO,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG;AAAA,EAC1C;AAAA,EACA,OAAO,wBAA2C,SAAc,YAAiB,UAAyC;AACtH,QAAI,QAAQ;AACZ,eAAW,QAAQ,YAAY;AAC3B,UAAG,YAAY,CAAC,MAAM,KAAK,CAAC,MAAM,SAAS,GAAG,IAAI,CAAC,GAAE;AACjD,cAAM,KAAK,IAAI;AAAA,MACnB,OAAO;AACH,YAAG,CAAC,MAAM,SAAS,IAAI,GAAE;AACrB,gBAAM,KAAK,IAAI;AAAA,QACnB;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,iBAAoB,MAAW,aAAqB,UAAkB;AACzE,QAAI,QAAa,CAAC,KAAK,WAAW,CAAC;AACnC,QAAI,IAAI;AACR,QAAI,YAAY;AAChB,OAAG;AACA,UAAG,MAAM,UAAU,cAAc,GAAG;AAC/B,cAAM,KAAK,KAAK,cAAc,CAAC,CAAC;AAAA,MACpC;AACA,UAAI,MAAM,SAAS,YAAc,cAAc,KAAK,GAAG;AACnD,cAAM,KAAK,KAAK,cAAc,CAAC,CAAC;AAAA,MACpC;AACA,UAAG,MAAM,SAAS,aAAa,IAAI,IAAI,cAAc,KAAK,UAAU,eAAe,IAAI,KAAK,IAAG;AAC3F;AAAA,MACJ,OAAO;AACH,oBAAY;AAAA,MAChB;AAAA,IACJ,SAAS;AACT,WAAO;AAAA,EACX;AAAA,EACA,OAAO,aAAgC,KAAU,OAAkB;AAC/D,WAAO,SAAS,IAAI,SAAS,IAAI,QAAQ,IAAI,MAAM,IAAI,IAAI,KAAK;AAAA,EACpE;AAAA,EACA,OAAO,wBAA2C,KAA6B,UAAoB;AAC/F,YAAQ,OAAO,CAAC,GAAU,OAAO,QAAQ;AAAA,EAC7C;AACJ;AAzNa,gBA4GF,UAAU,CAAC,MACd,QAAQ,CAAC,IAAK,MAAM,QAAQ,CAAC,IAAI,IAAI,CAAC,CAAC,IAAK,CAAC;AA7G9C,IAAM,iBAAN","sourcesContent":["import { Tag, Topic, Subject } from \"@ulld/database/internalDatabaseTypes\";\nimport { Row } from \"@tanstack/react-table\";\n\n// TEST:  Test this properly asap.\nexport class ArrayUtilities {\n    constructor() { }\n    static itemFromListWithLoop<T extends unknown>(list: T[], index: number): T {\n        if (index < list.length - 1) {\n            return list[index];\n        }\n        return list[index % list.length];\n    }\n\n    static listFromListWithLoop<T extends unknown>(list: T[], take: number): T[] {\n        let items: T[] = [];\n        for (var i = 0; i < take; i++) {\n            items.push(ArrayUtilities.itemFromListWithLoop<T>(list, i));\n        }\n        return items;\n    }\n    // TODO: Look up how to type n-dimensional arrays and apply that everywhere this is called\n    static meshGrid<T>(N: number[], dimensions: number) {\n        let d = N;\n        let l = 0;\n        let b: number[][] | number[] = [];\n        for (var i = 0; i < dimensions - 1; i++) {\n            let a = d.flat(dimensions).map(() => N);\n            do {\n                let j = a.slice(l, l + N.length);\n                if (j.length > 0) {\n                    // @ts-ignore\n                    b.length > 0 ? b.push(j) : (b = j);\n                }\n                l += N.length;\n            } while (l < a.length - N.length);\n        }\n        return b as T;\n    }\n\n    static randomFromList<T extends unknown>(list: T[]) {\n        list[Math.floor(Math.random() * list.length)];\n    }\n\n    static compute1DIfNotNull(f: (n: number) => number, axisData: number[]) {\n        let values: number[][] = [[], []];\n        axisData.forEach((n) => {\n            let val = f(n);\n            if (n) {\n                values[0].push(n);\n                values[1].push(val);\n            }\n        });\n        return values;\n    }\n\n    static generateData(func: (n: number) => number) {\n        let data: [number, number][] = [];\n        for (let i = -200; i <= 200; i += 0.1) {\n            data.push([i, func(i)]);\n        }\n        return data;\n    }\n\n    static doesOverlap<T extends unknown>(\n        a: Array<T>,\n        b: Array<T>,\n        caseInsensitive: boolean = false,\n    ): boolean {\n        if (caseInsensitive) {\n            /// @ts-ignore\n            a = a.map((s) => s.toLowerCase());\n        }\n        for (var i = 0; i < b.length; i++) {\n            /// @ts-ignore\n            if (a.indexOf(caseInsensitive ? b[i].toLowerCase() : b[i]) >= 0)\n                return true;\n        }\n        return false;\n    }\n\n    static containsAll<T extends unknown>(a: Array<T>, b: Array<T>): boolean {\n        `Returns true if a contains all elements of b`;\n        for (var i = 0; i < b.length; i++) {\n            if (a.indexOf(b[i]) === -1) return false;\n        }\n        return true;\n    }\n\n    static arrayTruthy(a: any) {\n        Boolean(Array.isArray(a) && a.length > 0);\n    }\n\n    static arrayOrItem<T>(\n        a?: T | T[] | null,\n        validate:\n            | \"nullIfMoreThanOne\"\n            | \"firstIfMoreThanOne\"\n            | \"arrayIfMoreThanOne\"\n            | \"arrayIfExists\"\n            | \"alwaysReturnArray\" = \"arrayIfMoreThanOne\",\n    ): T | null | T[] {\n        if (!a) return validate === \"alwaysReturnArray\" ? [] : null;\n        if (validate === \"alwaysReturnArray\") return Array.isArray(a) ? a : [a];\n        if (Array.isArray(a)) {\n            if (validate === \"arrayIfMoreThanOne\") return a as T[];\n            if (validate === \"firstIfMoreThanOne\") return a[0] as T;\n            if (validate === \"nullIfMoreThanOne\") return a.length === 1 ? a[0] : null;\n            if (validate === \"arrayIfExists\") return a;\n        }\n        return validate === \"arrayIfExists\" ? ([a] as T[]) : (a as T);\n    }\n\n    static asArray = (a: any | any[] | undefined | null) =>\n        Boolean(a) ? (Array.isArray(a) ? a : [a]) : [];\n\n    static arrayStrictBoolean(a: any) {\n        return Array.isArray(a) && a.length > 0;\n    }\n\n    static arange(start: number = 0, end: number = 10, diff: number = 1) {\n        let data = [start];\n        do {\n            data.push(data[data.length - 1] + diff);\n        } while (data[data.length - 1] + diff <= end);\n        return data;\n    }\n\n    static stringArrayToTagSubjectOrTopicConnectOrCreate<\n        T extends Tag | Topic | Subject,\n    >(\n        items: string[],\n    ) {\n        return items.map((t) => ({\n            where: {\n                value: t as string,\n            },\n            create: {\n                value: t as string,\n            },\n        }));\n    }\n\n    static fieldArrayIsSame<\n        T extends { [k: string]: unknown },\n        K extends keyof T,\n    >(a: Row<T>[], k: K): T[K] | undefined {\n        if (!a.length) return;\n        let first = a[0].getValue(k as string) as T[K];\n        return a.every((l) => l.getValue(k as string) === first)\n            ? first\n            : undefined;\n    }\n\n    static toggleItemInArray<T extends unknown>(\n        items: T[],\n        val: T,\n        tester?: (v1: T, v2: T) => boolean,\n        mapAdjustment?: (item: T) => string | number,\n    ) {\n        let _items = mapAdjustment ? items.map(mapAdjustment) : items;\n        return _items.includes(mapAdjustment ? mapAdjustment(val) : (val as any))\n            ? items.filter((a) => {\n                if (mapAdjustment) {\n                    return mapAdjustment(a) !== mapAdjustment(val);\n                } else {\n                    return a !== val;\n                }\n            })\n            : [...items, val];\n    }\n\n    static replaceSelfInArray<T extends unknown, H extends string | number>(\n        arr: T[],\n        comparison: H,\n        equalityCheck: (a: T) => H,\n        replacer: (val: T) => T | any,\n    ) {\n        return arr.map((a) => (equalityCheck(a) === comparison ? replacer(a) : a));\n    }\n    static beArray<T extends unknown>(val: T | T[]): T[] {\n        return Array.isArray(val) ? val : [val]\n    }\n    static concatWithoutDuplicates<T extends unknown>(initial: T[], additional: T[], comparer?: (a: T, b: T) => boolean): T[] {\n        let items = initial\n        for (const item of additional) {\n            if(comparer && !items.some((x) => comparer(x, item))){\n                items.push(item)\n            } else {\n                if(!items.includes(item)){\n                    items.push(item)\n                }\n            }\n        }\n        return items\n    }\n\n    static sliceAroundIndex<T>(data: T[], targetIndex: number, maxItems: number) {\n        let items: T[] = [data[targetIndex]]\n        let i = 1\n        let shouldRun = true\n        do {\n           if(items.length <= targetIndex + i) {\n                items.push(data[targetIndex + i])\n            } \n            if((items.length < maxItems) && (targetIndex - i >= 0)){\n                items.push(data[targetIndex - i])\n            }\n            if(items.length < maxItems && (i + 1 + targetIndex < data.length || targetIndex - (i + 1) > 0)){\n                i++\n            } else {\n                shouldRun = false\n            }\n        } while (shouldRun);\n        return items\n    }\n    static clampInArray<T extends unknown>(arr: T[], index: number): T {\n        return index >= arr.length ? arr[index % arr.length] : arr[index]\n    }\n    static concatWithOptionalArray<T extends unknown>(arr: T[] | undefined | null, newArray: T[]): T[] {\n        return (arr || [] as T[]).concat(newArray)\n    }\n}\n"]}