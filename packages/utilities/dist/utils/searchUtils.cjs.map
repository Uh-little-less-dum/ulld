{"version":3,"sources":["../../src/utils/arrayUtilities.ts","../../src/utils/searchUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tag, Topic, Subject } from \"@ulld/database/internalDatabaseTypes\";\nimport { Row } from \"@tanstack/react-table\";\n\n// TEST:  Test this properly asap.\nexport class ArrayUtilities {\n    constructor() { }\n    static itemFromListWithLoop<T extends unknown>(list: T[], index: number): T {\n        if (index < list.length - 1) {\n            return list[index];\n        }\n        return list[index % list.length];\n    }\n\n    static listFromListWithLoop<T extends unknown>(list: T[], take: number): T[] {\n        let items: T[] = [];\n        for (var i = 0; i < take; i++) {\n            items.push(ArrayUtilities.itemFromListWithLoop<T>(list, i));\n        }\n        return items;\n    }\n    // TODO: Look up how to type n-dimensional arrays and apply that everywhere this is called\n    static meshGrid<T>(N: number[], dimensions: number) {\n        let d = N;\n        let l = 0;\n        let b: number[][] | number[] = [];\n        for (var i = 0; i < dimensions - 1; i++) {\n            let a = d.flat(dimensions).map(() => N);\n            do {\n                let j = a.slice(l, l + N.length);\n                if (j.length > 0) {\n                    // @ts-ignore\n                    b.length > 0 ? b.push(j) : (b = j);\n                }\n                l += N.length;\n            } while (l < a.length - N.length);\n        }\n        return b as T;\n    }\n\n    static randomFromList<T extends unknown>(list: T[]) {\n        list[Math.floor(Math.random() * list.length)];\n    }\n\n    static compute1DIfNotNull(f: (n: number) => number, axisData: number[]) {\n        let values: number[][] = [[], []];\n        axisData.forEach((n) => {\n            let val = f(n);\n            if (n) {\n                values[0].push(n);\n                values[1].push(val);\n            }\n        });\n        return values;\n    }\n\n    static generateData(func: (n: number) => number) {\n        let data: [number, number][] = [];\n        for (let i = -200; i <= 200; i += 0.1) {\n            data.push([i, func(i)]);\n        }\n        return data;\n    }\n\n    static doesOverlap<T extends unknown>(\n        a: Array<T>,\n        b: Array<T>,\n        caseInsensitive: boolean = false,\n    ): boolean {\n        if (caseInsensitive) {\n            /// @ts-ignore\n            a = a.map((s) => s.toLowerCase());\n        }\n        for (var i = 0; i < b.length; i++) {\n            /// @ts-ignore\n            if (a.indexOf(caseInsensitive ? b[i].toLowerCase() : b[i]) >= 0)\n                return true;\n        }\n        return false;\n    }\n\n    static containsAll<T extends unknown>(a: Array<T>, b: Array<T>): boolean {\n        `Returns true if a contains all elements of b`;\n        for (var i = 0; i < b.length; i++) {\n            if (a.indexOf(b[i]) === -1) return false;\n        }\n        return true;\n    }\n\n    static arrayTruthy(a: any) {\n        Boolean(Array.isArray(a) && a.length > 0);\n    }\n\n    static arrayOrItem<T>(\n        a?: T | T[] | null,\n        validate:\n            | \"nullIfMoreThanOne\"\n            | \"firstIfMoreThanOne\"\n            | \"arrayIfMoreThanOne\"\n            | \"arrayIfExists\"\n            | \"alwaysReturnArray\" = \"arrayIfMoreThanOne\",\n    ): T | null | T[] {\n        if (!a) return validate === \"alwaysReturnArray\" ? [] : null;\n        if (validate === \"alwaysReturnArray\") return Array.isArray(a) ? a : [a];\n        if (Array.isArray(a)) {\n            if (validate === \"arrayIfMoreThanOne\") return a as T[];\n            if (validate === \"firstIfMoreThanOne\") return a[0] as T;\n            if (validate === \"nullIfMoreThanOne\") return a.length === 1 ? a[0] : null;\n            if (validate === \"arrayIfExists\") return a;\n        }\n        return validate === \"arrayIfExists\" ? ([a] as T[]) : (a as T);\n    }\n\n    static asArray = (a: any | any[] | undefined | null) =>\n        Boolean(a) ? (Array.isArray(a) ? a : [a]) : [];\n\n    static arrayStrictBoolean(a: any) {\n        return Array.isArray(a) && a.length > 0;\n    }\n\n    static arange(start: number = 0, end: number = 10, diff: number = 1) {\n        let data = [start];\n        do {\n            data.push(data[data.length - 1] + diff);\n        } while (data[data.length - 1] + diff <= end);\n        return data;\n    }\n\n    static stringArrayToTagSubjectOrTopicConnectOrCreate<\n        T extends Tag | Topic | Subject,\n    >(\n        items: string[],\n    ) {\n        return items.map((t) => ({\n            where: {\n                value: t as string,\n            },\n            create: {\n                value: t as string,\n            },\n        }));\n    }\n\n    static fieldArrayIsSame<\n        T extends { [k: string]: unknown },\n        K extends keyof T,\n    >(a: Row<T>[], k: K): T[K] | undefined {\n        if (!a.length) return;\n        let first = a[0].getValue(k as string) as T[K];\n        return a.every((l) => l.getValue(k as string) === first)\n            ? first\n            : undefined;\n    }\n\n    static toggleItemInArray<T extends unknown>(\n        items: T[],\n        val: T,\n        tester?: (v1: T, v2: T) => boolean,\n        mapAdjustment?: (item: T) => string | number,\n    ) {\n        let _items = mapAdjustment ? items.map(mapAdjustment) : items;\n        return _items.includes(mapAdjustment ? mapAdjustment(val) : (val as any))\n            ? items.filter((a) => {\n                if (mapAdjustment) {\n                    return mapAdjustment(a) !== mapAdjustment(val);\n                } else {\n                    return a !== val;\n                }\n            })\n            : [...items, val];\n    }\n\n    static replaceSelfInArray<T extends unknown, H extends string | number>(\n        arr: T[],\n        comparison: H,\n        equalityCheck: (a: T) => H,\n        replacer: (val: T) => T | any,\n    ) {\n        return arr.map((a) => (equalityCheck(a) === comparison ? replacer(a) : a));\n    }\n    static beArray<T extends unknown>(val: T | T[]): T[] {\n        return Array.isArray(val) ? val : [val]\n    }\n    static concatWithoutDuplicates<T extends unknown>(initial: T[], additional: T[], comparer?: (a: T, b: T) => boolean): T[] {\n        let items = initial\n        for (const item of additional) {\n            if(comparer && !items.some((x) => comparer(x, item))){\n                items.push(item)\n            } else {\n                if(!items.includes(item)){\n                    items.push(item)\n                }\n            }\n        }\n        return items\n    }\n\n    static sliceAroundIndex<T>(data: T[], targetIndex: number, maxItems: number) {\n        let items: T[] = [data[targetIndex]]\n        let i = 1\n        let shouldRun = true\n        do {\n           if(items.length <= targetIndex + i) {\n                items.push(data[targetIndex + i])\n            } \n            if((items.length < maxItems) && (targetIndex - i >= 0)){\n                items.push(data[targetIndex - i])\n            }\n            if(items.length < maxItems && (i + 1 + targetIndex < data.length || targetIndex - (i + 1) > 0)){\n                i++\n            } else {\n                shouldRun = false\n            }\n        } while (shouldRun);\n        return items\n    }\n    static clampInArray<T extends unknown>(arr: T[], index: number): T {\n        return index >= arr.length ? arr[index % arr.length] : arr[index]\n    }\n    static concatWithOptionalArray<T extends unknown>(arr: T[] | undefined | null, newArray: T[]): T[] {\n        return (arr || [] as T[]).concat(newArray)\n    }\n}\n","import { LetterType, SearchAllSearchType } from \"../types/general.js\";\nimport { SearchAllParams } from \"../types/pageParams.js\";\nimport { ArrayUtilities } from \"./arrayUtilities.js\";\n\nexport const getFirstLetterWithLatex = (value: string): LetterType => {\n    return value.replaceAll(/\\\\|\\:|\\-|\\=|\\_/gm, \"\")[0] as LetterType;\n};\n\nexport const getSearchType = (sp: SearchAllParams): SearchAllSearchType => {\n    if (sp.equationId) {\n        return \"byEquation\";\n    }\n    if (sp.sequentialId) {\n        return \"bySequentialId\";\n    }\n    if (sp.tags && sp.tags.length) {\n        return \"byTag\";\n    }\n    return \"searchAll\";\n};\n\nexport const searchAllParamsToSearchParamsClass = (\n    sp?: Partial<SearchAllParams>,\n): URLSearchParams => {\n    let data = new URLSearchParams();\n    if (!sp) {\n        return data;\n    }\n    if (sp.query) {\n        data.set(\"query\", sp.query);\n    }\n    if (sp.page || typeof sp.page === \"number\") {\n        data.set(\"page\", sp.page);\n    }\n    if (sp.tags) {\n        for (const t of ArrayUtilities.beArray(sp.tags)) {\n            data.append(\"tags\", t);\n        }\n    }\n    if (sp.take) {\n        data.set(\"take\", sp.take);\n    }\n    if (sp.remote) {\n        data.set(\"remote\", \"true\");\n    }\n    if (sp.topics) {\n        for (const t of ArrayUtilities.beArray(sp.topics)) {\n            data.append(\"topics\", t);\n        }\n    }\n    if (sp.subjects) {\n        for (const t of ArrayUtilities.beArray(sp.subjects)) {\n            data.append(\"subjects\", t);\n        }\n    }\n    if (sp.perPage) {\n        data.set(\"perPage\", sp.perPage);\n    }\n    if (sp.tagRegex) {\n        for (const t of ArrayUtilities.beArray(sp.tagRegex)) {\n            data.append(\"tagRegex\", t.source);\n        }\n    }\n    if (sp.citations) {\n        for (const c of ArrayUtilities.beArray(sp.citations)) {\n            data.append(\"citations\", c);\n        }\n    }\n    if (sp.categories) {\n        for (const t of ArrayUtilities.beArray(sp.categories)) {\n            data.append(\"categories\", t);\n        }\n    }\n    if (sp.sequentialId) {\n        data.set(\"sequentialId\", sp.sequentialId);\n    }\n    if (sp.equationId) {\n        data.set(\"equationId\", sp.equationId);\n    }\n    return data;\n};\n\nexport const getTaggablesFromSearchAllParams = (sp: SearchAllParams) => {\n    return {\n        tags: sp.tags || ([] as string[]),\n        topics: sp.topics || ([] as string[]),\n        subjects: sp.subjects || ([] as string[]),\n    };\n};\n\nexport const clearNullSearchParams = (p: URLSearchParams) => {\n    for (const k of p.keys()) {\n        let val = p.get(k);\n        if (!val) {\n            p.delete(k);\n        }\n    }\n    return p;\n};\n"]}