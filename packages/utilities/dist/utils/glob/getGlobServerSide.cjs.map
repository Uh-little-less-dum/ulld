{"version":3,"sources":["../../../src/utils/glob/getGlobServerSide.ts","../../../src/schemas/filePath/filePathInput.ts","../../../src/utils/fsUtils.ts"],"names":[],"mappings":";AACA,SAAS,YAAY;AAErB,OAAO,QAAQ;AACf,OAAO,UAAU;;;ACJjB,SAAS,SAAS;AAEX,IAAM,0BAA0B,EAAE,OAAO;AAAA,EAC5C,MAAM,EAAE,OAAO,EAAE,QAAQ,MAAM,EAAE,UAAU,CAAC,MAAM,EAAE,WAAW,GAAG,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC;AAAA,EACpF,MAAM,EACD,MAAM,CAAC,EAAE,QAAQ,MAAM,GAAG,EAAE,QAAQ,OAAO,GAAG,EAAE,QAAQ,cAAc,CAAC,CAAC,EACxE,QAAQ,OAAO;AAAA,EACpB,QAAQ,EAAE,MAAM,CAAC,EAAE,OAAO,GAAG,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC,EAAE,QAAQ;AAAA,EAC1D,UAAU,EAAE,MAAM,CAAC,EAAE,QAAQ,UAAU,GAAG,EAAE,QAAQ,cAAc,CAAC,CAAC,EAAE,QAAQ,UAAU;AAC5F,CAAC;;;ACPD,OAAO,WAAW;AAEX,IAAM,mBAAmB,CAAC,MAC7B,EAAE,WAAW,GAAG,IAAI,IAAI,IAAI,CAAC;;;AFK1B,IAAM,oBAAoB,OAC7B,OACA,cACC;AACD,MAAI,QAAQ,wBAAwB,MAAM,KAAK;AAC/C,MAAI,MAAO,MAAM;AAAA,IACb,MAAM;AAAA,IACN;AAAA,MACI,KAAK,UAAU;AAAA,MACf,QAAQ,MAAM,UAAU;AAAA,MACxB,OAAO,MAAM,SAAS;AAAA,IAC1B;AAAA,EACJ;AACA,MAAI,iBAAiB,MAAM,aAAa;AACxC,MAAI,gBAAgB;AAChB,UAAM,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,UAAU,QAAQ,CAAC,CAAC;AAAA,EACvD,OAAO;AACH,UAAM,IAAI,IAAI,CAAC,MAAM,iBAAiB,CAAC,CAAC;AAAA,EAC5C;AACA,MAAI,MAAM,SAAS,QAAQ;AACvB,UAAM,IAAI;AAAA,MAAO,CAAC,MACd,GACK,SAAS,iBAAiB,IAAI,KAAK,KAAK,UAAU,QAAQ,CAAC,CAAC,EAC5D,YAAY;AAAA,IACrB;AAAA,EACJ;AACA,SAAO;AACX","sourcesContent":["import { AppConfigSchemaOutput } from \"@ulld/types\";\nimport { glob } from \"glob\";\nimport { z } from \"zod\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { filePathGlobPropsSchema } from \"../../schemas/filePath/filePathInput.js\";\nimport { withForwardSlash } from \"../fsUtils.js\";\n\nexport type GlobInput = z.input<typeof filePathGlobPropsSchema>;\n\nexport const getGlobServerSide = async (\n    props: GlobInput,\n    appConfig: AppConfigSchemaOutput,\n) => {\n    let input = filePathGlobPropsSchema.parse(props);\n    let res = (await glob(\n        input.glob,\n        {\n            cwd: appConfig.fsRoot,\n            ignore: input.ignore || undefined,\n            nodir: input.type === \"files\",\n        },\n    )) as string[];\n    let returnAbsolute = input.returnAs === \"absolute\";\n    if (returnAbsolute) {\n        res = res.map((x) => path.join(appConfig.fsRoot, x));\n    } else {\n        res = res.map((x) => withForwardSlash(x));\n    }\n    if (input.type === \"dirs\") {\n        res = res.filter((x) =>\n            fs\n                .statSync(returnAbsolute ? x : path.join(appConfig.fsRoot, x))\n                .isDirectory(),\n        );\n    }\n    return res;\n};\n","import { z } from \"zod\";\n\nexport const filePathGlobPropsSchema = z.object({\n    glob: z.string().default(\"**/*\").transform((x) => x.startsWith(\"/\") ? x.slice(1) : x),\n    type: z\n        .union([z.literal(\"dirs\"), z.literal(\"files\"), z.literal(\"dirsAndFiles\")])\n        .default(\"files\"),\n    ignore: z.union([z.string(), z.string().array()]).nullish(),\n    returnAs: z.union([z.literal(\"absolute\"), z.literal(\"rootRelative\")]).default(\"absolute\"),\n});\n","import { filePathGlobPropsSchema } from \"../schemas/filePath/filePathInput.js\";\nimport { z } from \"zod\";\nimport axios from \"axios\";\n\nexport const withForwardSlash = (p: string) =>\n    p.startsWith(\"/\") ? p : `/${p}`;\n\nexport const withForwardSlashOptional = (p?: string) =>\n    typeof p === \"undefined\" ? undefined : withForwardSlash(p);\n\nexport const noTrailingSlash = (p: string) =>\n    p.endsWith(\"/\") ? p.slice(0, p.length - 1) : p;\n\nexport const withTrailingSlash = (p: string) => (p.endsWith(\"/\") ? p : `${p}/`);\n\nexport const makeHref = (s: string) => {\n    if (/^http(s?):\\/\\//gm.test(s)) {\n        return s;\n    }\n    if(typeof window === \"undefined\"){\n        return s\n    }\n    let isHttps = window?.location?.href.startsWith(\"http\")\n        ? window.location.href.startsWith(\"https\")\n        : process.env.NEXT_PUBLIC_PRODUCTION_REMOTE;\n    return `${isHttps ? \"https\" : \"http\"}://${s}`;\n};\n\nexport const noLeadingSlash = (p: string) =>\n    p.startsWith(\"/\") ? p.slice(1, p.length) : p;\n\nexport const setSlashes = ({\n    value,\n    leading,\n    trailing,\n}: {\n    value: string;\n    leading: boolean;\n    trailing: boolean;\n}) => {\n    let v = value;\n    v = leading ? withForwardSlash(v) : noLeadingSlash(v);\n    v = trailing ? withTrailingSlash(v) : noTrailingSlash(v);\n    return v;\n};\n\nexport const parentDir = (p: string) =>\n    p.indexOf(\"/\") >= 0 ? p.slice(0, p.lastIndexOf(\"/\")) : p;\n\nexport const getFilenameFromString = (p: string) =>\n    p.indexOf(\"/\") === -1 ? p : p.slice(p.lastIndexOf(\"/\") + 1, p.length);\n\nexport const ensureRootRelative = (p: string, fsRoot: string) =>\n    withForwardSlash(p.indexOf(fsRoot) === -1 ? p : p.split(fsRoot)[1]);\n\nexport const ensureAbsolute = (p: string, fsRoot: string) => {\n    return p.includes(fsRoot)\n        ? p\n        : `${fsRoot}${setSlashes({ value: p, leading: true, trailing: false })}`;\n};\n\nexport const getParentDirAndFilename = (\n    p: string,\n    ensureRootRelativeParent: boolean = true,\n    fsRoot: string,\n) => {\n    return {\n        parent: ensureRootRelativeParent\n            ? ensureRootRelative(parentDir(p), fsRoot)\n            : parentDir(p),\n        filename: getFilenameFromString(p),\n    };\n};\n\nexport const fileExtension = (path: string) => {\n    return path.split(\".\").at(-1);\n};\n\nexport const replacePrefix = (\n    content: string,\n    regex: string,\n    replaceWith: string = \"\",\n) => {\n    return content.startsWith(regex)\n        ? `${replaceWith}${content.split(regex)[1]}`\n        : content;\n};\n\nexport const replaceAppendix = (\n    content: string,\n    regex: string,\n    replaceWith: string = \"\",\n) => {\n    return content.endsWith(regex)\n        ? `${content.slice(0, content.length - regex.length)}${replaceWith}`\n        : content;\n};\n\nexport const getFsRootGlob = async (\n    props: z.input<typeof filePathGlobPropsSchema>,\n) => {\n    try {\n        let res = await axios.post(\"/api/glob\", props);\n        if(res.data.filePaths){\n            return res.data.filePaths as string[];\n        }\n    } catch (err) {\n        console.error(err);\n    }\n};\n"]}