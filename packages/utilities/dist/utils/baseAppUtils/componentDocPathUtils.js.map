{"version":3,"sources":["../../../src/utils/baseAppUtils/componentDocPathUtils.ts"],"names":["path"],"mappings":";;;;;;AAAA,OAAO,UAAU;AAEjB,OAAO,QAAQ;AAIR,IAAM,uCAAuC,CAChD,YACA,eACA,OAAgB,OAChB,gBACC;AACD,SAAO,KAAK;AAAA,IACR,eAAe,QAAQ,IAAI;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,OAAO,SAAS;AAAA,IAChB,UAAU,UAAU;AAAA,IACpB,GAAG,UAAU,aAAa,CAAC;AAAA,EAC/B;AACJ;AAGO,IAAM,+BAA+B,CAAC,UAAoC;AAC7E,MAAI,MAAM,IAAI,gBAAgB;AAC9B,MAAG,MAAM,KAAI;AACT,KAAC,MAAM,QAAQ,MAAM,GAAG,IAAI,MAAM,MAAM,CAAC,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,IAAI,OAAO,OAAO,CAAC,CAAC;AAAA,EAC5F;AACA,MAAG,MAAM,MAAK;AACV,QAAI,IAAI,QAAQ,MAAM;AAAA,EAC1B;AACA,MAAG,MAAM,OAAM;AACX,QAAI,IAAI,SAAS,MAAM,KAAK;AAAA,EAChC;AACA,MAAG,MAAM,QAAO;AACZ,QAAI,IAAI,UAAU,MAAM,MAAM;AAAA,EAClC;AACA,MAAG,MAAM,UAAS;AACd,QAAI,IAAI,YAAY,MAAM,QAAQ;AAAA,EACtC;AACA,SAAO,kBAAkB,IAAI,SAAS,CAAC;AAC3C;AAEO,IAAM,iCAAiC,CAC1C,MACA,OAAgB,UACf;AACD,SAAO;AAAA,IACH,KAAK;AAAA,IACL,KAAK;AAAA,IACL;AAAA,EACJ;AACJ;AAEO,IAAM,kCAAkC,OAC3C,MACA,OAAgB,UACf;AACD,MAAIA,QAAO,+BAA+B,MAAM,IAAI;AACpD,MAAI,CAACA,SAAQ,CAAC,GAAG,WAAWA,KAAI,GAAG;AAC/B;AAAA,EACJ;AACA,SAAO,MAAM,GAAG,SAAS,SAASA,OAAM,EAAE,UAAU,QAAQ,CAAC;AACjE;AAEO,IAAM,kBAAkB,CAC3B,WACA,UACC;AACD,MAAI,WAAW,IAAI,mBAAmB;AACtC,SAAO,SAAS,SAAS,UAAU,eAAe,KAAK;AAC3D;AAEO,IAAM,2BAA2B,OACpC,WACA,YACA,eACA,OAAgB,OAChB,iCAA0C,SACzC;AACD,MAAI,OAAO,UAAU,cAAc;AAAA,IAAK,CAAC,MACrC,QAAQ,EAAE,eAAe,cAAc,EAAE,kBAAkB,aAAa;AAAA,EAC5E;AACA,MAAG,MAAM;AACL,QAAI,UAAU,MAAM,gCAAgC,MAAM,IAAI;AAC9D,QAAG,CAAC,WAAW,gCAA+B;AAC1C,gBAAU,MAAM,gCAAgC,MAAM,CAAC,IAAI;AAAA,IAC/D;AACA,WAAO;AAAA,MACH;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AACJ","sourcesContent":["import path from \"path\";\nimport { BuildStaticDataOutput } from \"@ulld/types\";\nimport fs from \"fs\";\nimport { ComponentDocsQueryParams } from \"../../types/baseApp/componentDocsQuery.js\";\nimport { ComponentDocsQuery } from \"../../classes/query/componentDocs.js\";\n\nexport const componentDocsPathFromPluginComponent = (\n    pluginName: string,\n    componentName: string,\n    full: boolean = false,\n    projectRoot?: string,\n) => {\n    return path.join(\n        projectRoot || process.cwd(),\n        \"generatedMarkdown\",\n        \"componentDocs\",\n        full ? \"full\" : \"short\",\n        encodeURI(pluginName),\n        `${encodeURI(componentName)}.mdx`,\n    );\n};\n\n\nexport const componentDocQueryObjectToUrl = (query: ComponentDocsQueryParams) => {\n    let url = new URLSearchParams()\n    if(query.tag){\n        (Array.isArray(query.tag) ? query.tag : [query.tag]).forEach((t) => url.append(\"tag\", t))\n    }\n    if(query.full){\n        url.set(\"full\", \"true\")\n    }\n    if(query.query){\n        url.set(\"query\", query.query)\n    }\n    if(query.syntax){\n        url.set(\"syntax\", query.syntax)\n    }\n    if(query.pluginId){\n        url.set(\"pluginId\", query.pluginId)\n    }\n    return `/componentDocs?${url.toString()}`\n}\n\nexport const docItemToComponentDocsFilePath = (\n    item: BuildStaticDataOutput[\"componentDocs\"][number],\n    full: boolean = false,\n) => {\n    return componentDocsPathFromPluginComponent(\n        item.pluginName,\n        item.componentName,\n        full,\n    );\n};\n\nexport const getComponentDocsContentFromItem = async (\n    item: BuildStaticDataOutput[\"componentDocs\"][number],\n    full: boolean = false,\n) => {\n    let path = docItemToComponentDocsFilePath(item, full);\n    if (!path || !fs.existsSync(path)) {\n        return;\n    }\n    return await fs.promises.readFile(path, { encoding: \"utf-8\" });\n};\n\nexport const getItemsByQuery = (\n    buildData: BuildStaticDataOutput,\n    query: ComponentDocsQueryParams,\n) => {\n    let docQuery = new ComponentDocsQuery();\n    return docQuery.queryAll(buildData.componentDocs, query);\n};\n\nexport const getPluginDocContentByIds = async (\n    buildData: BuildStaticDataOutput,\n    pluginName: string,\n    componentName: string,\n    full: boolean = false,\n    permitOppositeOfFullIfNotFound: boolean = true\n) => {\n    let item = buildData.componentDocs.find((x) =>\n        Boolean(x.pluginName === pluginName && x.componentName === componentName),\n    );\n    if(item) {\n        let content = await getComponentDocsContentFromItem(item, full)\n        if(!content && permitOppositeOfFullIfNotFound){\n            content = await getComponentDocsContentFromItem(item, !full)\n        }\n        return {\n            item,\n            content\n        }\n    }\n};\n"]}