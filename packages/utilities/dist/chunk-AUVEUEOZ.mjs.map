{"version":3,"sources":["../src/parsingUtilities/mdx/getNoteTypeDataFromPath.ts"],"names":["sortNoteTypeDataForParsing","appConfig","a","b","s","getNoteTypeDataFromPath","rootRelativePath","preSortedNoteTypes","f"],"mappings":"AAKO,IAAMA,EACVC,GAEQA,EAAU,UACZ,KAAK,CAACC,EAAGC,IAAMA,EAAE,GAAG,OAASD,EAAE,GAAG,MAAM,EACxC,IAAKE,IAAO,CACT,GAAGA,EACH,GAAIA,EAAE,GAAG,WAAW,GAAG,EAAIA,EAAE,GAAG,MAAM,CAAC,EAAIA,EAAE,EACjD,EAAE,EAGGC,EAA0B,CACnCC,EACAL,EACAM,KAEeA,GAAsBP,EAA8BC,CAAS,GACjD,KAAMO,GAAMF,EAAiB,SAASE,EAAE,EAAE,CAAC","sourcesContent":["import type {\n    MinimalParsableAppConfigOutput,\n} from \"@ulld/types\";\n\n\nexport const sortNoteTypeDataForParsing = <T extends MinimalParsableAppConfigOutput>(\n   appConfig: T,\n): (T[\"noteTypes\"][number] & {fs: string})[] => {\n    return appConfig.noteTypes\n        .sort((a, b) => b.fs.length - a.fs.length)\n        .map((s) => ({\n            ...s,\n            fs: s.fs.startsWith(\"/\") ? s.fs.slice(1) : s.fs,\n        }));\n};\n\nexport const getNoteTypeDataFromPath = <T extends MinimalParsableAppConfigOutput>(\n    rootRelativePath: string,\n    appConfig: T,\n    preSortedNoteTypes?: ReturnType<typeof sortNoteTypeDataForParsing>,\n): T[\"noteTypes\"][number] | undefined => {\n    const sorted = preSortedNoteTypes || sortNoteTypeDataForParsing<T>(appConfig);\n    const docTypeData = sorted.find((f) => rootRelativePath.includes(f.fs));\n    return docTypeData;\n};\n"]}