{"version":3,"sources":["../../../src/commands/generateTunnel/index.tsx"],"names":["Box","Text","argument","option","React","z","globSync","path","logSymbols","fs","args","options","ExportedPath","exportedPath","ulldBlue","getExportString","filePath","sourceFile","fileExt","exportType","fpData","fp","GenerateTunnelFile","_cwd","filePaths","tunnelPath","fileContent","f","generateTunnel_default"],"mappings":"6CAAA,OAAS,OAAAA,EAAK,QAAAC,MAAY,MAC1B,OAAS,YAAAC,EAAU,UAAAC,MAAc,SACjC,OAAOC,MAAW,QAClB,OAAS,KAAAC,MAAS,MAClB,OAAS,YAAAC,MAAgB,OACzB,OAAOC,MAAU,OACjB,OAAOC,MAAgB,cACvB,OAAOC,MAAQ,KAGR,IAAMC,EAAOL,EAAE,MAAM,CACxBA,EACK,OAAO,EACP,QAAQ,GAAG,EACX,SACGH,EAAS,CACL,KAAM,OACN,YAAa,mDACb,wBAAyB,KAC7B,CAAC,CACL,EACJG,EAAE,OAAO,EAAE,QAAQ,KAAK,EAAE,SAASH,EAAS,CACxC,KAAM,iBACN,YAAa,kDACjB,CAAC,CAAC,CACN,CAAC,EAEYS,EAAUN,EAAE,OAAO,CAC5B,QAASA,EACJ,OAAO,EACP,MAAM,EACN,SAAS,EACT,SACGF,EAAO,CACH,YAAa,oDACb,MAAO,GACX,CAAC,CACL,EACJ,KAAME,EACD,OAAO,EACP,QAAQ,eAAe,EACvB,SAAS,0CAA0C,EACxD,OAAQA,EAAE,QAAQ,EAAE,SAChBF,EAAO,CACH,YAAa,2BACjB,CAAC,CACL,CACJ,CAAC,EAWKS,EAAe,CAAC,CAAE,aAAAC,CAAa,IAE7BT,EAAA,cAACJ,EAAA,CACG,cAAc,MACd,eAAe,SACf,WAAW,aACX,IAAK,EACL,aAAc,GACd,cAAe,IAEfI,EAAA,cAACH,EAAA,CAAK,MAAOa,GAAWN,EAAW,OAAQ,EAC3CJ,EAAA,cAACH,EAAA,KAAMY,CAAa,CACxB,EAIFE,EAAkB,CACpBC,EACAC,EACAC,EACAC,IACC,CACD,GAAI,CAACA,EAAY,CACb,IAAIC,EAASb,EAAK,MAAMS,CAAQ,EAChCA,EAAWT,EAAK,KAAKa,EAAO,IAAK,GAAGA,EAAO,IAAI,GAAGF,CAAO,EAAE,CAC/D,CACA,IAAIG,EAAKd,EAAK,SAASA,EAAK,QAAQU,CAAU,EAAGD,CAAQ,EAIzD,OAHKK,EAAG,WAAW,GAAG,IAClBA,EAAKA,EAAG,WAAW,GAAG,EAAI,IAAIA,CAAE,GAAK,KAAKA,CAAE,IAE5CF,EACO,uBAAuBE,CAAE,KAE7B,kBAAkBA,CAAE,IAC/B,EAEMC,EAAqB,CAAC,CAAE,KAAAZ,EAAM,QAAAC,CAAQ,IAA+B,CACvE,IAAMY,EAAOhB,EAAK,WAAWG,EAAK,CAAC,CAAC,EAC9BA,EAAK,CAAC,EACNH,EAAK,QAAQ,QAAQ,IAAI,EAAGG,EAAK,CAAC,CAAC,EACnCc,EAAYlB,EAASK,EAAQ,KAAM,CACrC,IAAKY,EACL,MAAO,GACP,SAAU,GACV,OAAQ,CAAC,GAAIZ,EAAQ,SAAW,CAAC,EAAI,UAAU,CACnD,CAAC,EAEGc,EAAalB,EAAK,KAAKgB,EAAM,UAAU,EAEvCG,EAAcF,EACb,IAAIH,GAAMN,EAAgBM,EAAII,EAAYf,EAAK,CAAC,EAAGC,EAAQ,MAAM,CAAC,EAClE,KAAK;AAAA,CAAI,EAEd,OAAAF,EAAG,cAAcgB,EAAYC,EAAa,CAAE,SAAU,OAAQ,CAAC,EAG3DtB,EAAA,cAACJ,EAAA,CAAI,cAAc,SAAS,eAAe,SAAS,WAAW,cAC1DwB,EAAU,IAAIG,GACJvB,EAAA,cAACQ,EAAA,CAAa,aAAce,EAAG,IAAKA,EAAG,CACjD,CACL,CAER,EAEAL,EAAmB,YAAc,qBAEjC,IAAOM,EAAQN","sourcesContent":["import { Box, Text } from 'ink';\nimport { argument, option } from 'pastel';\nimport React from 'react';\nimport { z } from 'zod';\nimport { globSync } from 'glob';\nimport path from 'path';\nimport logSymbols from 'log-symbols';\nimport fs from 'fs';\nimport { ulldBlue } from '../../staticData/main.js';\n\nexport const args = z.tuple([\n    z\n        .string()\n        .default('.')\n        .describe(\n            argument({\n                name: 'path',\n                description: 'Directory at which tunnel file should be created',\n                defaultValueDescription: 'cwd',\n            }),\n        ),\n    z.string().default(\".js\").describe(argument({\n        name: \"file extension\",\n        description: \"File extension to append to imported file paths.\"\n    }))\n]);\n\nexport const options = z.object({\n    exclude: z\n        .string()\n        .array()\n        .optional()\n        .describe(\n            option({\n                description: 'File globs to exclude from generated tunnel file.',\n                alias: 'x',\n            }),\n        ),\n    glob: z\n        .string()\n        .default('**/*.{ts,tsx}')\n        .describe('Glob with which to find files to include'),\n    asType: z.boolean().describe(\n        option({\n            description: 'Export everything as type',\n        }),\n    ),\n});\n\ninterface GenerateTunnelFileProps {\n    args: z.infer<typeof args>;\n    options: z.infer<typeof options>;\n}\n\ninterface ExportedPathProps {\n    exportedPath: string;\n}\n\nconst ExportedPath = ({ exportedPath }: ExportedPathProps) => {\n    return (\n        <Box\n            flexDirection=\"row\"\n            justifyContent=\"center\"\n            alignItems=\"flex-start\"\n            gap={2}\n            marginBottom={0.1}\n            paddingBottom={0.1}\n        >\n            <Text color={ulldBlue}>{logSymbols.success}</Text>\n            <Text>{exportedPath}</Text>\n        </Box>\n    );\n};\n\nconst getExportString = (\n    filePath: string,\n    sourceFile: string,\n    fileExt: string,\n    exportType?: boolean,\n) => {\n    if (!exportType) {\n        let fpData = path.parse(filePath);\n        filePath = path.join(fpData.dir, `${fpData.name}${fileExt}`);\n    }\n    let fp = path.relative(path.dirname(sourceFile), filePath);\n    if (!fp.startsWith('.')) {\n        fp = fp.startsWith('/') ? `.${fp}` : `./${fp}`;\n    }\n    if (exportType) {\n        return `export type * from \"${fp}\";`;\n    }\n    return `export * from \"${fp}\";`;\n};\n\nconst GenerateTunnelFile = ({ args, options }: GenerateTunnelFileProps) => {\n    const _cwd = path.isAbsolute(args[0])\n        ? args[0]\n        : path.resolve(process.cwd(), args[0]);\n    const filePaths = globSync(options.glob, {\n        cwd: _cwd,\n        nodir: true,\n        absolute: true,\n        ignore: [...(options.exclude || []), 'index.ts'],\n    });\n\n    let tunnelPath = path.join(_cwd, 'index.ts');\n\n    let fileContent = filePaths\n        .map(fp => getExportString(fp, tunnelPath, args[1], options.asType))\n        .join('\\n');\n\n    fs.writeFileSync(tunnelPath, fileContent, { encoding: 'utf-8' });\n\n    return (\n        <Box flexDirection=\"column\" justifyContent=\"center\" alignItems=\"flex-start\">\n            {filePaths.map(f => {\n                return <ExportedPath exportedPath={f} key={f} />;\n            })}\n        </Box>\n    );\n};\n\nGenerateTunnelFile.displayName = 'GenerateTunnelFile';\n\nexport default GenerateTunnelFile;\n"]}