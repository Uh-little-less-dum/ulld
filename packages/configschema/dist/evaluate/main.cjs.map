{"version":3,"sources":["../../src/evaluate/utils.ts","../../src/evaluate/evaluations/noteTypes.ts","../../src/evaluate/main.ts"],"names":["evaluations"],"mappings":";AAEO,IAAM,qBAAqB,CAC9B,OACA,cACC;AACD,MAAI,OAAqB,CAAC;AAC1B,aAAW,KAAK,OAAO;AACnB,QAAI,WAAW,YAAY,UAAU,CAAC,IAAK;AAC3C,QAAI,KAAK,SAAS,QAAQ,GAAG;AACzB,aAAO;AAAA,IACX,OAAO;AACH,WAAK,KAAK,QAAQ;AAAA,IACtB;AAAA,EACJ;AACA,SAAO;AACX;;;ACVA,IAAM,2BAA2B,CAAC,cAAmE;AACjG,QAAM,gBAAgB,mBAAuC,WAAW,CAAC,SAAS,KAAK,OAAiB;AACxG,MAAG,eAAc;AACb,WAAO;AAAA,MACH,OAAO;AAAA,MACP,MAAM;AAAA,MACN,UAAU;AAAA,MACV,QAAQ;AAAA,IACZ;AAAA,EACJ;AACJ;AAGA,IAAM,cAAc;AAAA,EAChB;AACJ;AAEA,IAAM,oBAAoB,CAAC,QAA+B,YAAgD;AACtG,MAAI,SAAS;AACb,QAAM,YAAY,OAAO;AACzB,aAAW,KAAK,aAAY;AACvB,QAAI,WAAW,EAAE,SAAS;AAC3B,QAAG,UAAS;AACR,aAAO,KAAK,QAAQ;AAAA,IACxB;AAAA,EACJ;AACA,SAAO;AACX;AAEA,IAAO,oBAAQ;;;AC/Bf,IAAMA,eAA8B;AAAA,EAClC;AACF;AAEA,IAAM,oBAAoB,CAAC,cAAmC;AAC1D,MAAI,SAA2B,CAAC;AAEhC,EAAAA,aAAY,QAAQ,CAAC,aAAa;AAC9B,aAAS,SAAS,WAAW,MAAM;AAAA,EACvC,CAAC;AACD,SAAO;AACX;AAGA,IAAO,eAAQ","sourcesContent":["type Comparable = boolean | string | Date | number;\n\nexport const arrayHasDuplicates = <T extends unknown>(\n    items: T[],\n    parseItem?: (item: T) => Comparable,\n) => {\n    let data: Comparable[] = [];\n    for (const k of items) {\n        let itemData = parseItem ? parseItem(k) : (k as Comparable);\n        if (data.includes(itemData)) {\n            return true;\n        } else {\n            data.push(itemData);\n        }\n    }\n    return false;\n};\n","import { DocumentTypeConfig } from \"../../zod/documentConfigSchema.js\";\nimport { AppConfigSchemaOutput } from \"../../zod/main.js\";\nimport { ConfigEvaluationError, EvaluationErrors } from \"../types.js\";\nimport {arrayHasDuplicates} from \"../utils.js\"\n\n\nconst overlappingDocumentTypes = (noteTypes: DocumentTypeConfig[]): ConfigEvaluationError | void  => {\n    const hasDuplicates = arrayHasDuplicates<DocumentTypeConfig>(noteTypes, (item) => item.docType as string)\n    if(hasDuplicates){\n        return {\n            label: \"Duplicate DocumentTypes\",\n            desc: \"Each NoteType has a docType key. This key is used internally for navigation and filtering. You may be seeing this error because two or more of the automatically generated keys overlap. Please fix this by adjusting any overlapping keys so they remain unique.\",\n            severity: \"error\",\n            action: \"docTypesOverlap\"\n        }\n    }\n}\n\n\nconst evaluations = [\n    overlappingDocumentTypes\n]\n\nconst evaluateNoteTypes = (config: AppConfigSchemaOutput, _errors: EvaluationErrors): EvaluationErrors => {\n    let errors = _errors\n    const noteTypes = config.noteTypes as DocumentTypeConfig[]\n    for (const k of evaluations){\n         let newError = k(noteTypes)\n        if(newError){\n            errors.push(newError)\n        }\n    }\n    return errors\n}\n\nexport default evaluateNoteTypes\n","import { AppConfigSchemaType } from \"../zod/main.js\";\nimport { EvalFunction, EvaluationErrors } from \"./types.js\";\nimport noteTypes from \"./evaluations/noteTypes.js\";\n\nconst evaluations: EvalFunction[] = [\n  noteTypes\n];\n\nconst evaluateAppConfig = (appConfig: AppConfigSchemaType) => {\n    let errors: EvaluationErrors = [];\n\n    evaluations.forEach((evalFunc) => {\n        errors = evalFunc(appConfig, errors);\n    });\n    return errors;\n};\n\n\nexport default evaluateAppConfig\n"]}