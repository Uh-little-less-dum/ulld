{"version":3,"sources":["../../src/zod/configUtilitySchemas.ts"],"names":[],"mappings":";AAAA,SAAS,SAAS;AAClB,OAAO,kBAAkB;AACzB,SAAS,wBAAwB;AAG1B,IAAM,iBAAiB,EAAE,MAAM;AAAA,EAClC,EAAE,QAAQ,OAAO;AAAA,EACjB,EAAE,QAAQ,SAAS;AAAA,EACnB,EAAE,QAAQ,MAAM;AAAA,EAChB,EAAE,QAAQ,MAAM;AACpB,CAAC;AAIM,IAAM,uBAAuB,CAAC,MAGhC;AACD,MAAI,OAAO,MAAM,UAAU;AACvB,WAAO;AAAA,MACH,UAAU;AAAA,MACV,OAAO,aAAa,GAAG,EAAE,UAAU,MAAM,UAAU,KAAK,CAAC;AAAA,IAC7D;AAAA,EACJ;AACA,SAAO;AAAA,IACH,UAAU,EAAE;AAAA,IACZ,OAAO;AAAA,EACX;AACJ;AAEO,IAAM,+BAA+B,CAAsC,MAAS;AACvF,MAAI,GAAG;AACH,WAAO,iBAAiB,CAAC;AAAA,EAC7B;AACA,SAAO;AACX;AAGO,IAAM,qBAAqB,CAAC,MAAe,aAAuB,OAAO,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,IAAI,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAuB,IAAI,EAAE,OAAO,EAAE,SAAS,IAAI,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAW,IAAI,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAuB,IAAI,EAAE,OAAO,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAW;AAI/a,IAAM,uBAAuB,CAAC,MAAe,aAAuB,OAAO,WAAW,EAAE,MAAM;AAAA,EACjG,EAAE,OAAO;AAAA,EACT,EAAE,WAAW,MAAM;AACvB,CAAC,EAAE,SAAS,EAAE,SAAS,IAAI,EAAE,UAAU,CAAC,MAAM,IAAI,qBAAqB,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM;AAAA,EACrF,EAAE,OAAO;AAAA,EACT,EAAE,WAAW,MAAM;AACvB,CAAC,EAAE,SAAS,IAAI,EAAE,UAAU,oBAAoB,IAAI,WAAW,EAAE,MAAM;AAAA,EACnE,EAAE,OAAO;AAAA,EACT,EAAE,WAAW,MAAM;AACvB,CAAC,EAAE,SAAS,EAAE,UAAU,CAAC,MAAM,IAAI,qBAAqB,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM;AAAA,EACtE,EAAE,OAAO;AAAA,EACT,EAAE,WAAW,MAAM;AACvB,CAAC,EAAE,UAAU,oBAAoB","sourcesContent":["import { z } from 'zod'\nimport globToRegExp from 'glob-to-regexp'\nimport { withForwardSlash } from '@ulld/utilities/utils/fsUtils'\n\n\nexport const logLevelSchema = z.union([\n    z.literal(\"debug\"),\n    z.literal(\"verbose\"),\n    z.literal(\"info\"),\n    z.literal(\"none\"),\n])\n\nexport type LogLevel = z.input<typeof logLevelSchema>\n\nexport const zodPathGlobTransform = (a: string | RegExp): {\n    original: string,\n    regex: RegExp\n} => {\n    if (typeof a === \"string\") {\n        return {\n            original: a,\n            regex: globToRegExp(a, { extended: true, globstar: true })\n        }\n    }\n    return {\n        original: a.source,\n        regex: a\n    }\n}\n\nexport const zodWithForwardSlashTransform = <T extends string | null | undefined>(a: T) => {\n    if (a) {\n        return withForwardSlash(a)\n    }\n    return a\n}\n\n\nexport const zodPathStringField = (desc?: string, optional?: boolean) => desc ? optional ? z.string().optional().describe(desc).transform((a) => a && withForwardSlash(a) as string | undefined) : z.string().describe(desc).transform((a) => a && withForwardSlash(a) as string) : optional ? z.string().optional().transform((a) => a && withForwardSlash(a) as string | undefined) : z.string().transform((a) => a && withForwardSlash(a) as string)\n\n\n\nexport const zodPathWithGlobField = (desc?: string, optional?: boolean) => desc ? optional ? z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).optional().describe(desc).transform((a) => a ? zodPathGlobTransform(a) : a) : z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).describe(desc).transform(zodPathGlobTransform) : optional ? z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).optional().transform((a) => a ? zodPathGlobTransform(a) : a) : z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).transform(zodPathGlobTransform)\n\n"]}