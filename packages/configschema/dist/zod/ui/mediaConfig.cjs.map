{"version":3,"sources":["../../../src/zod/ui/mediaConfig.ts","../../../src/zod/configUtilitySchemas.ts"],"names":["z"],"mappings":";AAAA,SAAS,KAAAA,UAAS;;;ACAlB,SAAS,SAAS;AAClB,OAAO,kBAAkB;AACzB,SAAS,wBAAwB;AAG1B,IAAM,iBAAiB,EAAE,MAAM;AAAA,EAClC,EAAE,QAAQ,OAAO;AAAA,EACjB,EAAE,QAAQ,SAAS;AAAA,EACnB,EAAE,QAAQ,MAAM;AAAA,EAChB,EAAE,QAAQ,MAAM;AACpB,CAAC;AA4BM,IAAM,qBAAqB,CAAC,MAAe,aAAuB,OAAO,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,IAAI,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAuB,IAAI,EAAE,OAAO,EAAE,SAAS,IAAI,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAW,IAAI,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAuB,IAAI,EAAE,OAAO,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAW;;;ADlC/a,IAAM,oBAAoBA,GAAE,OAAO;AAAA,EACtC,UAAUA,GAAE,OAAOA,GAAE,OAAO,EAAE,SAAS,iEAAiE,GAAG,mBAAmB,4DAA4D,CAAC,EAAE,QAAQ,CAAC,CAAC;AAAA,EACvM,wBAAwBA,GAAE,QAAQ,EAAE,QAAQ,IAAI,EAAE,SAAS,+NAA+N;AAAA,EAC1R,iBAAiBA,GAAE,WAAW,MAAM,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;AAC5D,CAAC,EACA,QAAQ,CAAC,CAAC","sourcesContent":["import { z } from \"zod\";\nimport { zodPathStringField } from \"../configUtilitySchemas.js\";\n\n\nexport const mediaConfigSchema = z.object({\n    imageMap: z.record(z.string().describe(\"An alias to more easily embed this image throughout your notes.\"), zodPathStringField(\"The fsRoot relative path at which this image can be found.\")).default({}),\n    includeDefaultImageMap: z.boolean().default(true).describe(\"Whether or not to include a default image map of light weight svg images that respond to the theme's colors to be easily embedded by their alias. Can be disabled to minimize the build size if they are unlikely to be used.\"),\n    imageRemoteTest: z.instanceof(RegExp).array().default([]),\n})\n.default({})\n// .transform((a) => {\n//     return {\n//         ...a,\n//         imageMap: a.includeDefaultImageMap ? {\n//             ...a,\n//         } : a\n//     }\n// })\n","import { z } from 'zod'\nimport globToRegExp from 'glob-to-regexp'\nimport { withForwardSlash } from '@ulld/utilities/utils/fsUtils'\n\n\nexport const logLevelSchema = z.union([\n    z.literal(\"debug\"),\n    z.literal(\"verbose\"),\n    z.literal(\"info\"),\n    z.literal(\"none\"),\n])\n\nexport type LogLevel = z.input<typeof logLevelSchema>\n\nexport const zodPathGlobTransform = (a: string | RegExp): {\n    original: string,\n    regex: RegExp\n} => {\n    if (typeof a === \"string\") {\n        return {\n            original: a,\n            regex: globToRegExp(a, { extended: true, globstar: true })\n        }\n    }\n    return {\n        original: a.source,\n        regex: a\n    }\n}\n\nexport const zodWithForwardSlashTransform = <T extends string | null | undefined>(a: T) => {\n    if (a) {\n        return withForwardSlash(a)\n    }\n    return a\n}\n\n\nexport const zodPathStringField = (desc?: string, optional?: boolean) => desc ? optional ? z.string().optional().describe(desc).transform((a) => a && withForwardSlash(a) as string | undefined) : z.string().describe(desc).transform((a) => a && withForwardSlash(a) as string) : optional ? z.string().optional().transform((a) => a && withForwardSlash(a) as string | undefined) : z.string().transform((a) => a && withForwardSlash(a) as string)\n\n\n\nexport const zodPathWithGlobField = (desc?: string, optional?: boolean) => desc ? optional ? z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).optional().describe(desc).transform((a) => a ? zodPathGlobTransform(a) : a) : z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).describe(desc).transform(zodPathGlobTransform) : optional ? z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).optional().transform((a) => a ? zodPathGlobTransform(a) : a) : z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).transform(zodPathGlobTransform)\n\n"]}