{"version":3,"sources":["../../../src/zod/math/main.ts","../../../src/zod/configUtilitySchemas.ts"],"names":["z"],"mappings":";AAAA,SAAS,KAAAA,UAAS;;;ACAlB,SAAS,SAAS;AAClB,OAAO,kBAAkB;AACzB,SAAS,wBAAwB;AAG1B,IAAM,iBAAiB,EAAE,MAAM;AAAA,EAClC,EAAE,QAAQ,OAAO;AAAA,EACjB,EAAE,QAAQ,SAAS;AAAA,EACnB,EAAE,QAAQ,MAAM;AAAA,EAChB,EAAE,QAAQ,MAAM;AACpB,CAAC;AA4BM,IAAM,qBAAqB,CAAC,MAAe,aAAuB,OAAO,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,IAAI,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAuB,IAAI,EAAE,OAAO,EAAE,SAAS,IAAI,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAW,IAAI,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAuB,IAAI,EAAE,OAAO,EAAE,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAW;;;ADlC/a,IAAM,mBAAmBA,GAAE,OAAO;AAAA,EACrC,eAAeA,GAAE,MAAM,CAACA,GAAE,OAAO,EAAE,MAAM,EAAE,SAAS,mGAAmG,GAAGA,GAAE,QAAQ,KAAK,CAAC,CAAC,EAAE,QAAQ,KAAK;AAAA,EAC1L,cAAc,mBAAmB,yLAAyL,IAAI;AAAA,EAC9N,WAAWA,GAAE,OAAOA,GAAE,OAAO,GAAGA,GAAE,OAAO,CAAC,EAAE,QAAQ,CAAC,CAAC;AAC1D,CAAC,EAAE,QAAQ,CAAC,CAAC","sourcesContent":["import { z } from \"zod\";\nimport { zodPathStringField } from \"../configUtilitySchemas.js\";\n\n\nexport const mathConfigSchema = z.object({\n    latexPackages: z.union([z.string().array().describe(\"Latex packages to be loaded internally. Packages must be supported and available through MathJax.\"), z.literal(\"all\")]).default(\"all\"),\n    latexFontUrl: zodPathStringField(\"URL of the latex font to be used. This should be left to it's default value unless an additional collection of .woff files are included in the build.additionalPublicResources field.\", true),\n    constants: z.record(z.string(), z.number()).default({})\n}).default({})\n","import { z } from 'zod'\nimport globToRegExp from 'glob-to-regexp'\nimport { withForwardSlash } from '@ulld/utilities/utils/fsUtils'\n\n\nexport const logLevelSchema = z.union([\n    z.literal(\"debug\"),\n    z.literal(\"verbose\"),\n    z.literal(\"info\"),\n    z.literal(\"none\"),\n])\n\nexport type LogLevel = z.input<typeof logLevelSchema>\n\nexport const zodPathGlobTransform = (a: string | RegExp): {\n    original: string,\n    regex: RegExp\n} => {\n    if (typeof a === \"string\") {\n        return {\n            original: a,\n            regex: globToRegExp(a, { extended: true, globstar: true })\n        }\n    }\n    return {\n        original: a.source,\n        regex: a\n    }\n}\n\nexport const zodWithForwardSlashTransform = <T extends string | null | undefined>(a: T) => {\n    if (a) {\n        return withForwardSlash(a)\n    }\n    return a\n}\n\n\nexport const zodPathStringField = (desc?: string, optional?: boolean) => desc ? optional ? z.string().optional().describe(desc).transform((a) => a && withForwardSlash(a) as string | undefined) : z.string().describe(desc).transform((a) => a && withForwardSlash(a) as string) : optional ? z.string().optional().transform((a) => a && withForwardSlash(a) as string | undefined) : z.string().transform((a) => a && withForwardSlash(a) as string)\n\n\n\nexport const zodPathWithGlobField = (desc?: string, optional?: boolean) => desc ? optional ? z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).optional().describe(desc).transform((a) => a ? zodPathGlobTransform(a) : a) : z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).describe(desc).transform(zodPathGlobTransform) : optional ? z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).optional().transform((a) => a ? zodPathGlobTransform(a) : a) : z.union([\n    z.string(),\n    z.instanceof(RegExp)\n]).transform(zodPathGlobTransform)\n\n"]}