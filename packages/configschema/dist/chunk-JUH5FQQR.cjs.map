{"version":3,"sources":["../src/zod/configUtilitySchemas.ts"],"names":[],"mappings":";AAAA,SAAS,SAAS;AAClB,OAAO,kBAAkB;AACzB,SAAS,wBAAwB;AAE1B,IAAM,iBAAiB,EAAE,MAAM;AAAA,EAClC,EAAE,QAAQ,OAAO;AAAA,EACjB,EAAE,QAAQ,SAAS;AAAA,EACnB,EAAE,QAAQ,MAAM;AAAA,EAChB,EAAE,QAAQ,MAAM;AACpB,CAAC;AASM,IAAM,uBAAuB,CAChC,MACoB;AACpB,MAAI,OAAO,MAAM,UAAU;AACvB,WAAO;AAAA,MACH,UAAU;AAAA,MACV,OAAO,aAAa,GAAG,EAAE,UAAU,MAAM,UAAU,KAAK,CAAC;AAAA,IAC7D;AAAA,EACJ;AACA,MAAI,OAAO,MAAM,YAAY,cAAc,KAAK,WAAW,GAAG;AAC1D,WAAO;AAAA,EACX;AACA,SAAO;AAAA,IACH,UAAU,EAAE;AAAA,IACZ,OAAO;AAAA,EACX;AACJ;AAEO,IAAM,+BAA+B,CAGxC,MACC;AACD,MAAI,GAAG;AACH,WAAO,iBAAiB,CAAC;AAAA,EAC7B;AACA,SAAO;AACX;AAEO,IAAM,qBAAqB,CAAC,MAAe,aAC9C,OACM,WACI,EACG,OAAO,EACP,SAAS,EACT,SAAS,IAAI,EACb,UAAU,CAAC,MAAM,KAAM,iBAAiB,CAAC,CAAwB,IACpE,EACG,OAAO,EACP,SAAS,IAAI,EACb,UAAU,CAAC,MAAM,KAAM,iBAAiB,CAAC,CAAY,IAC5D,WACI,EACG,OAAO,EACP,SAAS,EACT,UAAU,CAAC,MAAM,KAAM,iBAAiB,CAAC,CAAwB,IACpE,EAAE,OAAO,EAAE,UAAU,CAAC,MAAM,KAAM,iBAAiB,CAAC,CAAY;AAEvE,IAAM,uBAAuB,CAAC,MAAe,aAChD,OACM,WACI,EACG,MAAM,CAAC,EAAE,OAAO,GAAG,EAAE,WAAW,MAAM,CAAC,CAAC,EACxC,SAAS,EACT,SAAS,IAAI,EACb,UAAU,CAAC,MAAO,IAAI,qBAAqB,CAAC,IAAI,CAAE,IACrD,EACG,MAAM,CAAC,EAAE,OAAO,GAAG,EAAE,WAAW,MAAM,CAAC,CAAC,EACxC,SAAS,IAAI,EACb,UAAU,oBAAoB,IACrC,WACI,EACG,MAAM,CAAC,EAAE,OAAO,GAAG,EAAE,WAAW,MAAM,CAAC,CAAC,EACxC,SAAS,EACT,UAAU,CAAC,MAAO,IAAI,qBAAqB,CAAC,IAAI,CAAE,IACrD,EACG,MAAM,CAAC,EAAE,OAAO,GAAG,EAAE,WAAW,MAAM,CAAC,CAAC,EACxC,UAAU,oBAAoB","sourcesContent":["import { z } from \"zod\";\nimport globToRegExp from \"glob-to-regexp\";\nimport { withForwardSlash } from \"@ulld/utilities/utils/fsUtils\";\n\nexport const logLevelSchema = z.union([\n    z.literal(\"debug\"),\n    z.literal(\"verbose\"),\n    z.literal(\"info\"),\n    z.literal(\"none\"),\n]);\n\nexport type LogLevel = z.input<typeof logLevelSchema>;\n\nexport type ParsedRegExpField = {\n    original: string;\n    regex: RegExp;\n};\n\nexport const zodPathGlobTransform = (\n    a: string | RegExp | ParsedRegExpField,\n): ParsedRegExpField => {\n    if (typeof a === \"string\") {\n        return {\n            original: a,\n            regex: globToRegExp(a, { extended: true, globstar: true }),\n        };\n    }\n    if (typeof a === \"object\" && \"original\" in a && \"regex\" in a) {\n        return a;\n    }\n    return {\n        original: a.source,\n        regex: a,\n    };\n};\n\nexport const zodWithForwardSlashTransform = <\n    T extends string | null | undefined,\n>(\n    a: T,\n) => {\n    if (a) {\n        return withForwardSlash(a);\n    }\n    return a;\n};\n\nexport const zodPathStringField = (desc?: string, optional?: boolean) =>\n    desc\n        ? optional\n            ? z\n                .string()\n                .optional()\n                .describe(desc)\n                .transform((a) => a && (withForwardSlash(a) as string | undefined))\n            : z\n                .string()\n                .describe(desc)\n                .transform((a) => a && (withForwardSlash(a) as string))\n        : optional\n            ? z\n                .string()\n                .optional()\n                .transform((a) => a && (withForwardSlash(a) as string | undefined))\n            : z.string().transform((a) => a && (withForwardSlash(a) as string));\n\nexport const zodPathWithGlobField = (desc?: string, optional?: boolean) =>\n    desc\n        ? optional\n            ? z\n                .union([z.string(), z.instanceof(RegExp)])\n                .optional()\n                .describe(desc)\n                .transform((a) => (a ? zodPathGlobTransform(a) : a))\n            : z\n                .union([z.string(), z.instanceof(RegExp)])\n                .describe(desc)\n                .transform(zodPathGlobTransform)\n        : optional\n            ? z\n                .union([z.string(), z.instanceof(RegExp)])\n                .optional()\n                .transform((a) => (a ? zodPathGlobTransform(a) : a))\n            : z\n                .union([z.string(), z.instanceof(RegExp)])\n                .transform(zodPathGlobTransform);\n"]}