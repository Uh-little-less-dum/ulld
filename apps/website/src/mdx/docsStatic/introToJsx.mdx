---
id: introToJsx
created: 6-10-24
---

# Intro to JSX


**JSX** is an extension of javascript that's used by React as well as several other single page application frameworks. **TSX** is _almost_ identical, except **TSX** adds the ability to more strictly define types. For the purposes of using <LogoAsText />, **TSX** and **JSX** can be referenced interchangeably. 

The primary goal of **JSX** is to add the ability to write multiple different languages in a single file. React components, which are written in **TSX**[^1], work primarily as a render function. React components are functions that either return some sort of valid [**HTML**](https://developer.mozilla.org/en-US/docs/Web/HTML), or `null{:tsx}` if the internal logic determines that nothing visible should be returned.  

Through the great work at the people over at [MDX](https://mdxjs.com), we can now embed entire React components directly in markdown files, with the `.mdx{:sh}` file extension. All of the original functionality of markdown remains intact, and in <LogoAsText /> is actually extended, but users can now include neatly bundled **HTML**, **CSS**, and **Javascript** in pre-defined React components. 

> All you need to know is how to properly pass in the data that these components need to determine what they should return.


## How to read documentation ||how-to-read-docs||

Regardless of whether or not a component is actually built using Typescript (**TSX**), a similar syntax is used to define the properties that any given component accepts. Because these types are often defined in the same file as regular javascript code, they use an intentionally similar syntax, but not an identical syntax to regular javascript.


| Property | Description |
| -------- | ----------- |
| `optionalProperty?` | An optional property is denoted by a following question mark |
| `TypeOne \| TypeTwo` | When multiple types are valid for a given property, this list of valid types is separated by a `\|` symbol |


***

## React Component Syntax

**JSX** intentionally mirrors the appearance of **HTML**, and functions in a very similar manner. React components will always start with a capital letter, where as regular **HTML** elements can also be included in your note, with all **HTML** elements starting with a lower case letter.



### Children Property

All properties are passed into the component using the [syntax below](#normal-jsx-prop-syntax), but children are passed in using a unique syntax.


#### Self Closing Components

If a component does not accept a `children` property, it can be 'self closed' using this syntax:

```tsx "/>"
<SomeComponent name="Some name property" />
```

Components that do not accept `children` can also be closed using this syntax:


```tsx "</"
<SomeComponent name="Some name property">
</SomeComponent>
```

While unnecessary, this follows an identical syntax to components that ***do*** accept children. Notice that when a component is self closing, there is a `/` just before the closing `>`, and only one instance of that component for each time it is rendered. When a component is _not_ self closing, the `/` follows the `<` in the <Ul yellow>second</Ul> tag for each element rendered.

In the example above, the property `name` follows a similar syntax to [other](#normal-jsx-prop-syntax) component properties, and it is possible to pass in `children` in the same manner, but `children` adds the additional ability to pass the value in as:


```tsx
<SomeComponent name="Some name property">
    This is the children property here. This component will now receive two properties, 
    the "name" property, and this "children" property. This is often much more
    readable and easy to change.
</SomeComponent>
```


### Other Component Properties ||normal-jsx-prop-syntax||

Passing in other properties to react components follows a similar syntax to that of the `name` property above, but there are slight variations for different ***types***. All properties can be wrapped in a pair of curly braces as:

```tsx
<SomeComponent name={"Some name property"} />
```

#### Strings ||jsx-string-props||

The use of curly braces is important for other value types, but is optional in _most_ cases for strings. Note that the `name` property in the example above has a value that is still wrapped in quotations along with the curly braces. There is no difference between single and double quotes, and backticks `` ` `` can also be used.[^2]

<Hint>
    If your string property includes a single quotation, wrap it in double quotes. If it has a double quote, wrap it in single quotes. Alternatively, you can escape _special_ characters, including quotes in a string with a `\` before the special character. This is more or less universal across programming languages, and applies to all special characters. Adding a leading `\` removes the _"special"_ meaning of that character, and makes it function as the literal character.
</Hint>

##### String Literals ||jsx-string-literals||

> **Note:** String literals <Ul yellow>must</Ul> be wrapped in curly braces when passed in as a component property. Curly braces are optional with both single and double quotes.

While single quotes and double quotes are interchangable apart from the ability to wrap that same character as described above, backticks add additional functionality. Where as **Python** has `f-strings` with the following syntax:

```py title="phi.py"
phi = 1.618
value = f"Phi is {phi}"
```

Javascript uses backticks to accomplish the same thing:

````tsx title="phi.jsx"
const phi = 1.618
const value = `Phi is ${phi}`
````

Note that `phi` inside of the `` `...${phi}` {:tsx}`` block is just regular javascript. Code inside of the `` `${...}` {:tsx}`` is no longer part of a string. It is regular javascript code that is then inserted into that part of the string. This means that you can do calculations directly in that part of the string, or use variables as I've done in the example above. For example, we can write:

````tsx
<SomeComponent description={`$\\Phi$ is unique in the fact that for $\\Phi=${phi}$, $\\Phi + 1 = ${phi**2}$.`}/>
````

<Hint>
    Note that all latex math in the example above is wrapped in single `$` symbols, since the math should appear _inline_, and the leading `\` that is part of Latex syntax is escaped with another `\`. Just like a `\` can escape other special characters, it can also escape itself. In this case, we are escaping the `\` with another `\` to tell Javascript that the first `\` is not intended to escape another character and should be treated as a literal `\`.
</Hint>

<Admonition title="Children String Properties" type="info" dropdown>

   **MDX** and other markdown to html parsers wrap new lines, including the children property in a paragraph element. This can cause issues in cases where the `children` component is specifically of a type string. <LogoAsText /> attempts to parse these paragraphs dynamically, but in cases of a parsing error where a property of type `string` is critical like in a **JupyterCell** component, you can wrap the `children` in a pair of curly braces with a pair of backticks inside. 

    Backticks allow almost completely plain text writing style, where as certain content like line breaks will throw errors inside of either single or double quoted strings. The end result would look like:

    ````tsx
    <SomeComponent>
    {`This content is now specifically of type string, no matter how many line breaks are added.
    In most cases this won't matter, but if you receive an error related to the type of the children 
    property on a component that requests specifically a type of string, try this syntax.`}
    </SomeComponent>
    ````

</Admonition>


#### Numbers ||jsx-number-props||

As is the case in most programming languages, `"3.14"{:tsx}` is not the same as `3.14{:tsx}`. If a property requires a type of `number`, there is a significant chance that there will be some sort of mathematical operations taking place within that component. Ironically, strings also accept several mathematical functions, but they will return a significantly different value as demonstrated below:

````tsx
const piNumber = 3.14
const piString = "3.14"

let addedNumber = piNumber + 1 // 4.14
let addedString = piString + 1 // "3.141"
````

To pass a number into a React component, simply wrap the value in curly braces ***without*** any quotations.

```tsx
<SomeComponent value={3.14} />
```

<Hint>
    Keep in mind that Javascript has a global `Math{:tsx}` object. You can see documentation for that object [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math). Using that object, we can rewrite the example above as:
</Hint>

````tsx caption="You should definitely check out the Javascript Math object and the functions it provides. There is a number function that will be available on launch day that will significantly extend all properties of type number as well."
<SomeComponent 
    value={Math.PI} // 3.141592653589793
/>
````

#### Boolean Props ||jsx-boolean-props||


#### ReactNode Type

React provides hundreds of it's own types, but one that appears quite often is that of `ReactNode`. The `ReactNode` type is really pretty much anything that React can render _as is_. It accepts a [boolean](#jsx-boolean-props), a [string](#jsx-string-props), a [number](#jsx-number-props), or another ***rendered*** component.

```tsx
<SomeComponent 
    someNumberProperty={Math.PI}
    someStringProperty={`Love ya like a fat kid loves ${Math.PI}`}
    someBooleanProperty={true}
    someReactElementProp={<SomeOtherComponent name="Some property of SomeOtherComponent." />}
    // Do NOT do this:
    // This is actually of type Component.
    // It is a valid type, but not part of the much more common ReactNode type.
    someIncorrectElementProp={SomeOtherComponent} 
/>
```



[^1]: **JSX** is still used on occasion, but is considered exceedingly bad practice if an alternative type safety approach isn't taken.
[^2]: Be careful not to confuse backticks and single quotes for [string literals](#jsx-string-literals). True story: I spent 9 hours in a coffee shop when I was first learning to code, trying to figure out that a single quote, `'`, is not the same as a backtick, `` ` ``. Don't be me.
